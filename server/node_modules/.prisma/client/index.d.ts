
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model ActividadCliente
 * 
 */
export type ActividadCliente = $Result.DefaultSelection<Prisma.$ActividadClientePayload>
/**
 * Model BitacoraCliente
 * 
 */
export type BitacoraCliente = $Result.DefaultSelection<Prisma.$BitacoraClientePayload>
/**
 * Model BitacoraEstilista
 * 
 */
export type BitacoraEstilista = $Result.DefaultSelection<Prisma.$BitacoraEstilistaPayload>
/**
 * Model BloqueoHorarios
 * 
 */
export type BloqueoHorarios = $Result.DefaultSelection<Prisma.$BloqueoHorariosPayload>
/**
 * Model Citas
 * 
 */
export type Citas = $Result.DefaultSelection<Prisma.$CitasPayload>
/**
 * Model DetallesCita
 * 
 */
export type DetallesCita = $Result.DefaultSelection<Prisma.$DetallesCitaPayload>
/**
 * Model EstadoCita
 * 
 */
export type EstadoCita = $Result.DefaultSelection<Prisma.$EstadoCitaPayload>
/**
 * Model HistorialCitas
 * 
 */
export type HistorialCitas = $Result.DefaultSelection<Prisma.$HistorialCitasPayload>
/**
 * Model HistorialRecompensas
 * 
 */
export type HistorialRecompensas = $Result.DefaultSelection<Prisma.$HistorialRecompensasPayload>
/**
 * Model Horarios
 * 
 */
export type Horarios = $Result.DefaultSelection<Prisma.$HorariosPayload>
/**
 * Model HorariosReservados
 * 
 */
export type HorariosReservados = $Result.DefaultSelection<Prisma.$HorariosReservadosPayload>
/**
 * Model PuntosClientes
 * 
 */
export type PuntosClientes = $Result.DefaultSelection<Prisma.$PuntosClientesPayload>
/**
 * Model PuntosServicio
 * 
 */
export type PuntosServicio = $Result.DefaultSelection<Prisma.$PuntosServicioPayload>
/**
 * Model Roles
 * 
 */
export type Roles = $Result.DefaultSelection<Prisma.$RolesPayload>
/**
 * Model Servicios
 * 
 */
export type Servicios = $Result.DefaultSelection<Prisma.$ServiciosPayload>
/**
 * Model Usuarios
 * 
 */
export type Usuarios = $Result.DefaultSelection<Prisma.$UsuariosPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more ActividadClientes
 * const actividadClientes = await prisma.actividadCliente.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more ActividadClientes
   * const actividadClientes = await prisma.actividadCliente.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.actividadCliente`: Exposes CRUD operations for the **ActividadCliente** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActividadClientes
    * const actividadClientes = await prisma.actividadCliente.findMany()
    * ```
    */
  get actividadCliente(): Prisma.ActividadClienteDelegate<ExtArgs>;

  /**
   * `prisma.bitacoraCliente`: Exposes CRUD operations for the **BitacoraCliente** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BitacoraClientes
    * const bitacoraClientes = await prisma.bitacoraCliente.findMany()
    * ```
    */
  get bitacoraCliente(): Prisma.BitacoraClienteDelegate<ExtArgs>;

  /**
   * `prisma.bitacoraEstilista`: Exposes CRUD operations for the **BitacoraEstilista** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BitacoraEstilistas
    * const bitacoraEstilistas = await prisma.bitacoraEstilista.findMany()
    * ```
    */
  get bitacoraEstilista(): Prisma.BitacoraEstilistaDelegate<ExtArgs>;

  /**
   * `prisma.bloqueoHorarios`: Exposes CRUD operations for the **BloqueoHorarios** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BloqueoHorarios
    * const bloqueoHorarios = await prisma.bloqueoHorarios.findMany()
    * ```
    */
  get bloqueoHorarios(): Prisma.BloqueoHorariosDelegate<ExtArgs>;

  /**
   * `prisma.citas`: Exposes CRUD operations for the **Citas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Citas
    * const citas = await prisma.citas.findMany()
    * ```
    */
  get citas(): Prisma.CitasDelegate<ExtArgs>;

  /**
   * `prisma.detallesCita`: Exposes CRUD operations for the **DetallesCita** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DetallesCitas
    * const detallesCitas = await prisma.detallesCita.findMany()
    * ```
    */
  get detallesCita(): Prisma.DetallesCitaDelegate<ExtArgs>;

  /**
   * `prisma.estadoCita`: Exposes CRUD operations for the **EstadoCita** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EstadoCitas
    * const estadoCitas = await prisma.estadoCita.findMany()
    * ```
    */
  get estadoCita(): Prisma.EstadoCitaDelegate<ExtArgs>;

  /**
   * `prisma.historialCitas`: Exposes CRUD operations for the **HistorialCitas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HistorialCitas
    * const historialCitas = await prisma.historialCitas.findMany()
    * ```
    */
  get historialCitas(): Prisma.HistorialCitasDelegate<ExtArgs>;

  /**
   * `prisma.historialRecompensas`: Exposes CRUD operations for the **HistorialRecompensas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HistorialRecompensas
    * const historialRecompensas = await prisma.historialRecompensas.findMany()
    * ```
    */
  get historialRecompensas(): Prisma.HistorialRecompensasDelegate<ExtArgs>;

  /**
   * `prisma.horarios`: Exposes CRUD operations for the **Horarios** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Horarios
    * const horarios = await prisma.horarios.findMany()
    * ```
    */
  get horarios(): Prisma.HorariosDelegate<ExtArgs>;

  /**
   * `prisma.horariosReservados`: Exposes CRUD operations for the **HorariosReservados** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HorariosReservados
    * const horariosReservados = await prisma.horariosReservados.findMany()
    * ```
    */
  get horariosReservados(): Prisma.HorariosReservadosDelegate<ExtArgs>;

  /**
   * `prisma.puntosClientes`: Exposes CRUD operations for the **PuntosClientes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PuntosClientes
    * const puntosClientes = await prisma.puntosClientes.findMany()
    * ```
    */
  get puntosClientes(): Prisma.PuntosClientesDelegate<ExtArgs>;

  /**
   * `prisma.puntosServicio`: Exposes CRUD operations for the **PuntosServicio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PuntosServicios
    * const puntosServicios = await prisma.puntosServicio.findMany()
    * ```
    */
  get puntosServicio(): Prisma.PuntosServicioDelegate<ExtArgs>;

  /**
   * `prisma.roles`: Exposes CRUD operations for the **Roles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.roles.findMany()
    * ```
    */
  get roles(): Prisma.RolesDelegate<ExtArgs>;

  /**
   * `prisma.servicios`: Exposes CRUD operations for the **Servicios** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Servicios
    * const servicios = await prisma.servicios.findMany()
    * ```
    */
  get servicios(): Prisma.ServiciosDelegate<ExtArgs>;

  /**
   * `prisma.usuarios`: Exposes CRUD operations for the **Usuarios** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuarios.findMany()
    * ```
    */
  get usuarios(): Prisma.UsuariosDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.10.2
   * Query Engine version: 5a9203d0590c951969e85a7d07215503f4672eb9
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    ActividadCliente: 'ActividadCliente',
    BitacoraCliente: 'BitacoraCliente',
    BitacoraEstilista: 'BitacoraEstilista',
    BloqueoHorarios: 'BloqueoHorarios',
    Citas: 'Citas',
    DetallesCita: 'DetallesCita',
    EstadoCita: 'EstadoCita',
    HistorialCitas: 'HistorialCitas',
    HistorialRecompensas: 'HistorialRecompensas',
    Horarios: 'Horarios',
    HorariosReservados: 'HorariosReservados',
    PuntosClientes: 'PuntosClientes',
    PuntosServicio: 'PuntosServicio',
    Roles: 'Roles',
    Servicios: 'Servicios',
    Usuarios: 'Usuarios'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'actividadCliente' | 'bitacoraCliente' | 'bitacoraEstilista' | 'bloqueoHorarios' | 'citas' | 'detallesCita' | 'estadoCita' | 'historialCitas' | 'historialRecompensas' | 'horarios' | 'horariosReservados' | 'puntosClientes' | 'puntosServicio' | 'roles' | 'servicios' | 'usuarios'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      ActividadCliente: {
        payload: Prisma.$ActividadClientePayload<ExtArgs>
        fields: Prisma.ActividadClienteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActividadClienteFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ActividadClientePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActividadClienteFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ActividadClientePayload>
          }
          findFirst: {
            args: Prisma.ActividadClienteFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ActividadClientePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActividadClienteFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ActividadClientePayload>
          }
          findMany: {
            args: Prisma.ActividadClienteFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ActividadClientePayload>[]
          }
          create: {
            args: Prisma.ActividadClienteCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ActividadClientePayload>
          }
          createMany: {
            args: Prisma.ActividadClienteCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ActividadClienteDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ActividadClientePayload>
          }
          update: {
            args: Prisma.ActividadClienteUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ActividadClientePayload>
          }
          deleteMany: {
            args: Prisma.ActividadClienteDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ActividadClienteUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ActividadClienteUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ActividadClientePayload>
          }
          aggregate: {
            args: Prisma.ActividadClienteAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateActividadCliente>
          }
          groupBy: {
            args: Prisma.ActividadClienteGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ActividadClienteGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActividadClienteCountArgs<ExtArgs>,
            result: $Utils.Optional<ActividadClienteCountAggregateOutputType> | number
          }
        }
      }
      BitacoraCliente: {
        payload: Prisma.$BitacoraClientePayload<ExtArgs>
        fields: Prisma.BitacoraClienteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BitacoraClienteFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BitacoraClientePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BitacoraClienteFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BitacoraClientePayload>
          }
          findFirst: {
            args: Prisma.BitacoraClienteFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BitacoraClientePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BitacoraClienteFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BitacoraClientePayload>
          }
          findMany: {
            args: Prisma.BitacoraClienteFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BitacoraClientePayload>[]
          }
          create: {
            args: Prisma.BitacoraClienteCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BitacoraClientePayload>
          }
          createMany: {
            args: Prisma.BitacoraClienteCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BitacoraClienteDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BitacoraClientePayload>
          }
          update: {
            args: Prisma.BitacoraClienteUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BitacoraClientePayload>
          }
          deleteMany: {
            args: Prisma.BitacoraClienteDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BitacoraClienteUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BitacoraClienteUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BitacoraClientePayload>
          }
          aggregate: {
            args: Prisma.BitacoraClienteAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBitacoraCliente>
          }
          groupBy: {
            args: Prisma.BitacoraClienteGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BitacoraClienteGroupByOutputType>[]
          }
          count: {
            args: Prisma.BitacoraClienteCountArgs<ExtArgs>,
            result: $Utils.Optional<BitacoraClienteCountAggregateOutputType> | number
          }
        }
      }
      BitacoraEstilista: {
        payload: Prisma.$BitacoraEstilistaPayload<ExtArgs>
        fields: Prisma.BitacoraEstilistaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BitacoraEstilistaFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BitacoraEstilistaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BitacoraEstilistaFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BitacoraEstilistaPayload>
          }
          findFirst: {
            args: Prisma.BitacoraEstilistaFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BitacoraEstilistaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BitacoraEstilistaFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BitacoraEstilistaPayload>
          }
          findMany: {
            args: Prisma.BitacoraEstilistaFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BitacoraEstilistaPayload>[]
          }
          create: {
            args: Prisma.BitacoraEstilistaCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BitacoraEstilistaPayload>
          }
          createMany: {
            args: Prisma.BitacoraEstilistaCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BitacoraEstilistaDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BitacoraEstilistaPayload>
          }
          update: {
            args: Prisma.BitacoraEstilistaUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BitacoraEstilistaPayload>
          }
          deleteMany: {
            args: Prisma.BitacoraEstilistaDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BitacoraEstilistaUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BitacoraEstilistaUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BitacoraEstilistaPayload>
          }
          aggregate: {
            args: Prisma.BitacoraEstilistaAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBitacoraEstilista>
          }
          groupBy: {
            args: Prisma.BitacoraEstilistaGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BitacoraEstilistaGroupByOutputType>[]
          }
          count: {
            args: Prisma.BitacoraEstilistaCountArgs<ExtArgs>,
            result: $Utils.Optional<BitacoraEstilistaCountAggregateOutputType> | number
          }
        }
      }
      BloqueoHorarios: {
        payload: Prisma.$BloqueoHorariosPayload<ExtArgs>
        fields: Prisma.BloqueoHorariosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BloqueoHorariosFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BloqueoHorariosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BloqueoHorariosFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BloqueoHorariosPayload>
          }
          findFirst: {
            args: Prisma.BloqueoHorariosFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BloqueoHorariosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BloqueoHorariosFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BloqueoHorariosPayload>
          }
          findMany: {
            args: Prisma.BloqueoHorariosFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BloqueoHorariosPayload>[]
          }
          create: {
            args: Prisma.BloqueoHorariosCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BloqueoHorariosPayload>
          }
          createMany: {
            args: Prisma.BloqueoHorariosCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BloqueoHorariosDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BloqueoHorariosPayload>
          }
          update: {
            args: Prisma.BloqueoHorariosUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BloqueoHorariosPayload>
          }
          deleteMany: {
            args: Prisma.BloqueoHorariosDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BloqueoHorariosUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BloqueoHorariosUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BloqueoHorariosPayload>
          }
          aggregate: {
            args: Prisma.BloqueoHorariosAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBloqueoHorarios>
          }
          groupBy: {
            args: Prisma.BloqueoHorariosGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BloqueoHorariosGroupByOutputType>[]
          }
          count: {
            args: Prisma.BloqueoHorariosCountArgs<ExtArgs>,
            result: $Utils.Optional<BloqueoHorariosCountAggregateOutputType> | number
          }
        }
      }
      Citas: {
        payload: Prisma.$CitasPayload<ExtArgs>
        fields: Prisma.CitasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CitasFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CitasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CitasFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CitasPayload>
          }
          findFirst: {
            args: Prisma.CitasFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CitasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CitasFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CitasPayload>
          }
          findMany: {
            args: Prisma.CitasFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CitasPayload>[]
          }
          create: {
            args: Prisma.CitasCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CitasPayload>
          }
          createMany: {
            args: Prisma.CitasCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CitasDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CitasPayload>
          }
          update: {
            args: Prisma.CitasUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CitasPayload>
          }
          deleteMany: {
            args: Prisma.CitasDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CitasUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CitasUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CitasPayload>
          }
          aggregate: {
            args: Prisma.CitasAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCitas>
          }
          groupBy: {
            args: Prisma.CitasGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CitasGroupByOutputType>[]
          }
          count: {
            args: Prisma.CitasCountArgs<ExtArgs>,
            result: $Utils.Optional<CitasCountAggregateOutputType> | number
          }
        }
      }
      DetallesCita: {
        payload: Prisma.$DetallesCitaPayload<ExtArgs>
        fields: Prisma.DetallesCitaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DetallesCitaFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DetallesCitaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DetallesCitaFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DetallesCitaPayload>
          }
          findFirst: {
            args: Prisma.DetallesCitaFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DetallesCitaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DetallesCitaFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DetallesCitaPayload>
          }
          findMany: {
            args: Prisma.DetallesCitaFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DetallesCitaPayload>[]
          }
          create: {
            args: Prisma.DetallesCitaCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DetallesCitaPayload>
          }
          createMany: {
            args: Prisma.DetallesCitaCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DetallesCitaDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DetallesCitaPayload>
          }
          update: {
            args: Prisma.DetallesCitaUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DetallesCitaPayload>
          }
          deleteMany: {
            args: Prisma.DetallesCitaDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DetallesCitaUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DetallesCitaUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DetallesCitaPayload>
          }
          aggregate: {
            args: Prisma.DetallesCitaAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDetallesCita>
          }
          groupBy: {
            args: Prisma.DetallesCitaGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DetallesCitaGroupByOutputType>[]
          }
          count: {
            args: Prisma.DetallesCitaCountArgs<ExtArgs>,
            result: $Utils.Optional<DetallesCitaCountAggregateOutputType> | number
          }
        }
      }
      EstadoCita: {
        payload: Prisma.$EstadoCitaPayload<ExtArgs>
        fields: Prisma.EstadoCitaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EstadoCitaFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EstadoCitaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EstadoCitaFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EstadoCitaPayload>
          }
          findFirst: {
            args: Prisma.EstadoCitaFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EstadoCitaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EstadoCitaFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EstadoCitaPayload>
          }
          findMany: {
            args: Prisma.EstadoCitaFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EstadoCitaPayload>[]
          }
          create: {
            args: Prisma.EstadoCitaCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EstadoCitaPayload>
          }
          createMany: {
            args: Prisma.EstadoCitaCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EstadoCitaDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EstadoCitaPayload>
          }
          update: {
            args: Prisma.EstadoCitaUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EstadoCitaPayload>
          }
          deleteMany: {
            args: Prisma.EstadoCitaDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EstadoCitaUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EstadoCitaUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EstadoCitaPayload>
          }
          aggregate: {
            args: Prisma.EstadoCitaAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEstadoCita>
          }
          groupBy: {
            args: Prisma.EstadoCitaGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EstadoCitaGroupByOutputType>[]
          }
          count: {
            args: Prisma.EstadoCitaCountArgs<ExtArgs>,
            result: $Utils.Optional<EstadoCitaCountAggregateOutputType> | number
          }
        }
      }
      HistorialCitas: {
        payload: Prisma.$HistorialCitasPayload<ExtArgs>
        fields: Prisma.HistorialCitasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HistorialCitasFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HistorialCitasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HistorialCitasFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HistorialCitasPayload>
          }
          findFirst: {
            args: Prisma.HistorialCitasFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HistorialCitasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HistorialCitasFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HistorialCitasPayload>
          }
          findMany: {
            args: Prisma.HistorialCitasFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HistorialCitasPayload>[]
          }
          create: {
            args: Prisma.HistorialCitasCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HistorialCitasPayload>
          }
          createMany: {
            args: Prisma.HistorialCitasCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.HistorialCitasDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HistorialCitasPayload>
          }
          update: {
            args: Prisma.HistorialCitasUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HistorialCitasPayload>
          }
          deleteMany: {
            args: Prisma.HistorialCitasDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.HistorialCitasUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.HistorialCitasUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HistorialCitasPayload>
          }
          aggregate: {
            args: Prisma.HistorialCitasAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateHistorialCitas>
          }
          groupBy: {
            args: Prisma.HistorialCitasGroupByArgs<ExtArgs>,
            result: $Utils.Optional<HistorialCitasGroupByOutputType>[]
          }
          count: {
            args: Prisma.HistorialCitasCountArgs<ExtArgs>,
            result: $Utils.Optional<HistorialCitasCountAggregateOutputType> | number
          }
        }
      }
      HistorialRecompensas: {
        payload: Prisma.$HistorialRecompensasPayload<ExtArgs>
        fields: Prisma.HistorialRecompensasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HistorialRecompensasFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HistorialRecompensasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HistorialRecompensasFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HistorialRecompensasPayload>
          }
          findFirst: {
            args: Prisma.HistorialRecompensasFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HistorialRecompensasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HistorialRecompensasFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HistorialRecompensasPayload>
          }
          findMany: {
            args: Prisma.HistorialRecompensasFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HistorialRecompensasPayload>[]
          }
          create: {
            args: Prisma.HistorialRecompensasCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HistorialRecompensasPayload>
          }
          createMany: {
            args: Prisma.HistorialRecompensasCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.HistorialRecompensasDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HistorialRecompensasPayload>
          }
          update: {
            args: Prisma.HistorialRecompensasUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HistorialRecompensasPayload>
          }
          deleteMany: {
            args: Prisma.HistorialRecompensasDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.HistorialRecompensasUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.HistorialRecompensasUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HistorialRecompensasPayload>
          }
          aggregate: {
            args: Prisma.HistorialRecompensasAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateHistorialRecompensas>
          }
          groupBy: {
            args: Prisma.HistorialRecompensasGroupByArgs<ExtArgs>,
            result: $Utils.Optional<HistorialRecompensasGroupByOutputType>[]
          }
          count: {
            args: Prisma.HistorialRecompensasCountArgs<ExtArgs>,
            result: $Utils.Optional<HistorialRecompensasCountAggregateOutputType> | number
          }
        }
      }
      Horarios: {
        payload: Prisma.$HorariosPayload<ExtArgs>
        fields: Prisma.HorariosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HorariosFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HorariosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HorariosFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HorariosPayload>
          }
          findFirst: {
            args: Prisma.HorariosFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HorariosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HorariosFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HorariosPayload>
          }
          findMany: {
            args: Prisma.HorariosFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HorariosPayload>[]
          }
          create: {
            args: Prisma.HorariosCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HorariosPayload>
          }
          createMany: {
            args: Prisma.HorariosCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.HorariosDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HorariosPayload>
          }
          update: {
            args: Prisma.HorariosUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HorariosPayload>
          }
          deleteMany: {
            args: Prisma.HorariosDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.HorariosUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.HorariosUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HorariosPayload>
          }
          aggregate: {
            args: Prisma.HorariosAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateHorarios>
          }
          groupBy: {
            args: Prisma.HorariosGroupByArgs<ExtArgs>,
            result: $Utils.Optional<HorariosGroupByOutputType>[]
          }
          count: {
            args: Prisma.HorariosCountArgs<ExtArgs>,
            result: $Utils.Optional<HorariosCountAggregateOutputType> | number
          }
        }
      }
      HorariosReservados: {
        payload: Prisma.$HorariosReservadosPayload<ExtArgs>
        fields: Prisma.HorariosReservadosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HorariosReservadosFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HorariosReservadosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HorariosReservadosFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HorariosReservadosPayload>
          }
          findFirst: {
            args: Prisma.HorariosReservadosFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HorariosReservadosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HorariosReservadosFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HorariosReservadosPayload>
          }
          findMany: {
            args: Prisma.HorariosReservadosFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HorariosReservadosPayload>[]
          }
          create: {
            args: Prisma.HorariosReservadosCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HorariosReservadosPayload>
          }
          createMany: {
            args: Prisma.HorariosReservadosCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.HorariosReservadosDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HorariosReservadosPayload>
          }
          update: {
            args: Prisma.HorariosReservadosUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HorariosReservadosPayload>
          }
          deleteMany: {
            args: Prisma.HorariosReservadosDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.HorariosReservadosUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.HorariosReservadosUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HorariosReservadosPayload>
          }
          aggregate: {
            args: Prisma.HorariosReservadosAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateHorariosReservados>
          }
          groupBy: {
            args: Prisma.HorariosReservadosGroupByArgs<ExtArgs>,
            result: $Utils.Optional<HorariosReservadosGroupByOutputType>[]
          }
          count: {
            args: Prisma.HorariosReservadosCountArgs<ExtArgs>,
            result: $Utils.Optional<HorariosReservadosCountAggregateOutputType> | number
          }
        }
      }
      PuntosClientes: {
        payload: Prisma.$PuntosClientesPayload<ExtArgs>
        fields: Prisma.PuntosClientesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PuntosClientesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PuntosClientesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PuntosClientesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PuntosClientesPayload>
          }
          findFirst: {
            args: Prisma.PuntosClientesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PuntosClientesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PuntosClientesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PuntosClientesPayload>
          }
          findMany: {
            args: Prisma.PuntosClientesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PuntosClientesPayload>[]
          }
          create: {
            args: Prisma.PuntosClientesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PuntosClientesPayload>
          }
          createMany: {
            args: Prisma.PuntosClientesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PuntosClientesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PuntosClientesPayload>
          }
          update: {
            args: Prisma.PuntosClientesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PuntosClientesPayload>
          }
          deleteMany: {
            args: Prisma.PuntosClientesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PuntosClientesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PuntosClientesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PuntosClientesPayload>
          }
          aggregate: {
            args: Prisma.PuntosClientesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePuntosClientes>
          }
          groupBy: {
            args: Prisma.PuntosClientesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PuntosClientesGroupByOutputType>[]
          }
          count: {
            args: Prisma.PuntosClientesCountArgs<ExtArgs>,
            result: $Utils.Optional<PuntosClientesCountAggregateOutputType> | number
          }
        }
      }
      PuntosServicio: {
        payload: Prisma.$PuntosServicioPayload<ExtArgs>
        fields: Prisma.PuntosServicioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PuntosServicioFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PuntosServicioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PuntosServicioFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PuntosServicioPayload>
          }
          findFirst: {
            args: Prisma.PuntosServicioFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PuntosServicioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PuntosServicioFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PuntosServicioPayload>
          }
          findMany: {
            args: Prisma.PuntosServicioFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PuntosServicioPayload>[]
          }
          create: {
            args: Prisma.PuntosServicioCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PuntosServicioPayload>
          }
          createMany: {
            args: Prisma.PuntosServicioCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PuntosServicioDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PuntosServicioPayload>
          }
          update: {
            args: Prisma.PuntosServicioUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PuntosServicioPayload>
          }
          deleteMany: {
            args: Prisma.PuntosServicioDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PuntosServicioUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PuntosServicioUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PuntosServicioPayload>
          }
          aggregate: {
            args: Prisma.PuntosServicioAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePuntosServicio>
          }
          groupBy: {
            args: Prisma.PuntosServicioGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PuntosServicioGroupByOutputType>[]
          }
          count: {
            args: Prisma.PuntosServicioCountArgs<ExtArgs>,
            result: $Utils.Optional<PuntosServicioCountAggregateOutputType> | number
          }
        }
      }
      Roles: {
        payload: Prisma.$RolesPayload<ExtArgs>
        fields: Prisma.RolesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RolesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RolesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>
          }
          findFirst: {
            args: Prisma.RolesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RolesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>
          }
          findMany: {
            args: Prisma.RolesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>[]
          }
          create: {
            args: Prisma.RolesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>
          }
          createMany: {
            args: Prisma.RolesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RolesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>
          }
          update: {
            args: Prisma.RolesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>
          }
          deleteMany: {
            args: Prisma.RolesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RolesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RolesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>
          }
          aggregate: {
            args: Prisma.RolesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRoles>
          }
          groupBy: {
            args: Prisma.RolesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RolesGroupByOutputType>[]
          }
          count: {
            args: Prisma.RolesCountArgs<ExtArgs>,
            result: $Utils.Optional<RolesCountAggregateOutputType> | number
          }
        }
      }
      Servicios: {
        payload: Prisma.$ServiciosPayload<ExtArgs>
        fields: Prisma.ServiciosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiciosFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ServiciosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiciosFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ServiciosPayload>
          }
          findFirst: {
            args: Prisma.ServiciosFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ServiciosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiciosFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ServiciosPayload>
          }
          findMany: {
            args: Prisma.ServiciosFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ServiciosPayload>[]
          }
          create: {
            args: Prisma.ServiciosCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ServiciosPayload>
          }
          createMany: {
            args: Prisma.ServiciosCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ServiciosDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ServiciosPayload>
          }
          update: {
            args: Prisma.ServiciosUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ServiciosPayload>
          }
          deleteMany: {
            args: Prisma.ServiciosDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ServiciosUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ServiciosUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ServiciosPayload>
          }
          aggregate: {
            args: Prisma.ServiciosAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateServicios>
          }
          groupBy: {
            args: Prisma.ServiciosGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ServiciosGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiciosCountArgs<ExtArgs>,
            result: $Utils.Optional<ServiciosCountAggregateOutputType> | number
          }
        }
      }
      Usuarios: {
        payload: Prisma.$UsuariosPayload<ExtArgs>
        fields: Prisma.UsuariosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsuariosFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuariosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsuariosFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuariosPayload>
          }
          findFirst: {
            args: Prisma.UsuariosFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuariosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsuariosFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuariosPayload>
          }
          findMany: {
            args: Prisma.UsuariosFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuariosPayload>[]
          }
          create: {
            args: Prisma.UsuariosCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuariosPayload>
          }
          createMany: {
            args: Prisma.UsuariosCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UsuariosDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuariosPayload>
          }
          update: {
            args: Prisma.UsuariosUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuariosPayload>
          }
          deleteMany: {
            args: Prisma.UsuariosDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UsuariosUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UsuariosUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuariosPayload>
          }
          aggregate: {
            args: Prisma.UsuariosAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUsuarios>
          }
          groupBy: {
            args: Prisma.UsuariosGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UsuariosGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsuariosCountArgs<ExtArgs>,
            result: $Utils.Optional<UsuariosCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CitasCountOutputType
   */

  export type CitasCountOutputType = {
    ActividadCliente: number
    DetallesCita: number
    HistorialCitas: number
  }

  export type CitasCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ActividadCliente?: boolean | CitasCountOutputTypeCountActividadClienteArgs
    DetallesCita?: boolean | CitasCountOutputTypeCountDetallesCitaArgs
    HistorialCitas?: boolean | CitasCountOutputTypeCountHistorialCitasArgs
  }

  // Custom InputTypes

  /**
   * CitasCountOutputType without action
   */
  export type CitasCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CitasCountOutputType
     */
    select?: CitasCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CitasCountOutputType without action
   */
  export type CitasCountOutputTypeCountActividadClienteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActividadClienteWhereInput
  }


  /**
   * CitasCountOutputType without action
   */
  export type CitasCountOutputTypeCountDetallesCitaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DetallesCitaWhereInput
  }


  /**
   * CitasCountOutputType without action
   */
  export type CitasCountOutputTypeCountHistorialCitasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HistorialCitasWhereInput
  }



  /**
   * Count Type EstadoCitaCountOutputType
   */

  export type EstadoCitaCountOutputType = {
    Citas: number
  }

  export type EstadoCitaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Citas?: boolean | EstadoCitaCountOutputTypeCountCitasArgs
  }

  // Custom InputTypes

  /**
   * EstadoCitaCountOutputType without action
   */
  export type EstadoCitaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstadoCitaCountOutputType
     */
    select?: EstadoCitaCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * EstadoCitaCountOutputType without action
   */
  export type EstadoCitaCountOutputTypeCountCitasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CitasWhereInput
  }



  /**
   * Count Type RolesCountOutputType
   */

  export type RolesCountOutputType = {
    Usuarios: number
  }

  export type RolesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Usuarios?: boolean | RolesCountOutputTypeCountUsuariosArgs
  }

  // Custom InputTypes

  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolesCountOutputType
     */
    select?: RolesCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeCountUsuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuariosWhereInput
  }



  /**
   * Count Type ServiciosCountOutputType
   */

  export type ServiciosCountOutputType = {
    DetallesCita: number
    HistorialRecompensas: number
  }

  export type ServiciosCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DetallesCita?: boolean | ServiciosCountOutputTypeCountDetallesCitaArgs
    HistorialRecompensas?: boolean | ServiciosCountOutputTypeCountHistorialRecompensasArgs
  }

  // Custom InputTypes

  /**
   * ServiciosCountOutputType without action
   */
  export type ServiciosCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiciosCountOutputType
     */
    select?: ServiciosCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ServiciosCountOutputType without action
   */
  export type ServiciosCountOutputTypeCountDetallesCitaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DetallesCitaWhereInput
  }


  /**
   * ServiciosCountOutputType without action
   */
  export type ServiciosCountOutputTypeCountHistorialRecompensasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HistorialRecompensasWhereInput
  }



  /**
   * Count Type UsuariosCountOutputType
   */

  export type UsuariosCountOutputType = {
    ActividadCliente: number
    BitacoraCliente: number
    BitacoraEstilista: number
    BloqueoHorarios: number
    Citas_Citas_clienteIDToUsuarios: number
    Citas_Citas_estilistaIDToUsuarios: number
    HistorialCitas: number
    HistorialRecompensas: number
    Horarios: number
    PuntosClientes: number
  }

  export type UsuariosCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ActividadCliente?: boolean | UsuariosCountOutputTypeCountActividadClienteArgs
    BitacoraCliente?: boolean | UsuariosCountOutputTypeCountBitacoraClienteArgs
    BitacoraEstilista?: boolean | UsuariosCountOutputTypeCountBitacoraEstilistaArgs
    BloqueoHorarios?: boolean | UsuariosCountOutputTypeCountBloqueoHorariosArgs
    Citas_Citas_clienteIDToUsuarios?: boolean | UsuariosCountOutputTypeCountCitas_Citas_clienteIDToUsuariosArgs
    Citas_Citas_estilistaIDToUsuarios?: boolean | UsuariosCountOutputTypeCountCitas_Citas_estilistaIDToUsuariosArgs
    HistorialCitas?: boolean | UsuariosCountOutputTypeCountHistorialCitasArgs
    HistorialRecompensas?: boolean | UsuariosCountOutputTypeCountHistorialRecompensasArgs
    Horarios?: boolean | UsuariosCountOutputTypeCountHorariosArgs
    PuntosClientes?: boolean | UsuariosCountOutputTypeCountPuntosClientesArgs
  }

  // Custom InputTypes

  /**
   * UsuariosCountOutputType without action
   */
  export type UsuariosCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuariosCountOutputType
     */
    select?: UsuariosCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UsuariosCountOutputType without action
   */
  export type UsuariosCountOutputTypeCountActividadClienteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActividadClienteWhereInput
  }


  /**
   * UsuariosCountOutputType without action
   */
  export type UsuariosCountOutputTypeCountBitacoraClienteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BitacoraClienteWhereInput
  }


  /**
   * UsuariosCountOutputType without action
   */
  export type UsuariosCountOutputTypeCountBitacoraEstilistaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BitacoraEstilistaWhereInput
  }


  /**
   * UsuariosCountOutputType without action
   */
  export type UsuariosCountOutputTypeCountBloqueoHorariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BloqueoHorariosWhereInput
  }


  /**
   * UsuariosCountOutputType without action
   */
  export type UsuariosCountOutputTypeCountCitas_Citas_clienteIDToUsuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CitasWhereInput
  }


  /**
   * UsuariosCountOutputType without action
   */
  export type UsuariosCountOutputTypeCountCitas_Citas_estilistaIDToUsuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CitasWhereInput
  }


  /**
   * UsuariosCountOutputType without action
   */
  export type UsuariosCountOutputTypeCountHistorialCitasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HistorialCitasWhereInput
  }


  /**
   * UsuariosCountOutputType without action
   */
  export type UsuariosCountOutputTypeCountHistorialRecompensasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HistorialRecompensasWhereInput
  }


  /**
   * UsuariosCountOutputType without action
   */
  export type UsuariosCountOutputTypeCountHorariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HorariosWhereInput
  }


  /**
   * UsuariosCountOutputType without action
   */
  export type UsuariosCountOutputTypeCountPuntosClientesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PuntosClientesWhereInput
  }



  /**
   * Models
   */

  /**
   * Model ActividadCliente
   */

  export type AggregateActividadCliente = {
    _count: ActividadClienteCountAggregateOutputType | null
    _avg: ActividadClienteAvgAggregateOutputType | null
    _sum: ActividadClienteSumAggregateOutputType | null
    _min: ActividadClienteMinAggregateOutputType | null
    _max: ActividadClienteMaxAggregateOutputType | null
  }

  export type ActividadClienteAvgAggregateOutputType = {
    actividadID: number | null
    clienteID: number | null
    ultimaCitaID: number | null
  }

  export type ActividadClienteSumAggregateOutputType = {
    actividadID: number | null
    clienteID: number | null
    ultimaCitaID: number | null
  }

  export type ActividadClienteMinAggregateOutputType = {
    actividadID: number | null
    clienteID: number | null
    ultimaConexion: Date | null
    ultimaCitaID: number | null
  }

  export type ActividadClienteMaxAggregateOutputType = {
    actividadID: number | null
    clienteID: number | null
    ultimaConexion: Date | null
    ultimaCitaID: number | null
  }

  export type ActividadClienteCountAggregateOutputType = {
    actividadID: number
    clienteID: number
    ultimaConexion: number
    ultimaCitaID: number
    _all: number
  }


  export type ActividadClienteAvgAggregateInputType = {
    actividadID?: true
    clienteID?: true
    ultimaCitaID?: true
  }

  export type ActividadClienteSumAggregateInputType = {
    actividadID?: true
    clienteID?: true
    ultimaCitaID?: true
  }

  export type ActividadClienteMinAggregateInputType = {
    actividadID?: true
    clienteID?: true
    ultimaConexion?: true
    ultimaCitaID?: true
  }

  export type ActividadClienteMaxAggregateInputType = {
    actividadID?: true
    clienteID?: true
    ultimaConexion?: true
    ultimaCitaID?: true
  }

  export type ActividadClienteCountAggregateInputType = {
    actividadID?: true
    clienteID?: true
    ultimaConexion?: true
    ultimaCitaID?: true
    _all?: true
  }

  export type ActividadClienteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActividadCliente to aggregate.
     */
    where?: ActividadClienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActividadClientes to fetch.
     */
    orderBy?: ActividadClienteOrderByWithRelationInput | ActividadClienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActividadClienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActividadClientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActividadClientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActividadClientes
    **/
    _count?: true | ActividadClienteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActividadClienteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActividadClienteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActividadClienteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActividadClienteMaxAggregateInputType
  }

  export type GetActividadClienteAggregateType<T extends ActividadClienteAggregateArgs> = {
        [P in keyof T & keyof AggregateActividadCliente]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActividadCliente[P]>
      : GetScalarType<T[P], AggregateActividadCliente[P]>
  }




  export type ActividadClienteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActividadClienteWhereInput
    orderBy?: ActividadClienteOrderByWithAggregationInput | ActividadClienteOrderByWithAggregationInput[]
    by: ActividadClienteScalarFieldEnum[] | ActividadClienteScalarFieldEnum
    having?: ActividadClienteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActividadClienteCountAggregateInputType | true
    _avg?: ActividadClienteAvgAggregateInputType
    _sum?: ActividadClienteSumAggregateInputType
    _min?: ActividadClienteMinAggregateInputType
    _max?: ActividadClienteMaxAggregateInputType
  }

  export type ActividadClienteGroupByOutputType = {
    actividadID: number
    clienteID: number | null
    ultimaConexion: Date | null
    ultimaCitaID: number | null
    _count: ActividadClienteCountAggregateOutputType | null
    _avg: ActividadClienteAvgAggregateOutputType | null
    _sum: ActividadClienteSumAggregateOutputType | null
    _min: ActividadClienteMinAggregateOutputType | null
    _max: ActividadClienteMaxAggregateOutputType | null
  }

  type GetActividadClienteGroupByPayload<T extends ActividadClienteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActividadClienteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActividadClienteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActividadClienteGroupByOutputType[P]>
            : GetScalarType<T[P], ActividadClienteGroupByOutputType[P]>
        }
      >
    >


  export type ActividadClienteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    actividadID?: boolean
    clienteID?: boolean
    ultimaConexion?: boolean
    ultimaCitaID?: boolean
    Usuarios?: boolean | ActividadCliente$UsuariosArgs<ExtArgs>
    Citas?: boolean | ActividadCliente$CitasArgs<ExtArgs>
  }, ExtArgs["result"]["actividadCliente"]>

  export type ActividadClienteSelectScalar = {
    actividadID?: boolean
    clienteID?: boolean
    ultimaConexion?: boolean
    ultimaCitaID?: boolean
  }

  export type ActividadClienteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Usuarios?: boolean | ActividadCliente$UsuariosArgs<ExtArgs>
    Citas?: boolean | ActividadCliente$CitasArgs<ExtArgs>
  }


  export type $ActividadClientePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActividadCliente"
    objects: {
      Usuarios: Prisma.$UsuariosPayload<ExtArgs> | null
      Citas: Prisma.$CitasPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      actividadID: number
      clienteID: number | null
      ultimaConexion: Date | null
      ultimaCitaID: number | null
    }, ExtArgs["result"]["actividadCliente"]>
    composites: {}
  }


  type ActividadClienteGetPayload<S extends boolean | null | undefined | ActividadClienteDefaultArgs> = $Result.GetResult<Prisma.$ActividadClientePayload, S>

  type ActividadClienteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ActividadClienteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ActividadClienteCountAggregateInputType | true
    }

  export interface ActividadClienteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActividadCliente'], meta: { name: 'ActividadCliente' } }
    /**
     * Find zero or one ActividadCliente that matches the filter.
     * @param {ActividadClienteFindUniqueArgs} args - Arguments to find a ActividadCliente
     * @example
     * // Get one ActividadCliente
     * const actividadCliente = await prisma.actividadCliente.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ActividadClienteFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ActividadClienteFindUniqueArgs<ExtArgs>>
    ): Prisma__ActividadClienteClient<$Result.GetResult<Prisma.$ActividadClientePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ActividadCliente that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ActividadClienteFindUniqueOrThrowArgs} args - Arguments to find a ActividadCliente
     * @example
     * // Get one ActividadCliente
     * const actividadCliente = await prisma.actividadCliente.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ActividadClienteFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ActividadClienteFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ActividadClienteClient<$Result.GetResult<Prisma.$ActividadClientePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ActividadCliente that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActividadClienteFindFirstArgs} args - Arguments to find a ActividadCliente
     * @example
     * // Get one ActividadCliente
     * const actividadCliente = await prisma.actividadCliente.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ActividadClienteFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ActividadClienteFindFirstArgs<ExtArgs>>
    ): Prisma__ActividadClienteClient<$Result.GetResult<Prisma.$ActividadClientePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ActividadCliente that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActividadClienteFindFirstOrThrowArgs} args - Arguments to find a ActividadCliente
     * @example
     * // Get one ActividadCliente
     * const actividadCliente = await prisma.actividadCliente.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ActividadClienteFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ActividadClienteFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ActividadClienteClient<$Result.GetResult<Prisma.$ActividadClientePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ActividadClientes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActividadClienteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActividadClientes
     * const actividadClientes = await prisma.actividadCliente.findMany()
     * 
     * // Get first 10 ActividadClientes
     * const actividadClientes = await prisma.actividadCliente.findMany({ take: 10 })
     * 
     * // Only select the `actividadID`
     * const actividadClienteWithActividadIDOnly = await prisma.actividadCliente.findMany({ select: { actividadID: true } })
     * 
    **/
    findMany<T extends ActividadClienteFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ActividadClienteFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActividadClientePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ActividadCliente.
     * @param {ActividadClienteCreateArgs} args - Arguments to create a ActividadCliente.
     * @example
     * // Create one ActividadCliente
     * const ActividadCliente = await prisma.actividadCliente.create({
     *   data: {
     *     // ... data to create a ActividadCliente
     *   }
     * })
     * 
    **/
    create<T extends ActividadClienteCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ActividadClienteCreateArgs<ExtArgs>>
    ): Prisma__ActividadClienteClient<$Result.GetResult<Prisma.$ActividadClientePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ActividadClientes.
     *     @param {ActividadClienteCreateManyArgs} args - Arguments to create many ActividadClientes.
     *     @example
     *     // Create many ActividadClientes
     *     const actividadCliente = await prisma.actividadCliente.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ActividadClienteCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ActividadClienteCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ActividadCliente.
     * @param {ActividadClienteDeleteArgs} args - Arguments to delete one ActividadCliente.
     * @example
     * // Delete one ActividadCliente
     * const ActividadCliente = await prisma.actividadCliente.delete({
     *   where: {
     *     // ... filter to delete one ActividadCliente
     *   }
     * })
     * 
    **/
    delete<T extends ActividadClienteDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ActividadClienteDeleteArgs<ExtArgs>>
    ): Prisma__ActividadClienteClient<$Result.GetResult<Prisma.$ActividadClientePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ActividadCliente.
     * @param {ActividadClienteUpdateArgs} args - Arguments to update one ActividadCliente.
     * @example
     * // Update one ActividadCliente
     * const actividadCliente = await prisma.actividadCliente.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ActividadClienteUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ActividadClienteUpdateArgs<ExtArgs>>
    ): Prisma__ActividadClienteClient<$Result.GetResult<Prisma.$ActividadClientePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ActividadClientes.
     * @param {ActividadClienteDeleteManyArgs} args - Arguments to filter ActividadClientes to delete.
     * @example
     * // Delete a few ActividadClientes
     * const { count } = await prisma.actividadCliente.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ActividadClienteDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ActividadClienteDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActividadClientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActividadClienteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActividadClientes
     * const actividadCliente = await prisma.actividadCliente.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ActividadClienteUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ActividadClienteUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ActividadCliente.
     * @param {ActividadClienteUpsertArgs} args - Arguments to update or create a ActividadCliente.
     * @example
     * // Update or create a ActividadCliente
     * const actividadCliente = await prisma.actividadCliente.upsert({
     *   create: {
     *     // ... data to create a ActividadCliente
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActividadCliente we want to update
     *   }
     * })
    **/
    upsert<T extends ActividadClienteUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ActividadClienteUpsertArgs<ExtArgs>>
    ): Prisma__ActividadClienteClient<$Result.GetResult<Prisma.$ActividadClientePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ActividadClientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActividadClienteCountArgs} args - Arguments to filter ActividadClientes to count.
     * @example
     * // Count the number of ActividadClientes
     * const count = await prisma.actividadCliente.count({
     *   where: {
     *     // ... the filter for the ActividadClientes we want to count
     *   }
     * })
    **/
    count<T extends ActividadClienteCountArgs>(
      args?: Subset<T, ActividadClienteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActividadClienteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActividadCliente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActividadClienteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActividadClienteAggregateArgs>(args: Subset<T, ActividadClienteAggregateArgs>): Prisma.PrismaPromise<GetActividadClienteAggregateType<T>>

    /**
     * Group by ActividadCliente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActividadClienteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActividadClienteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActividadClienteGroupByArgs['orderBy'] }
        : { orderBy?: ActividadClienteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActividadClienteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActividadClienteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActividadCliente model
   */
  readonly fields: ActividadClienteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActividadCliente.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActividadClienteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Usuarios<T extends ActividadCliente$UsuariosArgs<ExtArgs> = {}>(args?: Subset<T, ActividadCliente$UsuariosArgs<ExtArgs>>): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    Citas<T extends ActividadCliente$CitasArgs<ExtArgs> = {}>(args?: Subset<T, ActividadCliente$CitasArgs<ExtArgs>>): Prisma__CitasClient<$Result.GetResult<Prisma.$CitasPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ActividadCliente model
   */ 
  interface ActividadClienteFieldRefs {
    readonly actividadID: FieldRef<"ActividadCliente", 'Int'>
    readonly clienteID: FieldRef<"ActividadCliente", 'Int'>
    readonly ultimaConexion: FieldRef<"ActividadCliente", 'DateTime'>
    readonly ultimaCitaID: FieldRef<"ActividadCliente", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * ActividadCliente findUnique
   */
  export type ActividadClienteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActividadCliente
     */
    select?: ActividadClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActividadClienteInclude<ExtArgs> | null
    /**
     * Filter, which ActividadCliente to fetch.
     */
    where: ActividadClienteWhereUniqueInput
  }


  /**
   * ActividadCliente findUniqueOrThrow
   */
  export type ActividadClienteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActividadCliente
     */
    select?: ActividadClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActividadClienteInclude<ExtArgs> | null
    /**
     * Filter, which ActividadCliente to fetch.
     */
    where: ActividadClienteWhereUniqueInput
  }


  /**
   * ActividadCliente findFirst
   */
  export type ActividadClienteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActividadCliente
     */
    select?: ActividadClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActividadClienteInclude<ExtArgs> | null
    /**
     * Filter, which ActividadCliente to fetch.
     */
    where?: ActividadClienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActividadClientes to fetch.
     */
    orderBy?: ActividadClienteOrderByWithRelationInput | ActividadClienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActividadClientes.
     */
    cursor?: ActividadClienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActividadClientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActividadClientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActividadClientes.
     */
    distinct?: ActividadClienteScalarFieldEnum | ActividadClienteScalarFieldEnum[]
  }


  /**
   * ActividadCliente findFirstOrThrow
   */
  export type ActividadClienteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActividadCliente
     */
    select?: ActividadClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActividadClienteInclude<ExtArgs> | null
    /**
     * Filter, which ActividadCliente to fetch.
     */
    where?: ActividadClienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActividadClientes to fetch.
     */
    orderBy?: ActividadClienteOrderByWithRelationInput | ActividadClienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActividadClientes.
     */
    cursor?: ActividadClienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActividadClientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActividadClientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActividadClientes.
     */
    distinct?: ActividadClienteScalarFieldEnum | ActividadClienteScalarFieldEnum[]
  }


  /**
   * ActividadCliente findMany
   */
  export type ActividadClienteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActividadCliente
     */
    select?: ActividadClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActividadClienteInclude<ExtArgs> | null
    /**
     * Filter, which ActividadClientes to fetch.
     */
    where?: ActividadClienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActividadClientes to fetch.
     */
    orderBy?: ActividadClienteOrderByWithRelationInput | ActividadClienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActividadClientes.
     */
    cursor?: ActividadClienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActividadClientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActividadClientes.
     */
    skip?: number
    distinct?: ActividadClienteScalarFieldEnum | ActividadClienteScalarFieldEnum[]
  }


  /**
   * ActividadCliente create
   */
  export type ActividadClienteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActividadCliente
     */
    select?: ActividadClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActividadClienteInclude<ExtArgs> | null
    /**
     * The data needed to create a ActividadCliente.
     */
    data?: XOR<ActividadClienteCreateInput, ActividadClienteUncheckedCreateInput>
  }


  /**
   * ActividadCliente createMany
   */
  export type ActividadClienteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActividadClientes.
     */
    data: ActividadClienteCreateManyInput | ActividadClienteCreateManyInput[]
  }


  /**
   * ActividadCliente update
   */
  export type ActividadClienteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActividadCliente
     */
    select?: ActividadClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActividadClienteInclude<ExtArgs> | null
    /**
     * The data needed to update a ActividadCliente.
     */
    data: XOR<ActividadClienteUpdateInput, ActividadClienteUncheckedUpdateInput>
    /**
     * Choose, which ActividadCliente to update.
     */
    where: ActividadClienteWhereUniqueInput
  }


  /**
   * ActividadCliente updateMany
   */
  export type ActividadClienteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActividadClientes.
     */
    data: XOR<ActividadClienteUpdateManyMutationInput, ActividadClienteUncheckedUpdateManyInput>
    /**
     * Filter which ActividadClientes to update
     */
    where?: ActividadClienteWhereInput
  }


  /**
   * ActividadCliente upsert
   */
  export type ActividadClienteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActividadCliente
     */
    select?: ActividadClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActividadClienteInclude<ExtArgs> | null
    /**
     * The filter to search for the ActividadCliente to update in case it exists.
     */
    where: ActividadClienteWhereUniqueInput
    /**
     * In case the ActividadCliente found by the `where` argument doesn't exist, create a new ActividadCliente with this data.
     */
    create: XOR<ActividadClienteCreateInput, ActividadClienteUncheckedCreateInput>
    /**
     * In case the ActividadCliente was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActividadClienteUpdateInput, ActividadClienteUncheckedUpdateInput>
  }


  /**
   * ActividadCliente delete
   */
  export type ActividadClienteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActividadCliente
     */
    select?: ActividadClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActividadClienteInclude<ExtArgs> | null
    /**
     * Filter which ActividadCliente to delete.
     */
    where: ActividadClienteWhereUniqueInput
  }


  /**
   * ActividadCliente deleteMany
   */
  export type ActividadClienteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActividadClientes to delete
     */
    where?: ActividadClienteWhereInput
  }


  /**
   * ActividadCliente.Usuarios
   */
  export type ActividadCliente$UsuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuariosInclude<ExtArgs> | null
    where?: UsuariosWhereInput
  }


  /**
   * ActividadCliente.Citas
   */
  export type ActividadCliente$CitasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Citas
     */
    select?: CitasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CitasInclude<ExtArgs> | null
    where?: CitasWhereInput
  }


  /**
   * ActividadCliente without action
   */
  export type ActividadClienteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActividadCliente
     */
    select?: ActividadClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActividadClienteInclude<ExtArgs> | null
  }



  /**
   * Model BitacoraCliente
   */

  export type AggregateBitacoraCliente = {
    _count: BitacoraClienteCountAggregateOutputType | null
    _avg: BitacoraClienteAvgAggregateOutputType | null
    _sum: BitacoraClienteSumAggregateOutputType | null
    _min: BitacoraClienteMinAggregateOutputType | null
    _max: BitacoraClienteMaxAggregateOutputType | null
  }

  export type BitacoraClienteAvgAggregateOutputType = {
    bitacoraID: number | null
    clienteID: number | null
  }

  export type BitacoraClienteSumAggregateOutputType = {
    bitacoraID: number | null
    clienteID: number | null
  }

  export type BitacoraClienteMinAggregateOutputType = {
    bitacoraID: number | null
    clienteID: number | null
    fechaRegistro: Date | null
  }

  export type BitacoraClienteMaxAggregateOutputType = {
    bitacoraID: number | null
    clienteID: number | null
    fechaRegistro: Date | null
  }

  export type BitacoraClienteCountAggregateOutputType = {
    bitacoraID: number
    clienteID: number
    fechaRegistro: number
    _all: number
  }


  export type BitacoraClienteAvgAggregateInputType = {
    bitacoraID?: true
    clienteID?: true
  }

  export type BitacoraClienteSumAggregateInputType = {
    bitacoraID?: true
    clienteID?: true
  }

  export type BitacoraClienteMinAggregateInputType = {
    bitacoraID?: true
    clienteID?: true
    fechaRegistro?: true
  }

  export type BitacoraClienteMaxAggregateInputType = {
    bitacoraID?: true
    clienteID?: true
    fechaRegistro?: true
  }

  export type BitacoraClienteCountAggregateInputType = {
    bitacoraID?: true
    clienteID?: true
    fechaRegistro?: true
    _all?: true
  }

  export type BitacoraClienteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BitacoraCliente to aggregate.
     */
    where?: BitacoraClienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BitacoraClientes to fetch.
     */
    orderBy?: BitacoraClienteOrderByWithRelationInput | BitacoraClienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BitacoraClienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BitacoraClientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BitacoraClientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BitacoraClientes
    **/
    _count?: true | BitacoraClienteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BitacoraClienteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BitacoraClienteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BitacoraClienteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BitacoraClienteMaxAggregateInputType
  }

  export type GetBitacoraClienteAggregateType<T extends BitacoraClienteAggregateArgs> = {
        [P in keyof T & keyof AggregateBitacoraCliente]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBitacoraCliente[P]>
      : GetScalarType<T[P], AggregateBitacoraCliente[P]>
  }




  export type BitacoraClienteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BitacoraClienteWhereInput
    orderBy?: BitacoraClienteOrderByWithAggregationInput | BitacoraClienteOrderByWithAggregationInput[]
    by: BitacoraClienteScalarFieldEnum[] | BitacoraClienteScalarFieldEnum
    having?: BitacoraClienteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BitacoraClienteCountAggregateInputType | true
    _avg?: BitacoraClienteAvgAggregateInputType
    _sum?: BitacoraClienteSumAggregateInputType
    _min?: BitacoraClienteMinAggregateInputType
    _max?: BitacoraClienteMaxAggregateInputType
  }

  export type BitacoraClienteGroupByOutputType = {
    bitacoraID: number
    clienteID: number | null
    fechaRegistro: Date | null
    _count: BitacoraClienteCountAggregateOutputType | null
    _avg: BitacoraClienteAvgAggregateOutputType | null
    _sum: BitacoraClienteSumAggregateOutputType | null
    _min: BitacoraClienteMinAggregateOutputType | null
    _max: BitacoraClienteMaxAggregateOutputType | null
  }

  type GetBitacoraClienteGroupByPayload<T extends BitacoraClienteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BitacoraClienteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BitacoraClienteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BitacoraClienteGroupByOutputType[P]>
            : GetScalarType<T[P], BitacoraClienteGroupByOutputType[P]>
        }
      >
    >


  export type BitacoraClienteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    bitacoraID?: boolean
    clienteID?: boolean
    fechaRegistro?: boolean
    Usuarios?: boolean | BitacoraCliente$UsuariosArgs<ExtArgs>
  }, ExtArgs["result"]["bitacoraCliente"]>

  export type BitacoraClienteSelectScalar = {
    bitacoraID?: boolean
    clienteID?: boolean
    fechaRegistro?: boolean
  }

  export type BitacoraClienteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Usuarios?: boolean | BitacoraCliente$UsuariosArgs<ExtArgs>
  }


  export type $BitacoraClientePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BitacoraCliente"
    objects: {
      Usuarios: Prisma.$UsuariosPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      bitacoraID: number
      clienteID: number | null
      fechaRegistro: Date | null
    }, ExtArgs["result"]["bitacoraCliente"]>
    composites: {}
  }


  type BitacoraClienteGetPayload<S extends boolean | null | undefined | BitacoraClienteDefaultArgs> = $Result.GetResult<Prisma.$BitacoraClientePayload, S>

  type BitacoraClienteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BitacoraClienteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BitacoraClienteCountAggregateInputType | true
    }

  export interface BitacoraClienteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BitacoraCliente'], meta: { name: 'BitacoraCliente' } }
    /**
     * Find zero or one BitacoraCliente that matches the filter.
     * @param {BitacoraClienteFindUniqueArgs} args - Arguments to find a BitacoraCliente
     * @example
     * // Get one BitacoraCliente
     * const bitacoraCliente = await prisma.bitacoraCliente.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BitacoraClienteFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BitacoraClienteFindUniqueArgs<ExtArgs>>
    ): Prisma__BitacoraClienteClient<$Result.GetResult<Prisma.$BitacoraClientePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one BitacoraCliente that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BitacoraClienteFindUniqueOrThrowArgs} args - Arguments to find a BitacoraCliente
     * @example
     * // Get one BitacoraCliente
     * const bitacoraCliente = await prisma.bitacoraCliente.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BitacoraClienteFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BitacoraClienteFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BitacoraClienteClient<$Result.GetResult<Prisma.$BitacoraClientePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first BitacoraCliente that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BitacoraClienteFindFirstArgs} args - Arguments to find a BitacoraCliente
     * @example
     * // Get one BitacoraCliente
     * const bitacoraCliente = await prisma.bitacoraCliente.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BitacoraClienteFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BitacoraClienteFindFirstArgs<ExtArgs>>
    ): Prisma__BitacoraClienteClient<$Result.GetResult<Prisma.$BitacoraClientePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first BitacoraCliente that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BitacoraClienteFindFirstOrThrowArgs} args - Arguments to find a BitacoraCliente
     * @example
     * // Get one BitacoraCliente
     * const bitacoraCliente = await prisma.bitacoraCliente.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BitacoraClienteFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BitacoraClienteFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BitacoraClienteClient<$Result.GetResult<Prisma.$BitacoraClientePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more BitacoraClientes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BitacoraClienteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BitacoraClientes
     * const bitacoraClientes = await prisma.bitacoraCliente.findMany()
     * 
     * // Get first 10 BitacoraClientes
     * const bitacoraClientes = await prisma.bitacoraCliente.findMany({ take: 10 })
     * 
     * // Only select the `bitacoraID`
     * const bitacoraClienteWithBitacoraIDOnly = await prisma.bitacoraCliente.findMany({ select: { bitacoraID: true } })
     * 
    **/
    findMany<T extends BitacoraClienteFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BitacoraClienteFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BitacoraClientePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a BitacoraCliente.
     * @param {BitacoraClienteCreateArgs} args - Arguments to create a BitacoraCliente.
     * @example
     * // Create one BitacoraCliente
     * const BitacoraCliente = await prisma.bitacoraCliente.create({
     *   data: {
     *     // ... data to create a BitacoraCliente
     *   }
     * })
     * 
    **/
    create<T extends BitacoraClienteCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BitacoraClienteCreateArgs<ExtArgs>>
    ): Prisma__BitacoraClienteClient<$Result.GetResult<Prisma.$BitacoraClientePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many BitacoraClientes.
     *     @param {BitacoraClienteCreateManyArgs} args - Arguments to create many BitacoraClientes.
     *     @example
     *     // Create many BitacoraClientes
     *     const bitacoraCliente = await prisma.bitacoraCliente.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BitacoraClienteCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BitacoraClienteCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BitacoraCliente.
     * @param {BitacoraClienteDeleteArgs} args - Arguments to delete one BitacoraCliente.
     * @example
     * // Delete one BitacoraCliente
     * const BitacoraCliente = await prisma.bitacoraCliente.delete({
     *   where: {
     *     // ... filter to delete one BitacoraCliente
     *   }
     * })
     * 
    **/
    delete<T extends BitacoraClienteDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BitacoraClienteDeleteArgs<ExtArgs>>
    ): Prisma__BitacoraClienteClient<$Result.GetResult<Prisma.$BitacoraClientePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one BitacoraCliente.
     * @param {BitacoraClienteUpdateArgs} args - Arguments to update one BitacoraCliente.
     * @example
     * // Update one BitacoraCliente
     * const bitacoraCliente = await prisma.bitacoraCliente.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BitacoraClienteUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BitacoraClienteUpdateArgs<ExtArgs>>
    ): Prisma__BitacoraClienteClient<$Result.GetResult<Prisma.$BitacoraClientePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more BitacoraClientes.
     * @param {BitacoraClienteDeleteManyArgs} args - Arguments to filter BitacoraClientes to delete.
     * @example
     * // Delete a few BitacoraClientes
     * const { count } = await prisma.bitacoraCliente.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BitacoraClienteDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BitacoraClienteDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BitacoraClientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BitacoraClienteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BitacoraClientes
     * const bitacoraCliente = await prisma.bitacoraCliente.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BitacoraClienteUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BitacoraClienteUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BitacoraCliente.
     * @param {BitacoraClienteUpsertArgs} args - Arguments to update or create a BitacoraCliente.
     * @example
     * // Update or create a BitacoraCliente
     * const bitacoraCliente = await prisma.bitacoraCliente.upsert({
     *   create: {
     *     // ... data to create a BitacoraCliente
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BitacoraCliente we want to update
     *   }
     * })
    **/
    upsert<T extends BitacoraClienteUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BitacoraClienteUpsertArgs<ExtArgs>>
    ): Prisma__BitacoraClienteClient<$Result.GetResult<Prisma.$BitacoraClientePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of BitacoraClientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BitacoraClienteCountArgs} args - Arguments to filter BitacoraClientes to count.
     * @example
     * // Count the number of BitacoraClientes
     * const count = await prisma.bitacoraCliente.count({
     *   where: {
     *     // ... the filter for the BitacoraClientes we want to count
     *   }
     * })
    **/
    count<T extends BitacoraClienteCountArgs>(
      args?: Subset<T, BitacoraClienteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BitacoraClienteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BitacoraCliente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BitacoraClienteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BitacoraClienteAggregateArgs>(args: Subset<T, BitacoraClienteAggregateArgs>): Prisma.PrismaPromise<GetBitacoraClienteAggregateType<T>>

    /**
     * Group by BitacoraCliente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BitacoraClienteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BitacoraClienteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BitacoraClienteGroupByArgs['orderBy'] }
        : { orderBy?: BitacoraClienteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BitacoraClienteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBitacoraClienteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BitacoraCliente model
   */
  readonly fields: BitacoraClienteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BitacoraCliente.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BitacoraClienteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Usuarios<T extends BitacoraCliente$UsuariosArgs<ExtArgs> = {}>(args?: Subset<T, BitacoraCliente$UsuariosArgs<ExtArgs>>): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the BitacoraCliente model
   */ 
  interface BitacoraClienteFieldRefs {
    readonly bitacoraID: FieldRef<"BitacoraCliente", 'Int'>
    readonly clienteID: FieldRef<"BitacoraCliente", 'Int'>
    readonly fechaRegistro: FieldRef<"BitacoraCliente", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * BitacoraCliente findUnique
   */
  export type BitacoraClienteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BitacoraCliente
     */
    select?: BitacoraClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BitacoraClienteInclude<ExtArgs> | null
    /**
     * Filter, which BitacoraCliente to fetch.
     */
    where: BitacoraClienteWhereUniqueInput
  }


  /**
   * BitacoraCliente findUniqueOrThrow
   */
  export type BitacoraClienteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BitacoraCliente
     */
    select?: BitacoraClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BitacoraClienteInclude<ExtArgs> | null
    /**
     * Filter, which BitacoraCliente to fetch.
     */
    where: BitacoraClienteWhereUniqueInput
  }


  /**
   * BitacoraCliente findFirst
   */
  export type BitacoraClienteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BitacoraCliente
     */
    select?: BitacoraClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BitacoraClienteInclude<ExtArgs> | null
    /**
     * Filter, which BitacoraCliente to fetch.
     */
    where?: BitacoraClienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BitacoraClientes to fetch.
     */
    orderBy?: BitacoraClienteOrderByWithRelationInput | BitacoraClienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BitacoraClientes.
     */
    cursor?: BitacoraClienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BitacoraClientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BitacoraClientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BitacoraClientes.
     */
    distinct?: BitacoraClienteScalarFieldEnum | BitacoraClienteScalarFieldEnum[]
  }


  /**
   * BitacoraCliente findFirstOrThrow
   */
  export type BitacoraClienteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BitacoraCliente
     */
    select?: BitacoraClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BitacoraClienteInclude<ExtArgs> | null
    /**
     * Filter, which BitacoraCliente to fetch.
     */
    where?: BitacoraClienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BitacoraClientes to fetch.
     */
    orderBy?: BitacoraClienteOrderByWithRelationInput | BitacoraClienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BitacoraClientes.
     */
    cursor?: BitacoraClienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BitacoraClientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BitacoraClientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BitacoraClientes.
     */
    distinct?: BitacoraClienteScalarFieldEnum | BitacoraClienteScalarFieldEnum[]
  }


  /**
   * BitacoraCliente findMany
   */
  export type BitacoraClienteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BitacoraCliente
     */
    select?: BitacoraClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BitacoraClienteInclude<ExtArgs> | null
    /**
     * Filter, which BitacoraClientes to fetch.
     */
    where?: BitacoraClienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BitacoraClientes to fetch.
     */
    orderBy?: BitacoraClienteOrderByWithRelationInput | BitacoraClienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BitacoraClientes.
     */
    cursor?: BitacoraClienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BitacoraClientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BitacoraClientes.
     */
    skip?: number
    distinct?: BitacoraClienteScalarFieldEnum | BitacoraClienteScalarFieldEnum[]
  }


  /**
   * BitacoraCliente create
   */
  export type BitacoraClienteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BitacoraCliente
     */
    select?: BitacoraClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BitacoraClienteInclude<ExtArgs> | null
    /**
     * The data needed to create a BitacoraCliente.
     */
    data?: XOR<BitacoraClienteCreateInput, BitacoraClienteUncheckedCreateInput>
  }


  /**
   * BitacoraCliente createMany
   */
  export type BitacoraClienteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BitacoraClientes.
     */
    data: BitacoraClienteCreateManyInput | BitacoraClienteCreateManyInput[]
  }


  /**
   * BitacoraCliente update
   */
  export type BitacoraClienteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BitacoraCliente
     */
    select?: BitacoraClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BitacoraClienteInclude<ExtArgs> | null
    /**
     * The data needed to update a BitacoraCliente.
     */
    data: XOR<BitacoraClienteUpdateInput, BitacoraClienteUncheckedUpdateInput>
    /**
     * Choose, which BitacoraCliente to update.
     */
    where: BitacoraClienteWhereUniqueInput
  }


  /**
   * BitacoraCliente updateMany
   */
  export type BitacoraClienteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BitacoraClientes.
     */
    data: XOR<BitacoraClienteUpdateManyMutationInput, BitacoraClienteUncheckedUpdateManyInput>
    /**
     * Filter which BitacoraClientes to update
     */
    where?: BitacoraClienteWhereInput
  }


  /**
   * BitacoraCliente upsert
   */
  export type BitacoraClienteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BitacoraCliente
     */
    select?: BitacoraClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BitacoraClienteInclude<ExtArgs> | null
    /**
     * The filter to search for the BitacoraCliente to update in case it exists.
     */
    where: BitacoraClienteWhereUniqueInput
    /**
     * In case the BitacoraCliente found by the `where` argument doesn't exist, create a new BitacoraCliente with this data.
     */
    create: XOR<BitacoraClienteCreateInput, BitacoraClienteUncheckedCreateInput>
    /**
     * In case the BitacoraCliente was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BitacoraClienteUpdateInput, BitacoraClienteUncheckedUpdateInput>
  }


  /**
   * BitacoraCliente delete
   */
  export type BitacoraClienteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BitacoraCliente
     */
    select?: BitacoraClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BitacoraClienteInclude<ExtArgs> | null
    /**
     * Filter which BitacoraCliente to delete.
     */
    where: BitacoraClienteWhereUniqueInput
  }


  /**
   * BitacoraCliente deleteMany
   */
  export type BitacoraClienteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BitacoraClientes to delete
     */
    where?: BitacoraClienteWhereInput
  }


  /**
   * BitacoraCliente.Usuarios
   */
  export type BitacoraCliente$UsuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuariosInclude<ExtArgs> | null
    where?: UsuariosWhereInput
  }


  /**
   * BitacoraCliente without action
   */
  export type BitacoraClienteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BitacoraCliente
     */
    select?: BitacoraClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BitacoraClienteInclude<ExtArgs> | null
  }



  /**
   * Model BitacoraEstilista
   */

  export type AggregateBitacoraEstilista = {
    _count: BitacoraEstilistaCountAggregateOutputType | null
    _avg: BitacoraEstilistaAvgAggregateOutputType | null
    _sum: BitacoraEstilistaSumAggregateOutputType | null
    _min: BitacoraEstilistaMinAggregateOutputType | null
    _max: BitacoraEstilistaMaxAggregateOutputType | null
  }

  export type BitacoraEstilistaAvgAggregateOutputType = {
    bitacoraID: number | null
    estilistaID: number | null
  }

  export type BitacoraEstilistaSumAggregateOutputType = {
    bitacoraID: number | null
    estilistaID: number | null
  }

  export type BitacoraEstilistaMinAggregateOutputType = {
    bitacoraID: number | null
    estilistaID: number | null
    fechaIngreso: Date | null
    fechaSalida: Date | null
  }

  export type BitacoraEstilistaMaxAggregateOutputType = {
    bitacoraID: number | null
    estilistaID: number | null
    fechaIngreso: Date | null
    fechaSalida: Date | null
  }

  export type BitacoraEstilistaCountAggregateOutputType = {
    bitacoraID: number
    estilistaID: number
    fechaIngreso: number
    fechaSalida: number
    _all: number
  }


  export type BitacoraEstilistaAvgAggregateInputType = {
    bitacoraID?: true
    estilistaID?: true
  }

  export type BitacoraEstilistaSumAggregateInputType = {
    bitacoraID?: true
    estilistaID?: true
  }

  export type BitacoraEstilistaMinAggregateInputType = {
    bitacoraID?: true
    estilistaID?: true
    fechaIngreso?: true
    fechaSalida?: true
  }

  export type BitacoraEstilistaMaxAggregateInputType = {
    bitacoraID?: true
    estilistaID?: true
    fechaIngreso?: true
    fechaSalida?: true
  }

  export type BitacoraEstilistaCountAggregateInputType = {
    bitacoraID?: true
    estilistaID?: true
    fechaIngreso?: true
    fechaSalida?: true
    _all?: true
  }

  export type BitacoraEstilistaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BitacoraEstilista to aggregate.
     */
    where?: BitacoraEstilistaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BitacoraEstilistas to fetch.
     */
    orderBy?: BitacoraEstilistaOrderByWithRelationInput | BitacoraEstilistaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BitacoraEstilistaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BitacoraEstilistas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BitacoraEstilistas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BitacoraEstilistas
    **/
    _count?: true | BitacoraEstilistaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BitacoraEstilistaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BitacoraEstilistaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BitacoraEstilistaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BitacoraEstilistaMaxAggregateInputType
  }

  export type GetBitacoraEstilistaAggregateType<T extends BitacoraEstilistaAggregateArgs> = {
        [P in keyof T & keyof AggregateBitacoraEstilista]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBitacoraEstilista[P]>
      : GetScalarType<T[P], AggregateBitacoraEstilista[P]>
  }




  export type BitacoraEstilistaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BitacoraEstilistaWhereInput
    orderBy?: BitacoraEstilistaOrderByWithAggregationInput | BitacoraEstilistaOrderByWithAggregationInput[]
    by: BitacoraEstilistaScalarFieldEnum[] | BitacoraEstilistaScalarFieldEnum
    having?: BitacoraEstilistaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BitacoraEstilistaCountAggregateInputType | true
    _avg?: BitacoraEstilistaAvgAggregateInputType
    _sum?: BitacoraEstilistaSumAggregateInputType
    _min?: BitacoraEstilistaMinAggregateInputType
    _max?: BitacoraEstilistaMaxAggregateInputType
  }

  export type BitacoraEstilistaGroupByOutputType = {
    bitacoraID: number
    estilistaID: number | null
    fechaIngreso: Date | null
    fechaSalida: Date | null
    _count: BitacoraEstilistaCountAggregateOutputType | null
    _avg: BitacoraEstilistaAvgAggregateOutputType | null
    _sum: BitacoraEstilistaSumAggregateOutputType | null
    _min: BitacoraEstilistaMinAggregateOutputType | null
    _max: BitacoraEstilistaMaxAggregateOutputType | null
  }

  type GetBitacoraEstilistaGroupByPayload<T extends BitacoraEstilistaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BitacoraEstilistaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BitacoraEstilistaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BitacoraEstilistaGroupByOutputType[P]>
            : GetScalarType<T[P], BitacoraEstilistaGroupByOutputType[P]>
        }
      >
    >


  export type BitacoraEstilistaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    bitacoraID?: boolean
    estilistaID?: boolean
    fechaIngreso?: boolean
    fechaSalida?: boolean
    Usuarios?: boolean | BitacoraEstilista$UsuariosArgs<ExtArgs>
  }, ExtArgs["result"]["bitacoraEstilista"]>

  export type BitacoraEstilistaSelectScalar = {
    bitacoraID?: boolean
    estilistaID?: boolean
    fechaIngreso?: boolean
    fechaSalida?: boolean
  }

  export type BitacoraEstilistaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Usuarios?: boolean | BitacoraEstilista$UsuariosArgs<ExtArgs>
  }


  export type $BitacoraEstilistaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BitacoraEstilista"
    objects: {
      Usuarios: Prisma.$UsuariosPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      bitacoraID: number
      estilistaID: number | null
      fechaIngreso: Date | null
      fechaSalida: Date | null
    }, ExtArgs["result"]["bitacoraEstilista"]>
    composites: {}
  }


  type BitacoraEstilistaGetPayload<S extends boolean | null | undefined | BitacoraEstilistaDefaultArgs> = $Result.GetResult<Prisma.$BitacoraEstilistaPayload, S>

  type BitacoraEstilistaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BitacoraEstilistaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BitacoraEstilistaCountAggregateInputType | true
    }

  export interface BitacoraEstilistaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BitacoraEstilista'], meta: { name: 'BitacoraEstilista' } }
    /**
     * Find zero or one BitacoraEstilista that matches the filter.
     * @param {BitacoraEstilistaFindUniqueArgs} args - Arguments to find a BitacoraEstilista
     * @example
     * // Get one BitacoraEstilista
     * const bitacoraEstilista = await prisma.bitacoraEstilista.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BitacoraEstilistaFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BitacoraEstilistaFindUniqueArgs<ExtArgs>>
    ): Prisma__BitacoraEstilistaClient<$Result.GetResult<Prisma.$BitacoraEstilistaPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one BitacoraEstilista that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BitacoraEstilistaFindUniqueOrThrowArgs} args - Arguments to find a BitacoraEstilista
     * @example
     * // Get one BitacoraEstilista
     * const bitacoraEstilista = await prisma.bitacoraEstilista.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BitacoraEstilistaFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BitacoraEstilistaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BitacoraEstilistaClient<$Result.GetResult<Prisma.$BitacoraEstilistaPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first BitacoraEstilista that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BitacoraEstilistaFindFirstArgs} args - Arguments to find a BitacoraEstilista
     * @example
     * // Get one BitacoraEstilista
     * const bitacoraEstilista = await prisma.bitacoraEstilista.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BitacoraEstilistaFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BitacoraEstilistaFindFirstArgs<ExtArgs>>
    ): Prisma__BitacoraEstilistaClient<$Result.GetResult<Prisma.$BitacoraEstilistaPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first BitacoraEstilista that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BitacoraEstilistaFindFirstOrThrowArgs} args - Arguments to find a BitacoraEstilista
     * @example
     * // Get one BitacoraEstilista
     * const bitacoraEstilista = await prisma.bitacoraEstilista.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BitacoraEstilistaFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BitacoraEstilistaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BitacoraEstilistaClient<$Result.GetResult<Prisma.$BitacoraEstilistaPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more BitacoraEstilistas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BitacoraEstilistaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BitacoraEstilistas
     * const bitacoraEstilistas = await prisma.bitacoraEstilista.findMany()
     * 
     * // Get first 10 BitacoraEstilistas
     * const bitacoraEstilistas = await prisma.bitacoraEstilista.findMany({ take: 10 })
     * 
     * // Only select the `bitacoraID`
     * const bitacoraEstilistaWithBitacoraIDOnly = await prisma.bitacoraEstilista.findMany({ select: { bitacoraID: true } })
     * 
    **/
    findMany<T extends BitacoraEstilistaFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BitacoraEstilistaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BitacoraEstilistaPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a BitacoraEstilista.
     * @param {BitacoraEstilistaCreateArgs} args - Arguments to create a BitacoraEstilista.
     * @example
     * // Create one BitacoraEstilista
     * const BitacoraEstilista = await prisma.bitacoraEstilista.create({
     *   data: {
     *     // ... data to create a BitacoraEstilista
     *   }
     * })
     * 
    **/
    create<T extends BitacoraEstilistaCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BitacoraEstilistaCreateArgs<ExtArgs>>
    ): Prisma__BitacoraEstilistaClient<$Result.GetResult<Prisma.$BitacoraEstilistaPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many BitacoraEstilistas.
     *     @param {BitacoraEstilistaCreateManyArgs} args - Arguments to create many BitacoraEstilistas.
     *     @example
     *     // Create many BitacoraEstilistas
     *     const bitacoraEstilista = await prisma.bitacoraEstilista.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BitacoraEstilistaCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BitacoraEstilistaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BitacoraEstilista.
     * @param {BitacoraEstilistaDeleteArgs} args - Arguments to delete one BitacoraEstilista.
     * @example
     * // Delete one BitacoraEstilista
     * const BitacoraEstilista = await prisma.bitacoraEstilista.delete({
     *   where: {
     *     // ... filter to delete one BitacoraEstilista
     *   }
     * })
     * 
    **/
    delete<T extends BitacoraEstilistaDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BitacoraEstilistaDeleteArgs<ExtArgs>>
    ): Prisma__BitacoraEstilistaClient<$Result.GetResult<Prisma.$BitacoraEstilistaPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one BitacoraEstilista.
     * @param {BitacoraEstilistaUpdateArgs} args - Arguments to update one BitacoraEstilista.
     * @example
     * // Update one BitacoraEstilista
     * const bitacoraEstilista = await prisma.bitacoraEstilista.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BitacoraEstilistaUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BitacoraEstilistaUpdateArgs<ExtArgs>>
    ): Prisma__BitacoraEstilistaClient<$Result.GetResult<Prisma.$BitacoraEstilistaPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more BitacoraEstilistas.
     * @param {BitacoraEstilistaDeleteManyArgs} args - Arguments to filter BitacoraEstilistas to delete.
     * @example
     * // Delete a few BitacoraEstilistas
     * const { count } = await prisma.bitacoraEstilista.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BitacoraEstilistaDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BitacoraEstilistaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BitacoraEstilistas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BitacoraEstilistaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BitacoraEstilistas
     * const bitacoraEstilista = await prisma.bitacoraEstilista.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BitacoraEstilistaUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BitacoraEstilistaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BitacoraEstilista.
     * @param {BitacoraEstilistaUpsertArgs} args - Arguments to update or create a BitacoraEstilista.
     * @example
     * // Update or create a BitacoraEstilista
     * const bitacoraEstilista = await prisma.bitacoraEstilista.upsert({
     *   create: {
     *     // ... data to create a BitacoraEstilista
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BitacoraEstilista we want to update
     *   }
     * })
    **/
    upsert<T extends BitacoraEstilistaUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BitacoraEstilistaUpsertArgs<ExtArgs>>
    ): Prisma__BitacoraEstilistaClient<$Result.GetResult<Prisma.$BitacoraEstilistaPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of BitacoraEstilistas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BitacoraEstilistaCountArgs} args - Arguments to filter BitacoraEstilistas to count.
     * @example
     * // Count the number of BitacoraEstilistas
     * const count = await prisma.bitacoraEstilista.count({
     *   where: {
     *     // ... the filter for the BitacoraEstilistas we want to count
     *   }
     * })
    **/
    count<T extends BitacoraEstilistaCountArgs>(
      args?: Subset<T, BitacoraEstilistaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BitacoraEstilistaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BitacoraEstilista.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BitacoraEstilistaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BitacoraEstilistaAggregateArgs>(args: Subset<T, BitacoraEstilistaAggregateArgs>): Prisma.PrismaPromise<GetBitacoraEstilistaAggregateType<T>>

    /**
     * Group by BitacoraEstilista.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BitacoraEstilistaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BitacoraEstilistaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BitacoraEstilistaGroupByArgs['orderBy'] }
        : { orderBy?: BitacoraEstilistaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BitacoraEstilistaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBitacoraEstilistaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BitacoraEstilista model
   */
  readonly fields: BitacoraEstilistaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BitacoraEstilista.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BitacoraEstilistaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Usuarios<T extends BitacoraEstilista$UsuariosArgs<ExtArgs> = {}>(args?: Subset<T, BitacoraEstilista$UsuariosArgs<ExtArgs>>): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the BitacoraEstilista model
   */ 
  interface BitacoraEstilistaFieldRefs {
    readonly bitacoraID: FieldRef<"BitacoraEstilista", 'Int'>
    readonly estilistaID: FieldRef<"BitacoraEstilista", 'Int'>
    readonly fechaIngreso: FieldRef<"BitacoraEstilista", 'DateTime'>
    readonly fechaSalida: FieldRef<"BitacoraEstilista", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * BitacoraEstilista findUnique
   */
  export type BitacoraEstilistaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BitacoraEstilista
     */
    select?: BitacoraEstilistaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BitacoraEstilistaInclude<ExtArgs> | null
    /**
     * Filter, which BitacoraEstilista to fetch.
     */
    where: BitacoraEstilistaWhereUniqueInput
  }


  /**
   * BitacoraEstilista findUniqueOrThrow
   */
  export type BitacoraEstilistaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BitacoraEstilista
     */
    select?: BitacoraEstilistaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BitacoraEstilistaInclude<ExtArgs> | null
    /**
     * Filter, which BitacoraEstilista to fetch.
     */
    where: BitacoraEstilistaWhereUniqueInput
  }


  /**
   * BitacoraEstilista findFirst
   */
  export type BitacoraEstilistaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BitacoraEstilista
     */
    select?: BitacoraEstilistaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BitacoraEstilistaInclude<ExtArgs> | null
    /**
     * Filter, which BitacoraEstilista to fetch.
     */
    where?: BitacoraEstilistaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BitacoraEstilistas to fetch.
     */
    orderBy?: BitacoraEstilistaOrderByWithRelationInput | BitacoraEstilistaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BitacoraEstilistas.
     */
    cursor?: BitacoraEstilistaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BitacoraEstilistas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BitacoraEstilistas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BitacoraEstilistas.
     */
    distinct?: BitacoraEstilistaScalarFieldEnum | BitacoraEstilistaScalarFieldEnum[]
  }


  /**
   * BitacoraEstilista findFirstOrThrow
   */
  export type BitacoraEstilistaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BitacoraEstilista
     */
    select?: BitacoraEstilistaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BitacoraEstilistaInclude<ExtArgs> | null
    /**
     * Filter, which BitacoraEstilista to fetch.
     */
    where?: BitacoraEstilistaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BitacoraEstilistas to fetch.
     */
    orderBy?: BitacoraEstilistaOrderByWithRelationInput | BitacoraEstilistaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BitacoraEstilistas.
     */
    cursor?: BitacoraEstilistaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BitacoraEstilistas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BitacoraEstilistas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BitacoraEstilistas.
     */
    distinct?: BitacoraEstilistaScalarFieldEnum | BitacoraEstilistaScalarFieldEnum[]
  }


  /**
   * BitacoraEstilista findMany
   */
  export type BitacoraEstilistaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BitacoraEstilista
     */
    select?: BitacoraEstilistaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BitacoraEstilistaInclude<ExtArgs> | null
    /**
     * Filter, which BitacoraEstilistas to fetch.
     */
    where?: BitacoraEstilistaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BitacoraEstilistas to fetch.
     */
    orderBy?: BitacoraEstilistaOrderByWithRelationInput | BitacoraEstilistaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BitacoraEstilistas.
     */
    cursor?: BitacoraEstilistaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BitacoraEstilistas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BitacoraEstilistas.
     */
    skip?: number
    distinct?: BitacoraEstilistaScalarFieldEnum | BitacoraEstilistaScalarFieldEnum[]
  }


  /**
   * BitacoraEstilista create
   */
  export type BitacoraEstilistaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BitacoraEstilista
     */
    select?: BitacoraEstilistaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BitacoraEstilistaInclude<ExtArgs> | null
    /**
     * The data needed to create a BitacoraEstilista.
     */
    data?: XOR<BitacoraEstilistaCreateInput, BitacoraEstilistaUncheckedCreateInput>
  }


  /**
   * BitacoraEstilista createMany
   */
  export type BitacoraEstilistaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BitacoraEstilistas.
     */
    data: BitacoraEstilistaCreateManyInput | BitacoraEstilistaCreateManyInput[]
  }


  /**
   * BitacoraEstilista update
   */
  export type BitacoraEstilistaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BitacoraEstilista
     */
    select?: BitacoraEstilistaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BitacoraEstilistaInclude<ExtArgs> | null
    /**
     * The data needed to update a BitacoraEstilista.
     */
    data: XOR<BitacoraEstilistaUpdateInput, BitacoraEstilistaUncheckedUpdateInput>
    /**
     * Choose, which BitacoraEstilista to update.
     */
    where: BitacoraEstilistaWhereUniqueInput
  }


  /**
   * BitacoraEstilista updateMany
   */
  export type BitacoraEstilistaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BitacoraEstilistas.
     */
    data: XOR<BitacoraEstilistaUpdateManyMutationInput, BitacoraEstilistaUncheckedUpdateManyInput>
    /**
     * Filter which BitacoraEstilistas to update
     */
    where?: BitacoraEstilistaWhereInput
  }


  /**
   * BitacoraEstilista upsert
   */
  export type BitacoraEstilistaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BitacoraEstilista
     */
    select?: BitacoraEstilistaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BitacoraEstilistaInclude<ExtArgs> | null
    /**
     * The filter to search for the BitacoraEstilista to update in case it exists.
     */
    where: BitacoraEstilistaWhereUniqueInput
    /**
     * In case the BitacoraEstilista found by the `where` argument doesn't exist, create a new BitacoraEstilista with this data.
     */
    create: XOR<BitacoraEstilistaCreateInput, BitacoraEstilistaUncheckedCreateInput>
    /**
     * In case the BitacoraEstilista was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BitacoraEstilistaUpdateInput, BitacoraEstilistaUncheckedUpdateInput>
  }


  /**
   * BitacoraEstilista delete
   */
  export type BitacoraEstilistaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BitacoraEstilista
     */
    select?: BitacoraEstilistaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BitacoraEstilistaInclude<ExtArgs> | null
    /**
     * Filter which BitacoraEstilista to delete.
     */
    where: BitacoraEstilistaWhereUniqueInput
  }


  /**
   * BitacoraEstilista deleteMany
   */
  export type BitacoraEstilistaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BitacoraEstilistas to delete
     */
    where?: BitacoraEstilistaWhereInput
  }


  /**
   * BitacoraEstilista.Usuarios
   */
  export type BitacoraEstilista$UsuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuariosInclude<ExtArgs> | null
    where?: UsuariosWhereInput
  }


  /**
   * BitacoraEstilista without action
   */
  export type BitacoraEstilistaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BitacoraEstilista
     */
    select?: BitacoraEstilistaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BitacoraEstilistaInclude<ExtArgs> | null
  }



  /**
   * Model BloqueoHorarios
   */

  export type AggregateBloqueoHorarios = {
    _count: BloqueoHorariosCountAggregateOutputType | null
    _avg: BloqueoHorariosAvgAggregateOutputType | null
    _sum: BloqueoHorariosSumAggregateOutputType | null
    _min: BloqueoHorariosMinAggregateOutputType | null
    _max: BloqueoHorariosMaxAggregateOutputType | null
  }

  export type BloqueoHorariosAvgAggregateOutputType = {
    bloqueoID: number | null
    estilistaID: number | null
  }

  export type BloqueoHorariosSumAggregateOutputType = {
    bloqueoID: number | null
    estilistaID: number | null
  }

  export type BloqueoHorariosMinAggregateOutputType = {
    bloqueoID: number | null
    estilistaID: number | null
    dia: string | null
    horaInicio: Date | null
    horaFinal: Date | null
    motivo: string | null
  }

  export type BloqueoHorariosMaxAggregateOutputType = {
    bloqueoID: number | null
    estilistaID: number | null
    dia: string | null
    horaInicio: Date | null
    horaFinal: Date | null
    motivo: string | null
  }

  export type BloqueoHorariosCountAggregateOutputType = {
    bloqueoID: number
    estilistaID: number
    dia: number
    horaInicio: number
    horaFinal: number
    motivo: number
    _all: number
  }


  export type BloqueoHorariosAvgAggregateInputType = {
    bloqueoID?: true
    estilistaID?: true
  }

  export type BloqueoHorariosSumAggregateInputType = {
    bloqueoID?: true
    estilistaID?: true
  }

  export type BloqueoHorariosMinAggregateInputType = {
    bloqueoID?: true
    estilistaID?: true
    dia?: true
    horaInicio?: true
    horaFinal?: true
    motivo?: true
  }

  export type BloqueoHorariosMaxAggregateInputType = {
    bloqueoID?: true
    estilistaID?: true
    dia?: true
    horaInicio?: true
    horaFinal?: true
    motivo?: true
  }

  export type BloqueoHorariosCountAggregateInputType = {
    bloqueoID?: true
    estilistaID?: true
    dia?: true
    horaInicio?: true
    horaFinal?: true
    motivo?: true
    _all?: true
  }

  export type BloqueoHorariosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BloqueoHorarios to aggregate.
     */
    where?: BloqueoHorariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BloqueoHorarios to fetch.
     */
    orderBy?: BloqueoHorariosOrderByWithRelationInput | BloqueoHorariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BloqueoHorariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BloqueoHorarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BloqueoHorarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BloqueoHorarios
    **/
    _count?: true | BloqueoHorariosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BloqueoHorariosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BloqueoHorariosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BloqueoHorariosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BloqueoHorariosMaxAggregateInputType
  }

  export type GetBloqueoHorariosAggregateType<T extends BloqueoHorariosAggregateArgs> = {
        [P in keyof T & keyof AggregateBloqueoHorarios]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBloqueoHorarios[P]>
      : GetScalarType<T[P], AggregateBloqueoHorarios[P]>
  }




  export type BloqueoHorariosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BloqueoHorariosWhereInput
    orderBy?: BloqueoHorariosOrderByWithAggregationInput | BloqueoHorariosOrderByWithAggregationInput[]
    by: BloqueoHorariosScalarFieldEnum[] | BloqueoHorariosScalarFieldEnum
    having?: BloqueoHorariosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BloqueoHorariosCountAggregateInputType | true
    _avg?: BloqueoHorariosAvgAggregateInputType
    _sum?: BloqueoHorariosSumAggregateInputType
    _min?: BloqueoHorariosMinAggregateInputType
    _max?: BloqueoHorariosMaxAggregateInputType
  }

  export type BloqueoHorariosGroupByOutputType = {
    bloqueoID: number
    estilistaID: number | null
    dia: string | null
    horaInicio: Date | null
    horaFinal: Date | null
    motivo: string | null
    _count: BloqueoHorariosCountAggregateOutputType | null
    _avg: BloqueoHorariosAvgAggregateOutputType | null
    _sum: BloqueoHorariosSumAggregateOutputType | null
    _min: BloqueoHorariosMinAggregateOutputType | null
    _max: BloqueoHorariosMaxAggregateOutputType | null
  }

  type GetBloqueoHorariosGroupByPayload<T extends BloqueoHorariosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BloqueoHorariosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BloqueoHorariosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BloqueoHorariosGroupByOutputType[P]>
            : GetScalarType<T[P], BloqueoHorariosGroupByOutputType[P]>
        }
      >
    >


  export type BloqueoHorariosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    bloqueoID?: boolean
    estilistaID?: boolean
    dia?: boolean
    horaInicio?: boolean
    horaFinal?: boolean
    motivo?: boolean
    Usuarios?: boolean | BloqueoHorarios$UsuariosArgs<ExtArgs>
  }, ExtArgs["result"]["bloqueoHorarios"]>

  export type BloqueoHorariosSelectScalar = {
    bloqueoID?: boolean
    estilistaID?: boolean
    dia?: boolean
    horaInicio?: boolean
    horaFinal?: boolean
    motivo?: boolean
  }

  export type BloqueoHorariosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Usuarios?: boolean | BloqueoHorarios$UsuariosArgs<ExtArgs>
  }


  export type $BloqueoHorariosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BloqueoHorarios"
    objects: {
      Usuarios: Prisma.$UsuariosPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      bloqueoID: number
      estilistaID: number | null
      dia: string | null
      horaInicio: Date | null
      horaFinal: Date | null
      motivo: string | null
    }, ExtArgs["result"]["bloqueoHorarios"]>
    composites: {}
  }


  type BloqueoHorariosGetPayload<S extends boolean | null | undefined | BloqueoHorariosDefaultArgs> = $Result.GetResult<Prisma.$BloqueoHorariosPayload, S>

  type BloqueoHorariosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BloqueoHorariosFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BloqueoHorariosCountAggregateInputType | true
    }

  export interface BloqueoHorariosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BloqueoHorarios'], meta: { name: 'BloqueoHorarios' } }
    /**
     * Find zero or one BloqueoHorarios that matches the filter.
     * @param {BloqueoHorariosFindUniqueArgs} args - Arguments to find a BloqueoHorarios
     * @example
     * // Get one BloqueoHorarios
     * const bloqueoHorarios = await prisma.bloqueoHorarios.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BloqueoHorariosFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BloqueoHorariosFindUniqueArgs<ExtArgs>>
    ): Prisma__BloqueoHorariosClient<$Result.GetResult<Prisma.$BloqueoHorariosPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one BloqueoHorarios that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BloqueoHorariosFindUniqueOrThrowArgs} args - Arguments to find a BloqueoHorarios
     * @example
     * // Get one BloqueoHorarios
     * const bloqueoHorarios = await prisma.bloqueoHorarios.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BloqueoHorariosFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BloqueoHorariosFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BloqueoHorariosClient<$Result.GetResult<Prisma.$BloqueoHorariosPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first BloqueoHorarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BloqueoHorariosFindFirstArgs} args - Arguments to find a BloqueoHorarios
     * @example
     * // Get one BloqueoHorarios
     * const bloqueoHorarios = await prisma.bloqueoHorarios.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BloqueoHorariosFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BloqueoHorariosFindFirstArgs<ExtArgs>>
    ): Prisma__BloqueoHorariosClient<$Result.GetResult<Prisma.$BloqueoHorariosPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first BloqueoHorarios that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BloqueoHorariosFindFirstOrThrowArgs} args - Arguments to find a BloqueoHorarios
     * @example
     * // Get one BloqueoHorarios
     * const bloqueoHorarios = await prisma.bloqueoHorarios.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BloqueoHorariosFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BloqueoHorariosFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BloqueoHorariosClient<$Result.GetResult<Prisma.$BloqueoHorariosPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more BloqueoHorarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BloqueoHorariosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BloqueoHorarios
     * const bloqueoHorarios = await prisma.bloqueoHorarios.findMany()
     * 
     * // Get first 10 BloqueoHorarios
     * const bloqueoHorarios = await prisma.bloqueoHorarios.findMany({ take: 10 })
     * 
     * // Only select the `bloqueoID`
     * const bloqueoHorariosWithBloqueoIDOnly = await prisma.bloqueoHorarios.findMany({ select: { bloqueoID: true } })
     * 
    **/
    findMany<T extends BloqueoHorariosFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BloqueoHorariosFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BloqueoHorariosPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a BloqueoHorarios.
     * @param {BloqueoHorariosCreateArgs} args - Arguments to create a BloqueoHorarios.
     * @example
     * // Create one BloqueoHorarios
     * const BloqueoHorarios = await prisma.bloqueoHorarios.create({
     *   data: {
     *     // ... data to create a BloqueoHorarios
     *   }
     * })
     * 
    **/
    create<T extends BloqueoHorariosCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BloqueoHorariosCreateArgs<ExtArgs>>
    ): Prisma__BloqueoHorariosClient<$Result.GetResult<Prisma.$BloqueoHorariosPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many BloqueoHorarios.
     *     @param {BloqueoHorariosCreateManyArgs} args - Arguments to create many BloqueoHorarios.
     *     @example
     *     // Create many BloqueoHorarios
     *     const bloqueoHorarios = await prisma.bloqueoHorarios.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BloqueoHorariosCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BloqueoHorariosCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BloqueoHorarios.
     * @param {BloqueoHorariosDeleteArgs} args - Arguments to delete one BloqueoHorarios.
     * @example
     * // Delete one BloqueoHorarios
     * const BloqueoHorarios = await prisma.bloqueoHorarios.delete({
     *   where: {
     *     // ... filter to delete one BloqueoHorarios
     *   }
     * })
     * 
    **/
    delete<T extends BloqueoHorariosDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BloqueoHorariosDeleteArgs<ExtArgs>>
    ): Prisma__BloqueoHorariosClient<$Result.GetResult<Prisma.$BloqueoHorariosPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one BloqueoHorarios.
     * @param {BloqueoHorariosUpdateArgs} args - Arguments to update one BloqueoHorarios.
     * @example
     * // Update one BloqueoHorarios
     * const bloqueoHorarios = await prisma.bloqueoHorarios.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BloqueoHorariosUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BloqueoHorariosUpdateArgs<ExtArgs>>
    ): Prisma__BloqueoHorariosClient<$Result.GetResult<Prisma.$BloqueoHorariosPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more BloqueoHorarios.
     * @param {BloqueoHorariosDeleteManyArgs} args - Arguments to filter BloqueoHorarios to delete.
     * @example
     * // Delete a few BloqueoHorarios
     * const { count } = await prisma.bloqueoHorarios.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BloqueoHorariosDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BloqueoHorariosDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BloqueoHorarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BloqueoHorariosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BloqueoHorarios
     * const bloqueoHorarios = await prisma.bloqueoHorarios.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BloqueoHorariosUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BloqueoHorariosUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BloqueoHorarios.
     * @param {BloqueoHorariosUpsertArgs} args - Arguments to update or create a BloqueoHorarios.
     * @example
     * // Update or create a BloqueoHorarios
     * const bloqueoHorarios = await prisma.bloqueoHorarios.upsert({
     *   create: {
     *     // ... data to create a BloqueoHorarios
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BloqueoHorarios we want to update
     *   }
     * })
    **/
    upsert<T extends BloqueoHorariosUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BloqueoHorariosUpsertArgs<ExtArgs>>
    ): Prisma__BloqueoHorariosClient<$Result.GetResult<Prisma.$BloqueoHorariosPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of BloqueoHorarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BloqueoHorariosCountArgs} args - Arguments to filter BloqueoHorarios to count.
     * @example
     * // Count the number of BloqueoHorarios
     * const count = await prisma.bloqueoHorarios.count({
     *   where: {
     *     // ... the filter for the BloqueoHorarios we want to count
     *   }
     * })
    **/
    count<T extends BloqueoHorariosCountArgs>(
      args?: Subset<T, BloqueoHorariosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BloqueoHorariosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BloqueoHorarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BloqueoHorariosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BloqueoHorariosAggregateArgs>(args: Subset<T, BloqueoHorariosAggregateArgs>): Prisma.PrismaPromise<GetBloqueoHorariosAggregateType<T>>

    /**
     * Group by BloqueoHorarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BloqueoHorariosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BloqueoHorariosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BloqueoHorariosGroupByArgs['orderBy'] }
        : { orderBy?: BloqueoHorariosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BloqueoHorariosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBloqueoHorariosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BloqueoHorarios model
   */
  readonly fields: BloqueoHorariosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BloqueoHorarios.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BloqueoHorariosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Usuarios<T extends BloqueoHorarios$UsuariosArgs<ExtArgs> = {}>(args?: Subset<T, BloqueoHorarios$UsuariosArgs<ExtArgs>>): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the BloqueoHorarios model
   */ 
  interface BloqueoHorariosFieldRefs {
    readonly bloqueoID: FieldRef<"BloqueoHorarios", 'Int'>
    readonly estilistaID: FieldRef<"BloqueoHorarios", 'Int'>
    readonly dia: FieldRef<"BloqueoHorarios", 'String'>
    readonly horaInicio: FieldRef<"BloqueoHorarios", 'DateTime'>
    readonly horaFinal: FieldRef<"BloqueoHorarios", 'DateTime'>
    readonly motivo: FieldRef<"BloqueoHorarios", 'String'>
  }
    

  // Custom InputTypes

  /**
   * BloqueoHorarios findUnique
   */
  export type BloqueoHorariosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BloqueoHorarios
     */
    select?: BloqueoHorariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BloqueoHorariosInclude<ExtArgs> | null
    /**
     * Filter, which BloqueoHorarios to fetch.
     */
    where: BloqueoHorariosWhereUniqueInput
  }


  /**
   * BloqueoHorarios findUniqueOrThrow
   */
  export type BloqueoHorariosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BloqueoHorarios
     */
    select?: BloqueoHorariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BloqueoHorariosInclude<ExtArgs> | null
    /**
     * Filter, which BloqueoHorarios to fetch.
     */
    where: BloqueoHorariosWhereUniqueInput
  }


  /**
   * BloqueoHorarios findFirst
   */
  export type BloqueoHorariosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BloqueoHorarios
     */
    select?: BloqueoHorariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BloqueoHorariosInclude<ExtArgs> | null
    /**
     * Filter, which BloqueoHorarios to fetch.
     */
    where?: BloqueoHorariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BloqueoHorarios to fetch.
     */
    orderBy?: BloqueoHorariosOrderByWithRelationInput | BloqueoHorariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BloqueoHorarios.
     */
    cursor?: BloqueoHorariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BloqueoHorarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BloqueoHorarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BloqueoHorarios.
     */
    distinct?: BloqueoHorariosScalarFieldEnum | BloqueoHorariosScalarFieldEnum[]
  }


  /**
   * BloqueoHorarios findFirstOrThrow
   */
  export type BloqueoHorariosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BloqueoHorarios
     */
    select?: BloqueoHorariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BloqueoHorariosInclude<ExtArgs> | null
    /**
     * Filter, which BloqueoHorarios to fetch.
     */
    where?: BloqueoHorariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BloqueoHorarios to fetch.
     */
    orderBy?: BloqueoHorariosOrderByWithRelationInput | BloqueoHorariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BloqueoHorarios.
     */
    cursor?: BloqueoHorariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BloqueoHorarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BloqueoHorarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BloqueoHorarios.
     */
    distinct?: BloqueoHorariosScalarFieldEnum | BloqueoHorariosScalarFieldEnum[]
  }


  /**
   * BloqueoHorarios findMany
   */
  export type BloqueoHorariosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BloqueoHorarios
     */
    select?: BloqueoHorariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BloqueoHorariosInclude<ExtArgs> | null
    /**
     * Filter, which BloqueoHorarios to fetch.
     */
    where?: BloqueoHorariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BloqueoHorarios to fetch.
     */
    orderBy?: BloqueoHorariosOrderByWithRelationInput | BloqueoHorariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BloqueoHorarios.
     */
    cursor?: BloqueoHorariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BloqueoHorarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BloqueoHorarios.
     */
    skip?: number
    distinct?: BloqueoHorariosScalarFieldEnum | BloqueoHorariosScalarFieldEnum[]
  }


  /**
   * BloqueoHorarios create
   */
  export type BloqueoHorariosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BloqueoHorarios
     */
    select?: BloqueoHorariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BloqueoHorariosInclude<ExtArgs> | null
    /**
     * The data needed to create a BloqueoHorarios.
     */
    data?: XOR<BloqueoHorariosCreateInput, BloqueoHorariosUncheckedCreateInput>
  }


  /**
   * BloqueoHorarios createMany
   */
  export type BloqueoHorariosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BloqueoHorarios.
     */
    data: BloqueoHorariosCreateManyInput | BloqueoHorariosCreateManyInput[]
  }


  /**
   * BloqueoHorarios update
   */
  export type BloqueoHorariosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BloqueoHorarios
     */
    select?: BloqueoHorariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BloqueoHorariosInclude<ExtArgs> | null
    /**
     * The data needed to update a BloqueoHorarios.
     */
    data: XOR<BloqueoHorariosUpdateInput, BloqueoHorariosUncheckedUpdateInput>
    /**
     * Choose, which BloqueoHorarios to update.
     */
    where: BloqueoHorariosWhereUniqueInput
  }


  /**
   * BloqueoHorarios updateMany
   */
  export type BloqueoHorariosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BloqueoHorarios.
     */
    data: XOR<BloqueoHorariosUpdateManyMutationInput, BloqueoHorariosUncheckedUpdateManyInput>
    /**
     * Filter which BloqueoHorarios to update
     */
    where?: BloqueoHorariosWhereInput
  }


  /**
   * BloqueoHorarios upsert
   */
  export type BloqueoHorariosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BloqueoHorarios
     */
    select?: BloqueoHorariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BloqueoHorariosInclude<ExtArgs> | null
    /**
     * The filter to search for the BloqueoHorarios to update in case it exists.
     */
    where: BloqueoHorariosWhereUniqueInput
    /**
     * In case the BloqueoHorarios found by the `where` argument doesn't exist, create a new BloqueoHorarios with this data.
     */
    create: XOR<BloqueoHorariosCreateInput, BloqueoHorariosUncheckedCreateInput>
    /**
     * In case the BloqueoHorarios was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BloqueoHorariosUpdateInput, BloqueoHorariosUncheckedUpdateInput>
  }


  /**
   * BloqueoHorarios delete
   */
  export type BloqueoHorariosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BloqueoHorarios
     */
    select?: BloqueoHorariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BloqueoHorariosInclude<ExtArgs> | null
    /**
     * Filter which BloqueoHorarios to delete.
     */
    where: BloqueoHorariosWhereUniqueInput
  }


  /**
   * BloqueoHorarios deleteMany
   */
  export type BloqueoHorariosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BloqueoHorarios to delete
     */
    where?: BloqueoHorariosWhereInput
  }


  /**
   * BloqueoHorarios.Usuarios
   */
  export type BloqueoHorarios$UsuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuariosInclude<ExtArgs> | null
    where?: UsuariosWhereInput
  }


  /**
   * BloqueoHorarios without action
   */
  export type BloqueoHorariosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BloqueoHorarios
     */
    select?: BloqueoHorariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BloqueoHorariosInclude<ExtArgs> | null
  }



  /**
   * Model Citas
   */

  export type AggregateCitas = {
    _count: CitasCountAggregateOutputType | null
    _avg: CitasAvgAggregateOutputType | null
    _sum: CitasSumAggregateOutputType | null
    _min: CitasMinAggregateOutputType | null
    _max: CitasMaxAggregateOutputType | null
  }

  export type CitasAvgAggregateOutputType = {
    citaID: number | null
    clienteID: number | null
    estilistaID: number | null
    estadoID: number | null
  }

  export type CitasSumAggregateOutputType = {
    citaID: number | null
    clienteID: number | null
    estilistaID: number | null
    estadoID: number | null
  }

  export type CitasMinAggregateOutputType = {
    citaID: number | null
    clienteID: number | null
    estilistaID: number | null
    comentarios: string | null
    estadoID: number | null
  }

  export type CitasMaxAggregateOutputType = {
    citaID: number | null
    clienteID: number | null
    estilistaID: number | null
    comentarios: string | null
    estadoID: number | null
  }

  export type CitasCountAggregateOutputType = {
    citaID: number
    clienteID: number
    estilistaID: number
    comentarios: number
    estadoID: number
    _all: number
  }


  export type CitasAvgAggregateInputType = {
    citaID?: true
    clienteID?: true
    estilistaID?: true
    estadoID?: true
  }

  export type CitasSumAggregateInputType = {
    citaID?: true
    clienteID?: true
    estilistaID?: true
    estadoID?: true
  }

  export type CitasMinAggregateInputType = {
    citaID?: true
    clienteID?: true
    estilistaID?: true
    comentarios?: true
    estadoID?: true
  }

  export type CitasMaxAggregateInputType = {
    citaID?: true
    clienteID?: true
    estilistaID?: true
    comentarios?: true
    estadoID?: true
  }

  export type CitasCountAggregateInputType = {
    citaID?: true
    clienteID?: true
    estilistaID?: true
    comentarios?: true
    estadoID?: true
    _all?: true
  }

  export type CitasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Citas to aggregate.
     */
    where?: CitasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Citas to fetch.
     */
    orderBy?: CitasOrderByWithRelationInput | CitasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CitasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Citas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Citas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Citas
    **/
    _count?: true | CitasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CitasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CitasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CitasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CitasMaxAggregateInputType
  }

  export type GetCitasAggregateType<T extends CitasAggregateArgs> = {
        [P in keyof T & keyof AggregateCitas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCitas[P]>
      : GetScalarType<T[P], AggregateCitas[P]>
  }




  export type CitasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CitasWhereInput
    orderBy?: CitasOrderByWithAggregationInput | CitasOrderByWithAggregationInput[]
    by: CitasScalarFieldEnum[] | CitasScalarFieldEnum
    having?: CitasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CitasCountAggregateInputType | true
    _avg?: CitasAvgAggregateInputType
    _sum?: CitasSumAggregateInputType
    _min?: CitasMinAggregateInputType
    _max?: CitasMaxAggregateInputType
  }

  export type CitasGroupByOutputType = {
    citaID: number
    clienteID: number | null
    estilistaID: number | null
    comentarios: string | null
    estadoID: number | null
    _count: CitasCountAggregateOutputType | null
    _avg: CitasAvgAggregateOutputType | null
    _sum: CitasSumAggregateOutputType | null
    _min: CitasMinAggregateOutputType | null
    _max: CitasMaxAggregateOutputType | null
  }

  type GetCitasGroupByPayload<T extends CitasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CitasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CitasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CitasGroupByOutputType[P]>
            : GetScalarType<T[P], CitasGroupByOutputType[P]>
        }
      >
    >


  export type CitasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    citaID?: boolean
    clienteID?: boolean
    estilistaID?: boolean
    comentarios?: boolean
    estadoID?: boolean
    ActividadCliente?: boolean | Citas$ActividadClienteArgs<ExtArgs>
    Usuarios_Citas_clienteIDToUsuarios?: boolean | Citas$Usuarios_Citas_clienteIDToUsuariosArgs<ExtArgs>
    EstadoCita?: boolean | Citas$EstadoCitaArgs<ExtArgs>
    Usuarios_Citas_estilistaIDToUsuarios?: boolean | Citas$Usuarios_Citas_estilistaIDToUsuariosArgs<ExtArgs>
    DetallesCita?: boolean | Citas$DetallesCitaArgs<ExtArgs>
    HistorialCitas?: boolean | Citas$HistorialCitasArgs<ExtArgs>
    HorariosReservados?: boolean | Citas$HorariosReservadosArgs<ExtArgs>
    _count?: boolean | CitasCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["citas"]>

  export type CitasSelectScalar = {
    citaID?: boolean
    clienteID?: boolean
    estilistaID?: boolean
    comentarios?: boolean
    estadoID?: boolean
  }

  export type CitasInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ActividadCliente?: boolean | Citas$ActividadClienteArgs<ExtArgs>
    Usuarios_Citas_clienteIDToUsuarios?: boolean | Citas$Usuarios_Citas_clienteIDToUsuariosArgs<ExtArgs>
    EstadoCita?: boolean | Citas$EstadoCitaArgs<ExtArgs>
    Usuarios_Citas_estilistaIDToUsuarios?: boolean | Citas$Usuarios_Citas_estilistaIDToUsuariosArgs<ExtArgs>
    DetallesCita?: boolean | Citas$DetallesCitaArgs<ExtArgs>
    HistorialCitas?: boolean | Citas$HistorialCitasArgs<ExtArgs>
    HorariosReservados?: boolean | Citas$HorariosReservadosArgs<ExtArgs>
    _count?: boolean | CitasCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CitasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Citas"
    objects: {
      ActividadCliente: Prisma.$ActividadClientePayload<ExtArgs>[]
      Usuarios_Citas_clienteIDToUsuarios: Prisma.$UsuariosPayload<ExtArgs> | null
      EstadoCita: Prisma.$EstadoCitaPayload<ExtArgs> | null
      Usuarios_Citas_estilistaIDToUsuarios: Prisma.$UsuariosPayload<ExtArgs> | null
      DetallesCita: Prisma.$DetallesCitaPayload<ExtArgs>[]
      HistorialCitas: Prisma.$HistorialCitasPayload<ExtArgs>[]
      HorariosReservados: Prisma.$HorariosReservadosPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      citaID: number
      clienteID: number | null
      estilistaID: number | null
      comentarios: string | null
      estadoID: number | null
    }, ExtArgs["result"]["citas"]>
    composites: {}
  }


  type CitasGetPayload<S extends boolean | null | undefined | CitasDefaultArgs> = $Result.GetResult<Prisma.$CitasPayload, S>

  type CitasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CitasFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CitasCountAggregateInputType | true
    }

  export interface CitasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Citas'], meta: { name: 'Citas' } }
    /**
     * Find zero or one Citas that matches the filter.
     * @param {CitasFindUniqueArgs} args - Arguments to find a Citas
     * @example
     * // Get one Citas
     * const citas = await prisma.citas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CitasFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CitasFindUniqueArgs<ExtArgs>>
    ): Prisma__CitasClient<$Result.GetResult<Prisma.$CitasPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Citas that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CitasFindUniqueOrThrowArgs} args - Arguments to find a Citas
     * @example
     * // Get one Citas
     * const citas = await prisma.citas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CitasFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CitasFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CitasClient<$Result.GetResult<Prisma.$CitasPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Citas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CitasFindFirstArgs} args - Arguments to find a Citas
     * @example
     * // Get one Citas
     * const citas = await prisma.citas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CitasFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CitasFindFirstArgs<ExtArgs>>
    ): Prisma__CitasClient<$Result.GetResult<Prisma.$CitasPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Citas that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CitasFindFirstOrThrowArgs} args - Arguments to find a Citas
     * @example
     * // Get one Citas
     * const citas = await prisma.citas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CitasFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CitasFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CitasClient<$Result.GetResult<Prisma.$CitasPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Citas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CitasFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Citas
     * const citas = await prisma.citas.findMany()
     * 
     * // Get first 10 Citas
     * const citas = await prisma.citas.findMany({ take: 10 })
     * 
     * // Only select the `citaID`
     * const citasWithCitaIDOnly = await prisma.citas.findMany({ select: { citaID: true } })
     * 
    **/
    findMany<T extends CitasFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CitasFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CitasPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Citas.
     * @param {CitasCreateArgs} args - Arguments to create a Citas.
     * @example
     * // Create one Citas
     * const Citas = await prisma.citas.create({
     *   data: {
     *     // ... data to create a Citas
     *   }
     * })
     * 
    **/
    create<T extends CitasCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CitasCreateArgs<ExtArgs>>
    ): Prisma__CitasClient<$Result.GetResult<Prisma.$CitasPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Citas.
     *     @param {CitasCreateManyArgs} args - Arguments to create many Citas.
     *     @example
     *     // Create many Citas
     *     const citas = await prisma.citas.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CitasCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CitasCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Citas.
     * @param {CitasDeleteArgs} args - Arguments to delete one Citas.
     * @example
     * // Delete one Citas
     * const Citas = await prisma.citas.delete({
     *   where: {
     *     // ... filter to delete one Citas
     *   }
     * })
     * 
    **/
    delete<T extends CitasDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CitasDeleteArgs<ExtArgs>>
    ): Prisma__CitasClient<$Result.GetResult<Prisma.$CitasPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Citas.
     * @param {CitasUpdateArgs} args - Arguments to update one Citas.
     * @example
     * // Update one Citas
     * const citas = await prisma.citas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CitasUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CitasUpdateArgs<ExtArgs>>
    ): Prisma__CitasClient<$Result.GetResult<Prisma.$CitasPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Citas.
     * @param {CitasDeleteManyArgs} args - Arguments to filter Citas to delete.
     * @example
     * // Delete a few Citas
     * const { count } = await prisma.citas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CitasDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CitasDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Citas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CitasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Citas
     * const citas = await prisma.citas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CitasUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CitasUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Citas.
     * @param {CitasUpsertArgs} args - Arguments to update or create a Citas.
     * @example
     * // Update or create a Citas
     * const citas = await prisma.citas.upsert({
     *   create: {
     *     // ... data to create a Citas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Citas we want to update
     *   }
     * })
    **/
    upsert<T extends CitasUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CitasUpsertArgs<ExtArgs>>
    ): Prisma__CitasClient<$Result.GetResult<Prisma.$CitasPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Citas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CitasCountArgs} args - Arguments to filter Citas to count.
     * @example
     * // Count the number of Citas
     * const count = await prisma.citas.count({
     *   where: {
     *     // ... the filter for the Citas we want to count
     *   }
     * })
    **/
    count<T extends CitasCountArgs>(
      args?: Subset<T, CitasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CitasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Citas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CitasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CitasAggregateArgs>(args: Subset<T, CitasAggregateArgs>): Prisma.PrismaPromise<GetCitasAggregateType<T>>

    /**
     * Group by Citas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CitasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CitasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CitasGroupByArgs['orderBy'] }
        : { orderBy?: CitasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CitasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCitasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Citas model
   */
  readonly fields: CitasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Citas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CitasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    ActividadCliente<T extends Citas$ActividadClienteArgs<ExtArgs> = {}>(args?: Subset<T, Citas$ActividadClienteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActividadClientePayload<ExtArgs>, T, 'findMany'> | Null>;

    Usuarios_Citas_clienteIDToUsuarios<T extends Citas$Usuarios_Citas_clienteIDToUsuariosArgs<ExtArgs> = {}>(args?: Subset<T, Citas$Usuarios_Citas_clienteIDToUsuariosArgs<ExtArgs>>): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    EstadoCita<T extends Citas$EstadoCitaArgs<ExtArgs> = {}>(args?: Subset<T, Citas$EstadoCitaArgs<ExtArgs>>): Prisma__EstadoCitaClient<$Result.GetResult<Prisma.$EstadoCitaPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    Usuarios_Citas_estilistaIDToUsuarios<T extends Citas$Usuarios_Citas_estilistaIDToUsuariosArgs<ExtArgs> = {}>(args?: Subset<T, Citas$Usuarios_Citas_estilistaIDToUsuariosArgs<ExtArgs>>): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    DetallesCita<T extends Citas$DetallesCitaArgs<ExtArgs> = {}>(args?: Subset<T, Citas$DetallesCitaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DetallesCitaPayload<ExtArgs>, T, 'findMany'> | Null>;

    HistorialCitas<T extends Citas$HistorialCitasArgs<ExtArgs> = {}>(args?: Subset<T, Citas$HistorialCitasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HistorialCitasPayload<ExtArgs>, T, 'findMany'> | Null>;

    HorariosReservados<T extends Citas$HorariosReservadosArgs<ExtArgs> = {}>(args?: Subset<T, Citas$HorariosReservadosArgs<ExtArgs>>): Prisma__HorariosReservadosClient<$Result.GetResult<Prisma.$HorariosReservadosPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Citas model
   */ 
  interface CitasFieldRefs {
    readonly citaID: FieldRef<"Citas", 'Int'>
    readonly clienteID: FieldRef<"Citas", 'Int'>
    readonly estilistaID: FieldRef<"Citas", 'Int'>
    readonly comentarios: FieldRef<"Citas", 'String'>
    readonly estadoID: FieldRef<"Citas", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Citas findUnique
   */
  export type CitasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Citas
     */
    select?: CitasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CitasInclude<ExtArgs> | null
    /**
     * Filter, which Citas to fetch.
     */
    where: CitasWhereUniqueInput
  }


  /**
   * Citas findUniqueOrThrow
   */
  export type CitasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Citas
     */
    select?: CitasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CitasInclude<ExtArgs> | null
    /**
     * Filter, which Citas to fetch.
     */
    where: CitasWhereUniqueInput
  }


  /**
   * Citas findFirst
   */
  export type CitasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Citas
     */
    select?: CitasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CitasInclude<ExtArgs> | null
    /**
     * Filter, which Citas to fetch.
     */
    where?: CitasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Citas to fetch.
     */
    orderBy?: CitasOrderByWithRelationInput | CitasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Citas.
     */
    cursor?: CitasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Citas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Citas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Citas.
     */
    distinct?: CitasScalarFieldEnum | CitasScalarFieldEnum[]
  }


  /**
   * Citas findFirstOrThrow
   */
  export type CitasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Citas
     */
    select?: CitasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CitasInclude<ExtArgs> | null
    /**
     * Filter, which Citas to fetch.
     */
    where?: CitasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Citas to fetch.
     */
    orderBy?: CitasOrderByWithRelationInput | CitasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Citas.
     */
    cursor?: CitasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Citas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Citas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Citas.
     */
    distinct?: CitasScalarFieldEnum | CitasScalarFieldEnum[]
  }


  /**
   * Citas findMany
   */
  export type CitasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Citas
     */
    select?: CitasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CitasInclude<ExtArgs> | null
    /**
     * Filter, which Citas to fetch.
     */
    where?: CitasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Citas to fetch.
     */
    orderBy?: CitasOrderByWithRelationInput | CitasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Citas.
     */
    cursor?: CitasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Citas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Citas.
     */
    skip?: number
    distinct?: CitasScalarFieldEnum | CitasScalarFieldEnum[]
  }


  /**
   * Citas create
   */
  export type CitasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Citas
     */
    select?: CitasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CitasInclude<ExtArgs> | null
    /**
     * The data needed to create a Citas.
     */
    data?: XOR<CitasCreateInput, CitasUncheckedCreateInput>
  }


  /**
   * Citas createMany
   */
  export type CitasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Citas.
     */
    data: CitasCreateManyInput | CitasCreateManyInput[]
  }


  /**
   * Citas update
   */
  export type CitasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Citas
     */
    select?: CitasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CitasInclude<ExtArgs> | null
    /**
     * The data needed to update a Citas.
     */
    data: XOR<CitasUpdateInput, CitasUncheckedUpdateInput>
    /**
     * Choose, which Citas to update.
     */
    where: CitasWhereUniqueInput
  }


  /**
   * Citas updateMany
   */
  export type CitasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Citas.
     */
    data: XOR<CitasUpdateManyMutationInput, CitasUncheckedUpdateManyInput>
    /**
     * Filter which Citas to update
     */
    where?: CitasWhereInput
  }


  /**
   * Citas upsert
   */
  export type CitasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Citas
     */
    select?: CitasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CitasInclude<ExtArgs> | null
    /**
     * The filter to search for the Citas to update in case it exists.
     */
    where: CitasWhereUniqueInput
    /**
     * In case the Citas found by the `where` argument doesn't exist, create a new Citas with this data.
     */
    create: XOR<CitasCreateInput, CitasUncheckedCreateInput>
    /**
     * In case the Citas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CitasUpdateInput, CitasUncheckedUpdateInput>
  }


  /**
   * Citas delete
   */
  export type CitasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Citas
     */
    select?: CitasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CitasInclude<ExtArgs> | null
    /**
     * Filter which Citas to delete.
     */
    where: CitasWhereUniqueInput
  }


  /**
   * Citas deleteMany
   */
  export type CitasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Citas to delete
     */
    where?: CitasWhereInput
  }


  /**
   * Citas.ActividadCliente
   */
  export type Citas$ActividadClienteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActividadCliente
     */
    select?: ActividadClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActividadClienteInclude<ExtArgs> | null
    where?: ActividadClienteWhereInput
    orderBy?: ActividadClienteOrderByWithRelationInput | ActividadClienteOrderByWithRelationInput[]
    cursor?: ActividadClienteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActividadClienteScalarFieldEnum | ActividadClienteScalarFieldEnum[]
  }


  /**
   * Citas.Usuarios_Citas_clienteIDToUsuarios
   */
  export type Citas$Usuarios_Citas_clienteIDToUsuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuariosInclude<ExtArgs> | null
    where?: UsuariosWhereInput
  }


  /**
   * Citas.EstadoCita
   */
  export type Citas$EstadoCitaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstadoCita
     */
    select?: EstadoCitaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EstadoCitaInclude<ExtArgs> | null
    where?: EstadoCitaWhereInput
  }


  /**
   * Citas.Usuarios_Citas_estilistaIDToUsuarios
   */
  export type Citas$Usuarios_Citas_estilistaIDToUsuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuariosInclude<ExtArgs> | null
    where?: UsuariosWhereInput
  }


  /**
   * Citas.DetallesCita
   */
  export type Citas$DetallesCitaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetallesCita
     */
    select?: DetallesCitaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DetallesCitaInclude<ExtArgs> | null
    where?: DetallesCitaWhereInput
    orderBy?: DetallesCitaOrderByWithRelationInput | DetallesCitaOrderByWithRelationInput[]
    cursor?: DetallesCitaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DetallesCitaScalarFieldEnum | DetallesCitaScalarFieldEnum[]
  }


  /**
   * Citas.HistorialCitas
   */
  export type Citas$HistorialCitasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorialCitas
     */
    select?: HistorialCitasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistorialCitasInclude<ExtArgs> | null
    where?: HistorialCitasWhereInput
    orderBy?: HistorialCitasOrderByWithRelationInput | HistorialCitasOrderByWithRelationInput[]
    cursor?: HistorialCitasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HistorialCitasScalarFieldEnum | HistorialCitasScalarFieldEnum[]
  }


  /**
   * Citas.HorariosReservados
   */
  export type Citas$HorariosReservadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HorariosReservados
     */
    select?: HorariosReservadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HorariosReservadosInclude<ExtArgs> | null
    where?: HorariosReservadosWhereInput
  }


  /**
   * Citas without action
   */
  export type CitasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Citas
     */
    select?: CitasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CitasInclude<ExtArgs> | null
  }



  /**
   * Model DetallesCita
   */

  export type AggregateDetallesCita = {
    _count: DetallesCitaCountAggregateOutputType | null
    _avg: DetallesCitaAvgAggregateOutputType | null
    _sum: DetallesCitaSumAggregateOutputType | null
    _min: DetallesCitaMinAggregateOutputType | null
    _max: DetallesCitaMaxAggregateOutputType | null
  }

  export type DetallesCitaAvgAggregateOutputType = {
    detalleID: number | null
    citaID: number | null
    servicioID: number | null
  }

  export type DetallesCitaSumAggregateOutputType = {
    detalleID: number | null
    citaID: number | null
    servicioID: number | null
  }

  export type DetallesCitaMinAggregateOutputType = {
    detalleID: number | null
    citaID: number | null
    servicioID: number | null
  }

  export type DetallesCitaMaxAggregateOutputType = {
    detalleID: number | null
    citaID: number | null
    servicioID: number | null
  }

  export type DetallesCitaCountAggregateOutputType = {
    detalleID: number
    citaID: number
    servicioID: number
    _all: number
  }


  export type DetallesCitaAvgAggregateInputType = {
    detalleID?: true
    citaID?: true
    servicioID?: true
  }

  export type DetallesCitaSumAggregateInputType = {
    detalleID?: true
    citaID?: true
    servicioID?: true
  }

  export type DetallesCitaMinAggregateInputType = {
    detalleID?: true
    citaID?: true
    servicioID?: true
  }

  export type DetallesCitaMaxAggregateInputType = {
    detalleID?: true
    citaID?: true
    servicioID?: true
  }

  export type DetallesCitaCountAggregateInputType = {
    detalleID?: true
    citaID?: true
    servicioID?: true
    _all?: true
  }

  export type DetallesCitaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DetallesCita to aggregate.
     */
    where?: DetallesCitaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetallesCitas to fetch.
     */
    orderBy?: DetallesCitaOrderByWithRelationInput | DetallesCitaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DetallesCitaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetallesCitas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetallesCitas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DetallesCitas
    **/
    _count?: true | DetallesCitaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DetallesCitaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DetallesCitaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DetallesCitaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DetallesCitaMaxAggregateInputType
  }

  export type GetDetallesCitaAggregateType<T extends DetallesCitaAggregateArgs> = {
        [P in keyof T & keyof AggregateDetallesCita]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDetallesCita[P]>
      : GetScalarType<T[P], AggregateDetallesCita[P]>
  }




  export type DetallesCitaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DetallesCitaWhereInput
    orderBy?: DetallesCitaOrderByWithAggregationInput | DetallesCitaOrderByWithAggregationInput[]
    by: DetallesCitaScalarFieldEnum[] | DetallesCitaScalarFieldEnum
    having?: DetallesCitaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DetallesCitaCountAggregateInputType | true
    _avg?: DetallesCitaAvgAggregateInputType
    _sum?: DetallesCitaSumAggregateInputType
    _min?: DetallesCitaMinAggregateInputType
    _max?: DetallesCitaMaxAggregateInputType
  }

  export type DetallesCitaGroupByOutputType = {
    detalleID: number
    citaID: number | null
    servicioID: number | null
    _count: DetallesCitaCountAggregateOutputType | null
    _avg: DetallesCitaAvgAggregateOutputType | null
    _sum: DetallesCitaSumAggregateOutputType | null
    _min: DetallesCitaMinAggregateOutputType | null
    _max: DetallesCitaMaxAggregateOutputType | null
  }

  type GetDetallesCitaGroupByPayload<T extends DetallesCitaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DetallesCitaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DetallesCitaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DetallesCitaGroupByOutputType[P]>
            : GetScalarType<T[P], DetallesCitaGroupByOutputType[P]>
        }
      >
    >


  export type DetallesCitaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    detalleID?: boolean
    citaID?: boolean
    servicioID?: boolean
    Citas?: boolean | DetallesCita$CitasArgs<ExtArgs>
    Servicios?: boolean | DetallesCita$ServiciosArgs<ExtArgs>
  }, ExtArgs["result"]["detallesCita"]>

  export type DetallesCitaSelectScalar = {
    detalleID?: boolean
    citaID?: boolean
    servicioID?: boolean
  }

  export type DetallesCitaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Citas?: boolean | DetallesCita$CitasArgs<ExtArgs>
    Servicios?: boolean | DetallesCita$ServiciosArgs<ExtArgs>
  }


  export type $DetallesCitaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DetallesCita"
    objects: {
      Citas: Prisma.$CitasPayload<ExtArgs> | null
      Servicios: Prisma.$ServiciosPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      detalleID: number
      citaID: number | null
      servicioID: number | null
    }, ExtArgs["result"]["detallesCita"]>
    composites: {}
  }


  type DetallesCitaGetPayload<S extends boolean | null | undefined | DetallesCitaDefaultArgs> = $Result.GetResult<Prisma.$DetallesCitaPayload, S>

  type DetallesCitaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DetallesCitaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DetallesCitaCountAggregateInputType | true
    }

  export interface DetallesCitaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DetallesCita'], meta: { name: 'DetallesCita' } }
    /**
     * Find zero or one DetallesCita that matches the filter.
     * @param {DetallesCitaFindUniqueArgs} args - Arguments to find a DetallesCita
     * @example
     * // Get one DetallesCita
     * const detallesCita = await prisma.detallesCita.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DetallesCitaFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DetallesCitaFindUniqueArgs<ExtArgs>>
    ): Prisma__DetallesCitaClient<$Result.GetResult<Prisma.$DetallesCitaPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one DetallesCita that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DetallesCitaFindUniqueOrThrowArgs} args - Arguments to find a DetallesCita
     * @example
     * // Get one DetallesCita
     * const detallesCita = await prisma.detallesCita.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DetallesCitaFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DetallesCitaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DetallesCitaClient<$Result.GetResult<Prisma.$DetallesCitaPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first DetallesCita that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetallesCitaFindFirstArgs} args - Arguments to find a DetallesCita
     * @example
     * // Get one DetallesCita
     * const detallesCita = await prisma.detallesCita.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DetallesCitaFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DetallesCitaFindFirstArgs<ExtArgs>>
    ): Prisma__DetallesCitaClient<$Result.GetResult<Prisma.$DetallesCitaPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first DetallesCita that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetallesCitaFindFirstOrThrowArgs} args - Arguments to find a DetallesCita
     * @example
     * // Get one DetallesCita
     * const detallesCita = await prisma.detallesCita.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DetallesCitaFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DetallesCitaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DetallesCitaClient<$Result.GetResult<Prisma.$DetallesCitaPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more DetallesCitas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetallesCitaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DetallesCitas
     * const detallesCitas = await prisma.detallesCita.findMany()
     * 
     * // Get first 10 DetallesCitas
     * const detallesCitas = await prisma.detallesCita.findMany({ take: 10 })
     * 
     * // Only select the `detalleID`
     * const detallesCitaWithDetalleIDOnly = await prisma.detallesCita.findMany({ select: { detalleID: true } })
     * 
    **/
    findMany<T extends DetallesCitaFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DetallesCitaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DetallesCitaPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a DetallesCita.
     * @param {DetallesCitaCreateArgs} args - Arguments to create a DetallesCita.
     * @example
     * // Create one DetallesCita
     * const DetallesCita = await prisma.detallesCita.create({
     *   data: {
     *     // ... data to create a DetallesCita
     *   }
     * })
     * 
    **/
    create<T extends DetallesCitaCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DetallesCitaCreateArgs<ExtArgs>>
    ): Prisma__DetallesCitaClient<$Result.GetResult<Prisma.$DetallesCitaPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many DetallesCitas.
     *     @param {DetallesCitaCreateManyArgs} args - Arguments to create many DetallesCitas.
     *     @example
     *     // Create many DetallesCitas
     *     const detallesCita = await prisma.detallesCita.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DetallesCitaCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DetallesCitaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DetallesCita.
     * @param {DetallesCitaDeleteArgs} args - Arguments to delete one DetallesCita.
     * @example
     * // Delete one DetallesCita
     * const DetallesCita = await prisma.detallesCita.delete({
     *   where: {
     *     // ... filter to delete one DetallesCita
     *   }
     * })
     * 
    **/
    delete<T extends DetallesCitaDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DetallesCitaDeleteArgs<ExtArgs>>
    ): Prisma__DetallesCitaClient<$Result.GetResult<Prisma.$DetallesCitaPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one DetallesCita.
     * @param {DetallesCitaUpdateArgs} args - Arguments to update one DetallesCita.
     * @example
     * // Update one DetallesCita
     * const detallesCita = await prisma.detallesCita.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DetallesCitaUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DetallesCitaUpdateArgs<ExtArgs>>
    ): Prisma__DetallesCitaClient<$Result.GetResult<Prisma.$DetallesCitaPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more DetallesCitas.
     * @param {DetallesCitaDeleteManyArgs} args - Arguments to filter DetallesCitas to delete.
     * @example
     * // Delete a few DetallesCitas
     * const { count } = await prisma.detallesCita.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DetallesCitaDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DetallesCitaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DetallesCitas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetallesCitaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DetallesCitas
     * const detallesCita = await prisma.detallesCita.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DetallesCitaUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DetallesCitaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DetallesCita.
     * @param {DetallesCitaUpsertArgs} args - Arguments to update or create a DetallesCita.
     * @example
     * // Update or create a DetallesCita
     * const detallesCita = await prisma.detallesCita.upsert({
     *   create: {
     *     // ... data to create a DetallesCita
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DetallesCita we want to update
     *   }
     * })
    **/
    upsert<T extends DetallesCitaUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DetallesCitaUpsertArgs<ExtArgs>>
    ): Prisma__DetallesCitaClient<$Result.GetResult<Prisma.$DetallesCitaPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of DetallesCitas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetallesCitaCountArgs} args - Arguments to filter DetallesCitas to count.
     * @example
     * // Count the number of DetallesCitas
     * const count = await prisma.detallesCita.count({
     *   where: {
     *     // ... the filter for the DetallesCitas we want to count
     *   }
     * })
    **/
    count<T extends DetallesCitaCountArgs>(
      args?: Subset<T, DetallesCitaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DetallesCitaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DetallesCita.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetallesCitaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DetallesCitaAggregateArgs>(args: Subset<T, DetallesCitaAggregateArgs>): Prisma.PrismaPromise<GetDetallesCitaAggregateType<T>>

    /**
     * Group by DetallesCita.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetallesCitaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DetallesCitaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DetallesCitaGroupByArgs['orderBy'] }
        : { orderBy?: DetallesCitaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DetallesCitaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDetallesCitaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DetallesCita model
   */
  readonly fields: DetallesCitaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DetallesCita.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DetallesCitaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Citas<T extends DetallesCita$CitasArgs<ExtArgs> = {}>(args?: Subset<T, DetallesCita$CitasArgs<ExtArgs>>): Prisma__CitasClient<$Result.GetResult<Prisma.$CitasPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    Servicios<T extends DetallesCita$ServiciosArgs<ExtArgs> = {}>(args?: Subset<T, DetallesCita$ServiciosArgs<ExtArgs>>): Prisma__ServiciosClient<$Result.GetResult<Prisma.$ServiciosPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the DetallesCita model
   */ 
  interface DetallesCitaFieldRefs {
    readonly detalleID: FieldRef<"DetallesCita", 'Int'>
    readonly citaID: FieldRef<"DetallesCita", 'Int'>
    readonly servicioID: FieldRef<"DetallesCita", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * DetallesCita findUnique
   */
  export type DetallesCitaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetallesCita
     */
    select?: DetallesCitaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DetallesCitaInclude<ExtArgs> | null
    /**
     * Filter, which DetallesCita to fetch.
     */
    where: DetallesCitaWhereUniqueInput
  }


  /**
   * DetallesCita findUniqueOrThrow
   */
  export type DetallesCitaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetallesCita
     */
    select?: DetallesCitaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DetallesCitaInclude<ExtArgs> | null
    /**
     * Filter, which DetallesCita to fetch.
     */
    where: DetallesCitaWhereUniqueInput
  }


  /**
   * DetallesCita findFirst
   */
  export type DetallesCitaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetallesCita
     */
    select?: DetallesCitaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DetallesCitaInclude<ExtArgs> | null
    /**
     * Filter, which DetallesCita to fetch.
     */
    where?: DetallesCitaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetallesCitas to fetch.
     */
    orderBy?: DetallesCitaOrderByWithRelationInput | DetallesCitaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DetallesCitas.
     */
    cursor?: DetallesCitaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetallesCitas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetallesCitas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DetallesCitas.
     */
    distinct?: DetallesCitaScalarFieldEnum | DetallesCitaScalarFieldEnum[]
  }


  /**
   * DetallesCita findFirstOrThrow
   */
  export type DetallesCitaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetallesCita
     */
    select?: DetallesCitaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DetallesCitaInclude<ExtArgs> | null
    /**
     * Filter, which DetallesCita to fetch.
     */
    where?: DetallesCitaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetallesCitas to fetch.
     */
    orderBy?: DetallesCitaOrderByWithRelationInput | DetallesCitaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DetallesCitas.
     */
    cursor?: DetallesCitaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetallesCitas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetallesCitas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DetallesCitas.
     */
    distinct?: DetallesCitaScalarFieldEnum | DetallesCitaScalarFieldEnum[]
  }


  /**
   * DetallesCita findMany
   */
  export type DetallesCitaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetallesCita
     */
    select?: DetallesCitaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DetallesCitaInclude<ExtArgs> | null
    /**
     * Filter, which DetallesCitas to fetch.
     */
    where?: DetallesCitaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetallesCitas to fetch.
     */
    orderBy?: DetallesCitaOrderByWithRelationInput | DetallesCitaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DetallesCitas.
     */
    cursor?: DetallesCitaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetallesCitas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetallesCitas.
     */
    skip?: number
    distinct?: DetallesCitaScalarFieldEnum | DetallesCitaScalarFieldEnum[]
  }


  /**
   * DetallesCita create
   */
  export type DetallesCitaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetallesCita
     */
    select?: DetallesCitaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DetallesCitaInclude<ExtArgs> | null
    /**
     * The data needed to create a DetallesCita.
     */
    data?: XOR<DetallesCitaCreateInput, DetallesCitaUncheckedCreateInput>
  }


  /**
   * DetallesCita createMany
   */
  export type DetallesCitaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DetallesCitas.
     */
    data: DetallesCitaCreateManyInput | DetallesCitaCreateManyInput[]
  }


  /**
   * DetallesCita update
   */
  export type DetallesCitaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetallesCita
     */
    select?: DetallesCitaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DetallesCitaInclude<ExtArgs> | null
    /**
     * The data needed to update a DetallesCita.
     */
    data: XOR<DetallesCitaUpdateInput, DetallesCitaUncheckedUpdateInput>
    /**
     * Choose, which DetallesCita to update.
     */
    where: DetallesCitaWhereUniqueInput
  }


  /**
   * DetallesCita updateMany
   */
  export type DetallesCitaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DetallesCitas.
     */
    data: XOR<DetallesCitaUpdateManyMutationInput, DetallesCitaUncheckedUpdateManyInput>
    /**
     * Filter which DetallesCitas to update
     */
    where?: DetallesCitaWhereInput
  }


  /**
   * DetallesCita upsert
   */
  export type DetallesCitaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetallesCita
     */
    select?: DetallesCitaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DetallesCitaInclude<ExtArgs> | null
    /**
     * The filter to search for the DetallesCita to update in case it exists.
     */
    where: DetallesCitaWhereUniqueInput
    /**
     * In case the DetallesCita found by the `where` argument doesn't exist, create a new DetallesCita with this data.
     */
    create: XOR<DetallesCitaCreateInput, DetallesCitaUncheckedCreateInput>
    /**
     * In case the DetallesCita was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DetallesCitaUpdateInput, DetallesCitaUncheckedUpdateInput>
  }


  /**
   * DetallesCita delete
   */
  export type DetallesCitaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetallesCita
     */
    select?: DetallesCitaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DetallesCitaInclude<ExtArgs> | null
    /**
     * Filter which DetallesCita to delete.
     */
    where: DetallesCitaWhereUniqueInput
  }


  /**
   * DetallesCita deleteMany
   */
  export type DetallesCitaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DetallesCitas to delete
     */
    where?: DetallesCitaWhereInput
  }


  /**
   * DetallesCita.Citas
   */
  export type DetallesCita$CitasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Citas
     */
    select?: CitasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CitasInclude<ExtArgs> | null
    where?: CitasWhereInput
  }


  /**
   * DetallesCita.Servicios
   */
  export type DetallesCita$ServiciosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicios
     */
    select?: ServiciosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiciosInclude<ExtArgs> | null
    where?: ServiciosWhereInput
  }


  /**
   * DetallesCita without action
   */
  export type DetallesCitaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetallesCita
     */
    select?: DetallesCitaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DetallesCitaInclude<ExtArgs> | null
  }



  /**
   * Model EstadoCita
   */

  export type AggregateEstadoCita = {
    _count: EstadoCitaCountAggregateOutputType | null
    _avg: EstadoCitaAvgAggregateOutputType | null
    _sum: EstadoCitaSumAggregateOutputType | null
    _min: EstadoCitaMinAggregateOutputType | null
    _max: EstadoCitaMaxAggregateOutputType | null
  }

  export type EstadoCitaAvgAggregateOutputType = {
    estadoID: number | null
  }

  export type EstadoCitaSumAggregateOutputType = {
    estadoID: number | null
  }

  export type EstadoCitaMinAggregateOutputType = {
    estadoID: number | null
    nombre: string | null
  }

  export type EstadoCitaMaxAggregateOutputType = {
    estadoID: number | null
    nombre: string | null
  }

  export type EstadoCitaCountAggregateOutputType = {
    estadoID: number
    nombre: number
    _all: number
  }


  export type EstadoCitaAvgAggregateInputType = {
    estadoID?: true
  }

  export type EstadoCitaSumAggregateInputType = {
    estadoID?: true
  }

  export type EstadoCitaMinAggregateInputType = {
    estadoID?: true
    nombre?: true
  }

  export type EstadoCitaMaxAggregateInputType = {
    estadoID?: true
    nombre?: true
  }

  export type EstadoCitaCountAggregateInputType = {
    estadoID?: true
    nombre?: true
    _all?: true
  }

  export type EstadoCitaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EstadoCita to aggregate.
     */
    where?: EstadoCitaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EstadoCitas to fetch.
     */
    orderBy?: EstadoCitaOrderByWithRelationInput | EstadoCitaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EstadoCitaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EstadoCitas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EstadoCitas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EstadoCitas
    **/
    _count?: true | EstadoCitaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EstadoCitaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EstadoCitaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EstadoCitaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EstadoCitaMaxAggregateInputType
  }

  export type GetEstadoCitaAggregateType<T extends EstadoCitaAggregateArgs> = {
        [P in keyof T & keyof AggregateEstadoCita]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEstadoCita[P]>
      : GetScalarType<T[P], AggregateEstadoCita[P]>
  }




  export type EstadoCitaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EstadoCitaWhereInput
    orderBy?: EstadoCitaOrderByWithAggregationInput | EstadoCitaOrderByWithAggregationInput[]
    by: EstadoCitaScalarFieldEnum[] | EstadoCitaScalarFieldEnum
    having?: EstadoCitaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EstadoCitaCountAggregateInputType | true
    _avg?: EstadoCitaAvgAggregateInputType
    _sum?: EstadoCitaSumAggregateInputType
    _min?: EstadoCitaMinAggregateInputType
    _max?: EstadoCitaMaxAggregateInputType
  }

  export type EstadoCitaGroupByOutputType = {
    estadoID: number
    nombre: string | null
    _count: EstadoCitaCountAggregateOutputType | null
    _avg: EstadoCitaAvgAggregateOutputType | null
    _sum: EstadoCitaSumAggregateOutputType | null
    _min: EstadoCitaMinAggregateOutputType | null
    _max: EstadoCitaMaxAggregateOutputType | null
  }

  type GetEstadoCitaGroupByPayload<T extends EstadoCitaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EstadoCitaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EstadoCitaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EstadoCitaGroupByOutputType[P]>
            : GetScalarType<T[P], EstadoCitaGroupByOutputType[P]>
        }
      >
    >


  export type EstadoCitaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    estadoID?: boolean
    nombre?: boolean
    Citas?: boolean | EstadoCita$CitasArgs<ExtArgs>
    _count?: boolean | EstadoCitaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["estadoCita"]>

  export type EstadoCitaSelectScalar = {
    estadoID?: boolean
    nombre?: boolean
  }

  export type EstadoCitaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Citas?: boolean | EstadoCita$CitasArgs<ExtArgs>
    _count?: boolean | EstadoCitaCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $EstadoCitaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EstadoCita"
    objects: {
      Citas: Prisma.$CitasPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      estadoID: number
      nombre: string | null
    }, ExtArgs["result"]["estadoCita"]>
    composites: {}
  }


  type EstadoCitaGetPayload<S extends boolean | null | undefined | EstadoCitaDefaultArgs> = $Result.GetResult<Prisma.$EstadoCitaPayload, S>

  type EstadoCitaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EstadoCitaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EstadoCitaCountAggregateInputType | true
    }

  export interface EstadoCitaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EstadoCita'], meta: { name: 'EstadoCita' } }
    /**
     * Find zero or one EstadoCita that matches the filter.
     * @param {EstadoCitaFindUniqueArgs} args - Arguments to find a EstadoCita
     * @example
     * // Get one EstadoCita
     * const estadoCita = await prisma.estadoCita.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EstadoCitaFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EstadoCitaFindUniqueArgs<ExtArgs>>
    ): Prisma__EstadoCitaClient<$Result.GetResult<Prisma.$EstadoCitaPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one EstadoCita that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EstadoCitaFindUniqueOrThrowArgs} args - Arguments to find a EstadoCita
     * @example
     * // Get one EstadoCita
     * const estadoCita = await prisma.estadoCita.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EstadoCitaFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EstadoCitaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EstadoCitaClient<$Result.GetResult<Prisma.$EstadoCitaPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first EstadoCita that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoCitaFindFirstArgs} args - Arguments to find a EstadoCita
     * @example
     * // Get one EstadoCita
     * const estadoCita = await prisma.estadoCita.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EstadoCitaFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EstadoCitaFindFirstArgs<ExtArgs>>
    ): Prisma__EstadoCitaClient<$Result.GetResult<Prisma.$EstadoCitaPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first EstadoCita that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoCitaFindFirstOrThrowArgs} args - Arguments to find a EstadoCita
     * @example
     * // Get one EstadoCita
     * const estadoCita = await prisma.estadoCita.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EstadoCitaFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EstadoCitaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EstadoCitaClient<$Result.GetResult<Prisma.$EstadoCitaPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more EstadoCitas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoCitaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EstadoCitas
     * const estadoCitas = await prisma.estadoCita.findMany()
     * 
     * // Get first 10 EstadoCitas
     * const estadoCitas = await prisma.estadoCita.findMany({ take: 10 })
     * 
     * // Only select the `estadoID`
     * const estadoCitaWithEstadoIDOnly = await prisma.estadoCita.findMany({ select: { estadoID: true } })
     * 
    **/
    findMany<T extends EstadoCitaFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EstadoCitaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EstadoCitaPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a EstadoCita.
     * @param {EstadoCitaCreateArgs} args - Arguments to create a EstadoCita.
     * @example
     * // Create one EstadoCita
     * const EstadoCita = await prisma.estadoCita.create({
     *   data: {
     *     // ... data to create a EstadoCita
     *   }
     * })
     * 
    **/
    create<T extends EstadoCitaCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EstadoCitaCreateArgs<ExtArgs>>
    ): Prisma__EstadoCitaClient<$Result.GetResult<Prisma.$EstadoCitaPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many EstadoCitas.
     *     @param {EstadoCitaCreateManyArgs} args - Arguments to create many EstadoCitas.
     *     @example
     *     // Create many EstadoCitas
     *     const estadoCita = await prisma.estadoCita.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EstadoCitaCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EstadoCitaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EstadoCita.
     * @param {EstadoCitaDeleteArgs} args - Arguments to delete one EstadoCita.
     * @example
     * // Delete one EstadoCita
     * const EstadoCita = await prisma.estadoCita.delete({
     *   where: {
     *     // ... filter to delete one EstadoCita
     *   }
     * })
     * 
    **/
    delete<T extends EstadoCitaDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EstadoCitaDeleteArgs<ExtArgs>>
    ): Prisma__EstadoCitaClient<$Result.GetResult<Prisma.$EstadoCitaPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one EstadoCita.
     * @param {EstadoCitaUpdateArgs} args - Arguments to update one EstadoCita.
     * @example
     * // Update one EstadoCita
     * const estadoCita = await prisma.estadoCita.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EstadoCitaUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EstadoCitaUpdateArgs<ExtArgs>>
    ): Prisma__EstadoCitaClient<$Result.GetResult<Prisma.$EstadoCitaPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more EstadoCitas.
     * @param {EstadoCitaDeleteManyArgs} args - Arguments to filter EstadoCitas to delete.
     * @example
     * // Delete a few EstadoCitas
     * const { count } = await prisma.estadoCita.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EstadoCitaDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EstadoCitaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EstadoCitas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoCitaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EstadoCitas
     * const estadoCita = await prisma.estadoCita.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EstadoCitaUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EstadoCitaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EstadoCita.
     * @param {EstadoCitaUpsertArgs} args - Arguments to update or create a EstadoCita.
     * @example
     * // Update or create a EstadoCita
     * const estadoCita = await prisma.estadoCita.upsert({
     *   create: {
     *     // ... data to create a EstadoCita
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EstadoCita we want to update
     *   }
     * })
    **/
    upsert<T extends EstadoCitaUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EstadoCitaUpsertArgs<ExtArgs>>
    ): Prisma__EstadoCitaClient<$Result.GetResult<Prisma.$EstadoCitaPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of EstadoCitas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoCitaCountArgs} args - Arguments to filter EstadoCitas to count.
     * @example
     * // Count the number of EstadoCitas
     * const count = await prisma.estadoCita.count({
     *   where: {
     *     // ... the filter for the EstadoCitas we want to count
     *   }
     * })
    **/
    count<T extends EstadoCitaCountArgs>(
      args?: Subset<T, EstadoCitaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EstadoCitaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EstadoCita.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoCitaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EstadoCitaAggregateArgs>(args: Subset<T, EstadoCitaAggregateArgs>): Prisma.PrismaPromise<GetEstadoCitaAggregateType<T>>

    /**
     * Group by EstadoCita.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoCitaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EstadoCitaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EstadoCitaGroupByArgs['orderBy'] }
        : { orderBy?: EstadoCitaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EstadoCitaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEstadoCitaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EstadoCita model
   */
  readonly fields: EstadoCitaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EstadoCita.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EstadoCitaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Citas<T extends EstadoCita$CitasArgs<ExtArgs> = {}>(args?: Subset<T, EstadoCita$CitasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CitasPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the EstadoCita model
   */ 
  interface EstadoCitaFieldRefs {
    readonly estadoID: FieldRef<"EstadoCita", 'Int'>
    readonly nombre: FieldRef<"EstadoCita", 'String'>
  }
    

  // Custom InputTypes

  /**
   * EstadoCita findUnique
   */
  export type EstadoCitaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstadoCita
     */
    select?: EstadoCitaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EstadoCitaInclude<ExtArgs> | null
    /**
     * Filter, which EstadoCita to fetch.
     */
    where: EstadoCitaWhereUniqueInput
  }


  /**
   * EstadoCita findUniqueOrThrow
   */
  export type EstadoCitaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstadoCita
     */
    select?: EstadoCitaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EstadoCitaInclude<ExtArgs> | null
    /**
     * Filter, which EstadoCita to fetch.
     */
    where: EstadoCitaWhereUniqueInput
  }


  /**
   * EstadoCita findFirst
   */
  export type EstadoCitaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstadoCita
     */
    select?: EstadoCitaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EstadoCitaInclude<ExtArgs> | null
    /**
     * Filter, which EstadoCita to fetch.
     */
    where?: EstadoCitaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EstadoCitas to fetch.
     */
    orderBy?: EstadoCitaOrderByWithRelationInput | EstadoCitaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EstadoCitas.
     */
    cursor?: EstadoCitaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EstadoCitas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EstadoCitas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EstadoCitas.
     */
    distinct?: EstadoCitaScalarFieldEnum | EstadoCitaScalarFieldEnum[]
  }


  /**
   * EstadoCita findFirstOrThrow
   */
  export type EstadoCitaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstadoCita
     */
    select?: EstadoCitaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EstadoCitaInclude<ExtArgs> | null
    /**
     * Filter, which EstadoCita to fetch.
     */
    where?: EstadoCitaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EstadoCitas to fetch.
     */
    orderBy?: EstadoCitaOrderByWithRelationInput | EstadoCitaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EstadoCitas.
     */
    cursor?: EstadoCitaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EstadoCitas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EstadoCitas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EstadoCitas.
     */
    distinct?: EstadoCitaScalarFieldEnum | EstadoCitaScalarFieldEnum[]
  }


  /**
   * EstadoCita findMany
   */
  export type EstadoCitaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstadoCita
     */
    select?: EstadoCitaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EstadoCitaInclude<ExtArgs> | null
    /**
     * Filter, which EstadoCitas to fetch.
     */
    where?: EstadoCitaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EstadoCitas to fetch.
     */
    orderBy?: EstadoCitaOrderByWithRelationInput | EstadoCitaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EstadoCitas.
     */
    cursor?: EstadoCitaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EstadoCitas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EstadoCitas.
     */
    skip?: number
    distinct?: EstadoCitaScalarFieldEnum | EstadoCitaScalarFieldEnum[]
  }


  /**
   * EstadoCita create
   */
  export type EstadoCitaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstadoCita
     */
    select?: EstadoCitaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EstadoCitaInclude<ExtArgs> | null
    /**
     * The data needed to create a EstadoCita.
     */
    data?: XOR<EstadoCitaCreateInput, EstadoCitaUncheckedCreateInput>
  }


  /**
   * EstadoCita createMany
   */
  export type EstadoCitaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EstadoCitas.
     */
    data: EstadoCitaCreateManyInput | EstadoCitaCreateManyInput[]
  }


  /**
   * EstadoCita update
   */
  export type EstadoCitaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstadoCita
     */
    select?: EstadoCitaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EstadoCitaInclude<ExtArgs> | null
    /**
     * The data needed to update a EstadoCita.
     */
    data: XOR<EstadoCitaUpdateInput, EstadoCitaUncheckedUpdateInput>
    /**
     * Choose, which EstadoCita to update.
     */
    where: EstadoCitaWhereUniqueInput
  }


  /**
   * EstadoCita updateMany
   */
  export type EstadoCitaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EstadoCitas.
     */
    data: XOR<EstadoCitaUpdateManyMutationInput, EstadoCitaUncheckedUpdateManyInput>
    /**
     * Filter which EstadoCitas to update
     */
    where?: EstadoCitaWhereInput
  }


  /**
   * EstadoCita upsert
   */
  export type EstadoCitaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstadoCita
     */
    select?: EstadoCitaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EstadoCitaInclude<ExtArgs> | null
    /**
     * The filter to search for the EstadoCita to update in case it exists.
     */
    where: EstadoCitaWhereUniqueInput
    /**
     * In case the EstadoCita found by the `where` argument doesn't exist, create a new EstadoCita with this data.
     */
    create: XOR<EstadoCitaCreateInput, EstadoCitaUncheckedCreateInput>
    /**
     * In case the EstadoCita was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EstadoCitaUpdateInput, EstadoCitaUncheckedUpdateInput>
  }


  /**
   * EstadoCita delete
   */
  export type EstadoCitaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstadoCita
     */
    select?: EstadoCitaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EstadoCitaInclude<ExtArgs> | null
    /**
     * Filter which EstadoCita to delete.
     */
    where: EstadoCitaWhereUniqueInput
  }


  /**
   * EstadoCita deleteMany
   */
  export type EstadoCitaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EstadoCitas to delete
     */
    where?: EstadoCitaWhereInput
  }


  /**
   * EstadoCita.Citas
   */
  export type EstadoCita$CitasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Citas
     */
    select?: CitasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CitasInclude<ExtArgs> | null
    where?: CitasWhereInput
    orderBy?: CitasOrderByWithRelationInput | CitasOrderByWithRelationInput[]
    cursor?: CitasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CitasScalarFieldEnum | CitasScalarFieldEnum[]
  }


  /**
   * EstadoCita without action
   */
  export type EstadoCitaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstadoCita
     */
    select?: EstadoCitaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EstadoCitaInclude<ExtArgs> | null
  }



  /**
   * Model HistorialCitas
   */

  export type AggregateHistorialCitas = {
    _count: HistorialCitasCountAggregateOutputType | null
    _avg: HistorialCitasAvgAggregateOutputType | null
    _sum: HistorialCitasSumAggregateOutputType | null
    _min: HistorialCitasMinAggregateOutputType | null
    _max: HistorialCitasMaxAggregateOutputType | null
  }

  export type HistorialCitasAvgAggregateOutputType = {
    historialCitasID: number | null
    clienteID: number | null
    citaID: number | null
  }

  export type HistorialCitasSumAggregateOutputType = {
    historialCitasID: number | null
    clienteID: number | null
    citaID: number | null
  }

  export type HistorialCitasMinAggregateOutputType = {
    historialCitasID: number | null
    clienteID: number | null
    citaID: number | null
  }

  export type HistorialCitasMaxAggregateOutputType = {
    historialCitasID: number | null
    clienteID: number | null
    citaID: number | null
  }

  export type HistorialCitasCountAggregateOutputType = {
    historialCitasID: number
    clienteID: number
    citaID: number
    _all: number
  }


  export type HistorialCitasAvgAggregateInputType = {
    historialCitasID?: true
    clienteID?: true
    citaID?: true
  }

  export type HistorialCitasSumAggregateInputType = {
    historialCitasID?: true
    clienteID?: true
    citaID?: true
  }

  export type HistorialCitasMinAggregateInputType = {
    historialCitasID?: true
    clienteID?: true
    citaID?: true
  }

  export type HistorialCitasMaxAggregateInputType = {
    historialCitasID?: true
    clienteID?: true
    citaID?: true
  }

  export type HistorialCitasCountAggregateInputType = {
    historialCitasID?: true
    clienteID?: true
    citaID?: true
    _all?: true
  }

  export type HistorialCitasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HistorialCitas to aggregate.
     */
    where?: HistorialCitasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HistorialCitas to fetch.
     */
    orderBy?: HistorialCitasOrderByWithRelationInput | HistorialCitasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HistorialCitasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HistorialCitas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HistorialCitas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HistorialCitas
    **/
    _count?: true | HistorialCitasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HistorialCitasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HistorialCitasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HistorialCitasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HistorialCitasMaxAggregateInputType
  }

  export type GetHistorialCitasAggregateType<T extends HistorialCitasAggregateArgs> = {
        [P in keyof T & keyof AggregateHistorialCitas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHistorialCitas[P]>
      : GetScalarType<T[P], AggregateHistorialCitas[P]>
  }




  export type HistorialCitasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HistorialCitasWhereInput
    orderBy?: HistorialCitasOrderByWithAggregationInput | HistorialCitasOrderByWithAggregationInput[]
    by: HistorialCitasScalarFieldEnum[] | HistorialCitasScalarFieldEnum
    having?: HistorialCitasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HistorialCitasCountAggregateInputType | true
    _avg?: HistorialCitasAvgAggregateInputType
    _sum?: HistorialCitasSumAggregateInputType
    _min?: HistorialCitasMinAggregateInputType
    _max?: HistorialCitasMaxAggregateInputType
  }

  export type HistorialCitasGroupByOutputType = {
    historialCitasID: number
    clienteID: number | null
    citaID: number | null
    _count: HistorialCitasCountAggregateOutputType | null
    _avg: HistorialCitasAvgAggregateOutputType | null
    _sum: HistorialCitasSumAggregateOutputType | null
    _min: HistorialCitasMinAggregateOutputType | null
    _max: HistorialCitasMaxAggregateOutputType | null
  }

  type GetHistorialCitasGroupByPayload<T extends HistorialCitasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HistorialCitasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HistorialCitasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HistorialCitasGroupByOutputType[P]>
            : GetScalarType<T[P], HistorialCitasGroupByOutputType[P]>
        }
      >
    >


  export type HistorialCitasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    historialCitasID?: boolean
    clienteID?: boolean
    citaID?: boolean
    Citas?: boolean | HistorialCitas$CitasArgs<ExtArgs>
    Usuarios?: boolean | HistorialCitas$UsuariosArgs<ExtArgs>
  }, ExtArgs["result"]["historialCitas"]>

  export type HistorialCitasSelectScalar = {
    historialCitasID?: boolean
    clienteID?: boolean
    citaID?: boolean
  }

  export type HistorialCitasInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Citas?: boolean | HistorialCitas$CitasArgs<ExtArgs>
    Usuarios?: boolean | HistorialCitas$UsuariosArgs<ExtArgs>
  }


  export type $HistorialCitasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HistorialCitas"
    objects: {
      Citas: Prisma.$CitasPayload<ExtArgs> | null
      Usuarios: Prisma.$UsuariosPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      historialCitasID: number
      clienteID: number | null
      citaID: number | null
    }, ExtArgs["result"]["historialCitas"]>
    composites: {}
  }


  type HistorialCitasGetPayload<S extends boolean | null | undefined | HistorialCitasDefaultArgs> = $Result.GetResult<Prisma.$HistorialCitasPayload, S>

  type HistorialCitasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HistorialCitasFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HistorialCitasCountAggregateInputType | true
    }

  export interface HistorialCitasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HistorialCitas'], meta: { name: 'HistorialCitas' } }
    /**
     * Find zero or one HistorialCitas that matches the filter.
     * @param {HistorialCitasFindUniqueArgs} args - Arguments to find a HistorialCitas
     * @example
     * // Get one HistorialCitas
     * const historialCitas = await prisma.historialCitas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends HistorialCitasFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, HistorialCitasFindUniqueArgs<ExtArgs>>
    ): Prisma__HistorialCitasClient<$Result.GetResult<Prisma.$HistorialCitasPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one HistorialCitas that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {HistorialCitasFindUniqueOrThrowArgs} args - Arguments to find a HistorialCitas
     * @example
     * // Get one HistorialCitas
     * const historialCitas = await prisma.historialCitas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends HistorialCitasFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, HistorialCitasFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__HistorialCitasClient<$Result.GetResult<Prisma.$HistorialCitasPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first HistorialCitas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistorialCitasFindFirstArgs} args - Arguments to find a HistorialCitas
     * @example
     * // Get one HistorialCitas
     * const historialCitas = await prisma.historialCitas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends HistorialCitasFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, HistorialCitasFindFirstArgs<ExtArgs>>
    ): Prisma__HistorialCitasClient<$Result.GetResult<Prisma.$HistorialCitasPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first HistorialCitas that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistorialCitasFindFirstOrThrowArgs} args - Arguments to find a HistorialCitas
     * @example
     * // Get one HistorialCitas
     * const historialCitas = await prisma.historialCitas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends HistorialCitasFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, HistorialCitasFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__HistorialCitasClient<$Result.GetResult<Prisma.$HistorialCitasPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more HistorialCitas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistorialCitasFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HistorialCitas
     * const historialCitas = await prisma.historialCitas.findMany()
     * 
     * // Get first 10 HistorialCitas
     * const historialCitas = await prisma.historialCitas.findMany({ take: 10 })
     * 
     * // Only select the `historialCitasID`
     * const historialCitasWithHistorialCitasIDOnly = await prisma.historialCitas.findMany({ select: { historialCitasID: true } })
     * 
    **/
    findMany<T extends HistorialCitasFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, HistorialCitasFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HistorialCitasPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a HistorialCitas.
     * @param {HistorialCitasCreateArgs} args - Arguments to create a HistorialCitas.
     * @example
     * // Create one HistorialCitas
     * const HistorialCitas = await prisma.historialCitas.create({
     *   data: {
     *     // ... data to create a HistorialCitas
     *   }
     * })
     * 
    **/
    create<T extends HistorialCitasCreateArgs<ExtArgs>>(
      args: SelectSubset<T, HistorialCitasCreateArgs<ExtArgs>>
    ): Prisma__HistorialCitasClient<$Result.GetResult<Prisma.$HistorialCitasPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many HistorialCitas.
     *     @param {HistorialCitasCreateManyArgs} args - Arguments to create many HistorialCitas.
     *     @example
     *     // Create many HistorialCitas
     *     const historialCitas = await prisma.historialCitas.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends HistorialCitasCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, HistorialCitasCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a HistorialCitas.
     * @param {HistorialCitasDeleteArgs} args - Arguments to delete one HistorialCitas.
     * @example
     * // Delete one HistorialCitas
     * const HistorialCitas = await prisma.historialCitas.delete({
     *   where: {
     *     // ... filter to delete one HistorialCitas
     *   }
     * })
     * 
    **/
    delete<T extends HistorialCitasDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, HistorialCitasDeleteArgs<ExtArgs>>
    ): Prisma__HistorialCitasClient<$Result.GetResult<Prisma.$HistorialCitasPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one HistorialCitas.
     * @param {HistorialCitasUpdateArgs} args - Arguments to update one HistorialCitas.
     * @example
     * // Update one HistorialCitas
     * const historialCitas = await prisma.historialCitas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends HistorialCitasUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, HistorialCitasUpdateArgs<ExtArgs>>
    ): Prisma__HistorialCitasClient<$Result.GetResult<Prisma.$HistorialCitasPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more HistorialCitas.
     * @param {HistorialCitasDeleteManyArgs} args - Arguments to filter HistorialCitas to delete.
     * @example
     * // Delete a few HistorialCitas
     * const { count } = await prisma.historialCitas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends HistorialCitasDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, HistorialCitasDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HistorialCitas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistorialCitasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HistorialCitas
     * const historialCitas = await prisma.historialCitas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends HistorialCitasUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, HistorialCitasUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HistorialCitas.
     * @param {HistorialCitasUpsertArgs} args - Arguments to update or create a HistorialCitas.
     * @example
     * // Update or create a HistorialCitas
     * const historialCitas = await prisma.historialCitas.upsert({
     *   create: {
     *     // ... data to create a HistorialCitas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HistorialCitas we want to update
     *   }
     * })
    **/
    upsert<T extends HistorialCitasUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, HistorialCitasUpsertArgs<ExtArgs>>
    ): Prisma__HistorialCitasClient<$Result.GetResult<Prisma.$HistorialCitasPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of HistorialCitas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistorialCitasCountArgs} args - Arguments to filter HistorialCitas to count.
     * @example
     * // Count the number of HistorialCitas
     * const count = await prisma.historialCitas.count({
     *   where: {
     *     // ... the filter for the HistorialCitas we want to count
     *   }
     * })
    **/
    count<T extends HistorialCitasCountArgs>(
      args?: Subset<T, HistorialCitasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HistorialCitasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HistorialCitas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistorialCitasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HistorialCitasAggregateArgs>(args: Subset<T, HistorialCitasAggregateArgs>): Prisma.PrismaPromise<GetHistorialCitasAggregateType<T>>

    /**
     * Group by HistorialCitas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistorialCitasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HistorialCitasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HistorialCitasGroupByArgs['orderBy'] }
        : { orderBy?: HistorialCitasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HistorialCitasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHistorialCitasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HistorialCitas model
   */
  readonly fields: HistorialCitasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HistorialCitas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HistorialCitasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Citas<T extends HistorialCitas$CitasArgs<ExtArgs> = {}>(args?: Subset<T, HistorialCitas$CitasArgs<ExtArgs>>): Prisma__CitasClient<$Result.GetResult<Prisma.$CitasPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    Usuarios<T extends HistorialCitas$UsuariosArgs<ExtArgs> = {}>(args?: Subset<T, HistorialCitas$UsuariosArgs<ExtArgs>>): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the HistorialCitas model
   */ 
  interface HistorialCitasFieldRefs {
    readonly historialCitasID: FieldRef<"HistorialCitas", 'Int'>
    readonly clienteID: FieldRef<"HistorialCitas", 'Int'>
    readonly citaID: FieldRef<"HistorialCitas", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * HistorialCitas findUnique
   */
  export type HistorialCitasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorialCitas
     */
    select?: HistorialCitasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistorialCitasInclude<ExtArgs> | null
    /**
     * Filter, which HistorialCitas to fetch.
     */
    where: HistorialCitasWhereUniqueInput
  }


  /**
   * HistorialCitas findUniqueOrThrow
   */
  export type HistorialCitasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorialCitas
     */
    select?: HistorialCitasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistorialCitasInclude<ExtArgs> | null
    /**
     * Filter, which HistorialCitas to fetch.
     */
    where: HistorialCitasWhereUniqueInput
  }


  /**
   * HistorialCitas findFirst
   */
  export type HistorialCitasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorialCitas
     */
    select?: HistorialCitasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistorialCitasInclude<ExtArgs> | null
    /**
     * Filter, which HistorialCitas to fetch.
     */
    where?: HistorialCitasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HistorialCitas to fetch.
     */
    orderBy?: HistorialCitasOrderByWithRelationInput | HistorialCitasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HistorialCitas.
     */
    cursor?: HistorialCitasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HistorialCitas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HistorialCitas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HistorialCitas.
     */
    distinct?: HistorialCitasScalarFieldEnum | HistorialCitasScalarFieldEnum[]
  }


  /**
   * HistorialCitas findFirstOrThrow
   */
  export type HistorialCitasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorialCitas
     */
    select?: HistorialCitasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistorialCitasInclude<ExtArgs> | null
    /**
     * Filter, which HistorialCitas to fetch.
     */
    where?: HistorialCitasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HistorialCitas to fetch.
     */
    orderBy?: HistorialCitasOrderByWithRelationInput | HistorialCitasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HistorialCitas.
     */
    cursor?: HistorialCitasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HistorialCitas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HistorialCitas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HistorialCitas.
     */
    distinct?: HistorialCitasScalarFieldEnum | HistorialCitasScalarFieldEnum[]
  }


  /**
   * HistorialCitas findMany
   */
  export type HistorialCitasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorialCitas
     */
    select?: HistorialCitasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistorialCitasInclude<ExtArgs> | null
    /**
     * Filter, which HistorialCitas to fetch.
     */
    where?: HistorialCitasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HistorialCitas to fetch.
     */
    orderBy?: HistorialCitasOrderByWithRelationInput | HistorialCitasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HistorialCitas.
     */
    cursor?: HistorialCitasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HistorialCitas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HistorialCitas.
     */
    skip?: number
    distinct?: HistorialCitasScalarFieldEnum | HistorialCitasScalarFieldEnum[]
  }


  /**
   * HistorialCitas create
   */
  export type HistorialCitasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorialCitas
     */
    select?: HistorialCitasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistorialCitasInclude<ExtArgs> | null
    /**
     * The data needed to create a HistorialCitas.
     */
    data?: XOR<HistorialCitasCreateInput, HistorialCitasUncheckedCreateInput>
  }


  /**
   * HistorialCitas createMany
   */
  export type HistorialCitasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HistorialCitas.
     */
    data: HistorialCitasCreateManyInput | HistorialCitasCreateManyInput[]
  }


  /**
   * HistorialCitas update
   */
  export type HistorialCitasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorialCitas
     */
    select?: HistorialCitasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistorialCitasInclude<ExtArgs> | null
    /**
     * The data needed to update a HistorialCitas.
     */
    data: XOR<HistorialCitasUpdateInput, HistorialCitasUncheckedUpdateInput>
    /**
     * Choose, which HistorialCitas to update.
     */
    where: HistorialCitasWhereUniqueInput
  }


  /**
   * HistorialCitas updateMany
   */
  export type HistorialCitasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HistorialCitas.
     */
    data: XOR<HistorialCitasUpdateManyMutationInput, HistorialCitasUncheckedUpdateManyInput>
    /**
     * Filter which HistorialCitas to update
     */
    where?: HistorialCitasWhereInput
  }


  /**
   * HistorialCitas upsert
   */
  export type HistorialCitasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorialCitas
     */
    select?: HistorialCitasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistorialCitasInclude<ExtArgs> | null
    /**
     * The filter to search for the HistorialCitas to update in case it exists.
     */
    where: HistorialCitasWhereUniqueInput
    /**
     * In case the HistorialCitas found by the `where` argument doesn't exist, create a new HistorialCitas with this data.
     */
    create: XOR<HistorialCitasCreateInput, HistorialCitasUncheckedCreateInput>
    /**
     * In case the HistorialCitas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HistorialCitasUpdateInput, HistorialCitasUncheckedUpdateInput>
  }


  /**
   * HistorialCitas delete
   */
  export type HistorialCitasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorialCitas
     */
    select?: HistorialCitasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistorialCitasInclude<ExtArgs> | null
    /**
     * Filter which HistorialCitas to delete.
     */
    where: HistorialCitasWhereUniqueInput
  }


  /**
   * HistorialCitas deleteMany
   */
  export type HistorialCitasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HistorialCitas to delete
     */
    where?: HistorialCitasWhereInput
  }


  /**
   * HistorialCitas.Citas
   */
  export type HistorialCitas$CitasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Citas
     */
    select?: CitasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CitasInclude<ExtArgs> | null
    where?: CitasWhereInput
  }


  /**
   * HistorialCitas.Usuarios
   */
  export type HistorialCitas$UsuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuariosInclude<ExtArgs> | null
    where?: UsuariosWhereInput
  }


  /**
   * HistorialCitas without action
   */
  export type HistorialCitasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorialCitas
     */
    select?: HistorialCitasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistorialCitasInclude<ExtArgs> | null
  }



  /**
   * Model HistorialRecompensas
   */

  export type AggregateHistorialRecompensas = {
    _count: HistorialRecompensasCountAggregateOutputType | null
    _avg: HistorialRecompensasAvgAggregateOutputType | null
    _sum: HistorialRecompensasSumAggregateOutputType | null
    _min: HistorialRecompensasMinAggregateOutputType | null
    _max: HistorialRecompensasMaxAggregateOutputType | null
  }

  export type HistorialRecompensasAvgAggregateOutputType = {
    historialID: number | null
    clienteID: number | null
    servicioID: number | null
    puntosCanjeados: number | null
  }

  export type HistorialRecompensasSumAggregateOutputType = {
    historialID: number | null
    clienteID: number | null
    servicioID: number | null
    puntosCanjeados: number | null
  }

  export type HistorialRecompensasMinAggregateOutputType = {
    historialID: number | null
    clienteID: number | null
    servicioID: number | null
    puntosCanjeados: number | null
    fecha: Date | null
  }

  export type HistorialRecompensasMaxAggregateOutputType = {
    historialID: number | null
    clienteID: number | null
    servicioID: number | null
    puntosCanjeados: number | null
    fecha: Date | null
  }

  export type HistorialRecompensasCountAggregateOutputType = {
    historialID: number
    clienteID: number
    servicioID: number
    puntosCanjeados: number
    fecha: number
    _all: number
  }


  export type HistorialRecompensasAvgAggregateInputType = {
    historialID?: true
    clienteID?: true
    servicioID?: true
    puntosCanjeados?: true
  }

  export type HistorialRecompensasSumAggregateInputType = {
    historialID?: true
    clienteID?: true
    servicioID?: true
    puntosCanjeados?: true
  }

  export type HistorialRecompensasMinAggregateInputType = {
    historialID?: true
    clienteID?: true
    servicioID?: true
    puntosCanjeados?: true
    fecha?: true
  }

  export type HistorialRecompensasMaxAggregateInputType = {
    historialID?: true
    clienteID?: true
    servicioID?: true
    puntosCanjeados?: true
    fecha?: true
  }

  export type HistorialRecompensasCountAggregateInputType = {
    historialID?: true
    clienteID?: true
    servicioID?: true
    puntosCanjeados?: true
    fecha?: true
    _all?: true
  }

  export type HistorialRecompensasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HistorialRecompensas to aggregate.
     */
    where?: HistorialRecompensasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HistorialRecompensas to fetch.
     */
    orderBy?: HistorialRecompensasOrderByWithRelationInput | HistorialRecompensasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HistorialRecompensasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HistorialRecompensas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HistorialRecompensas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HistorialRecompensas
    **/
    _count?: true | HistorialRecompensasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HistorialRecompensasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HistorialRecompensasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HistorialRecompensasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HistorialRecompensasMaxAggregateInputType
  }

  export type GetHistorialRecompensasAggregateType<T extends HistorialRecompensasAggregateArgs> = {
        [P in keyof T & keyof AggregateHistorialRecompensas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHistorialRecompensas[P]>
      : GetScalarType<T[P], AggregateHistorialRecompensas[P]>
  }




  export type HistorialRecompensasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HistorialRecompensasWhereInput
    orderBy?: HistorialRecompensasOrderByWithAggregationInput | HistorialRecompensasOrderByWithAggregationInput[]
    by: HistorialRecompensasScalarFieldEnum[] | HistorialRecompensasScalarFieldEnum
    having?: HistorialRecompensasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HistorialRecompensasCountAggregateInputType | true
    _avg?: HistorialRecompensasAvgAggregateInputType
    _sum?: HistorialRecompensasSumAggregateInputType
    _min?: HistorialRecompensasMinAggregateInputType
    _max?: HistorialRecompensasMaxAggregateInputType
  }

  export type HistorialRecompensasGroupByOutputType = {
    historialID: number
    clienteID: number | null
    servicioID: number | null
    puntosCanjeados: number | null
    fecha: Date | null
    _count: HistorialRecompensasCountAggregateOutputType | null
    _avg: HistorialRecompensasAvgAggregateOutputType | null
    _sum: HistorialRecompensasSumAggregateOutputType | null
    _min: HistorialRecompensasMinAggregateOutputType | null
    _max: HistorialRecompensasMaxAggregateOutputType | null
  }

  type GetHistorialRecompensasGroupByPayload<T extends HistorialRecompensasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HistorialRecompensasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HistorialRecompensasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HistorialRecompensasGroupByOutputType[P]>
            : GetScalarType<T[P], HistorialRecompensasGroupByOutputType[P]>
        }
      >
    >


  export type HistorialRecompensasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    historialID?: boolean
    clienteID?: boolean
    servicioID?: boolean
    puntosCanjeados?: boolean
    fecha?: boolean
    Usuarios?: boolean | HistorialRecompensas$UsuariosArgs<ExtArgs>
    Servicios?: boolean | HistorialRecompensas$ServiciosArgs<ExtArgs>
  }, ExtArgs["result"]["historialRecompensas"]>

  export type HistorialRecompensasSelectScalar = {
    historialID?: boolean
    clienteID?: boolean
    servicioID?: boolean
    puntosCanjeados?: boolean
    fecha?: boolean
  }

  export type HistorialRecompensasInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Usuarios?: boolean | HistorialRecompensas$UsuariosArgs<ExtArgs>
    Servicios?: boolean | HistorialRecompensas$ServiciosArgs<ExtArgs>
  }


  export type $HistorialRecompensasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HistorialRecompensas"
    objects: {
      Usuarios: Prisma.$UsuariosPayload<ExtArgs> | null
      Servicios: Prisma.$ServiciosPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      historialID: number
      clienteID: number | null
      servicioID: number | null
      puntosCanjeados: number | null
      fecha: Date | null
    }, ExtArgs["result"]["historialRecompensas"]>
    composites: {}
  }


  type HistorialRecompensasGetPayload<S extends boolean | null | undefined | HistorialRecompensasDefaultArgs> = $Result.GetResult<Prisma.$HistorialRecompensasPayload, S>

  type HistorialRecompensasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HistorialRecompensasFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HistorialRecompensasCountAggregateInputType | true
    }

  export interface HistorialRecompensasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HistorialRecompensas'], meta: { name: 'HistorialRecompensas' } }
    /**
     * Find zero or one HistorialRecompensas that matches the filter.
     * @param {HistorialRecompensasFindUniqueArgs} args - Arguments to find a HistorialRecompensas
     * @example
     * // Get one HistorialRecompensas
     * const historialRecompensas = await prisma.historialRecompensas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends HistorialRecompensasFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, HistorialRecompensasFindUniqueArgs<ExtArgs>>
    ): Prisma__HistorialRecompensasClient<$Result.GetResult<Prisma.$HistorialRecompensasPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one HistorialRecompensas that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {HistorialRecompensasFindUniqueOrThrowArgs} args - Arguments to find a HistorialRecompensas
     * @example
     * // Get one HistorialRecompensas
     * const historialRecompensas = await prisma.historialRecompensas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends HistorialRecompensasFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, HistorialRecompensasFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__HistorialRecompensasClient<$Result.GetResult<Prisma.$HistorialRecompensasPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first HistorialRecompensas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistorialRecompensasFindFirstArgs} args - Arguments to find a HistorialRecompensas
     * @example
     * // Get one HistorialRecompensas
     * const historialRecompensas = await prisma.historialRecompensas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends HistorialRecompensasFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, HistorialRecompensasFindFirstArgs<ExtArgs>>
    ): Prisma__HistorialRecompensasClient<$Result.GetResult<Prisma.$HistorialRecompensasPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first HistorialRecompensas that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistorialRecompensasFindFirstOrThrowArgs} args - Arguments to find a HistorialRecompensas
     * @example
     * // Get one HistorialRecompensas
     * const historialRecompensas = await prisma.historialRecompensas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends HistorialRecompensasFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, HistorialRecompensasFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__HistorialRecompensasClient<$Result.GetResult<Prisma.$HistorialRecompensasPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more HistorialRecompensas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistorialRecompensasFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HistorialRecompensas
     * const historialRecompensas = await prisma.historialRecompensas.findMany()
     * 
     * // Get first 10 HistorialRecompensas
     * const historialRecompensas = await prisma.historialRecompensas.findMany({ take: 10 })
     * 
     * // Only select the `historialID`
     * const historialRecompensasWithHistorialIDOnly = await prisma.historialRecompensas.findMany({ select: { historialID: true } })
     * 
    **/
    findMany<T extends HistorialRecompensasFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, HistorialRecompensasFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HistorialRecompensasPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a HistorialRecompensas.
     * @param {HistorialRecompensasCreateArgs} args - Arguments to create a HistorialRecompensas.
     * @example
     * // Create one HistorialRecompensas
     * const HistorialRecompensas = await prisma.historialRecompensas.create({
     *   data: {
     *     // ... data to create a HistorialRecompensas
     *   }
     * })
     * 
    **/
    create<T extends HistorialRecompensasCreateArgs<ExtArgs>>(
      args: SelectSubset<T, HistorialRecompensasCreateArgs<ExtArgs>>
    ): Prisma__HistorialRecompensasClient<$Result.GetResult<Prisma.$HistorialRecompensasPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many HistorialRecompensas.
     *     @param {HistorialRecompensasCreateManyArgs} args - Arguments to create many HistorialRecompensas.
     *     @example
     *     // Create many HistorialRecompensas
     *     const historialRecompensas = await prisma.historialRecompensas.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends HistorialRecompensasCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, HistorialRecompensasCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a HistorialRecompensas.
     * @param {HistorialRecompensasDeleteArgs} args - Arguments to delete one HistorialRecompensas.
     * @example
     * // Delete one HistorialRecompensas
     * const HistorialRecompensas = await prisma.historialRecompensas.delete({
     *   where: {
     *     // ... filter to delete one HistorialRecompensas
     *   }
     * })
     * 
    **/
    delete<T extends HistorialRecompensasDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, HistorialRecompensasDeleteArgs<ExtArgs>>
    ): Prisma__HistorialRecompensasClient<$Result.GetResult<Prisma.$HistorialRecompensasPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one HistorialRecompensas.
     * @param {HistorialRecompensasUpdateArgs} args - Arguments to update one HistorialRecompensas.
     * @example
     * // Update one HistorialRecompensas
     * const historialRecompensas = await prisma.historialRecompensas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends HistorialRecompensasUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, HistorialRecompensasUpdateArgs<ExtArgs>>
    ): Prisma__HistorialRecompensasClient<$Result.GetResult<Prisma.$HistorialRecompensasPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more HistorialRecompensas.
     * @param {HistorialRecompensasDeleteManyArgs} args - Arguments to filter HistorialRecompensas to delete.
     * @example
     * // Delete a few HistorialRecompensas
     * const { count } = await prisma.historialRecompensas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends HistorialRecompensasDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, HistorialRecompensasDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HistorialRecompensas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistorialRecompensasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HistorialRecompensas
     * const historialRecompensas = await prisma.historialRecompensas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends HistorialRecompensasUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, HistorialRecompensasUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HistorialRecompensas.
     * @param {HistorialRecompensasUpsertArgs} args - Arguments to update or create a HistorialRecompensas.
     * @example
     * // Update or create a HistorialRecompensas
     * const historialRecompensas = await prisma.historialRecompensas.upsert({
     *   create: {
     *     // ... data to create a HistorialRecompensas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HistorialRecompensas we want to update
     *   }
     * })
    **/
    upsert<T extends HistorialRecompensasUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, HistorialRecompensasUpsertArgs<ExtArgs>>
    ): Prisma__HistorialRecompensasClient<$Result.GetResult<Prisma.$HistorialRecompensasPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of HistorialRecompensas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistorialRecompensasCountArgs} args - Arguments to filter HistorialRecompensas to count.
     * @example
     * // Count the number of HistorialRecompensas
     * const count = await prisma.historialRecompensas.count({
     *   where: {
     *     // ... the filter for the HistorialRecompensas we want to count
     *   }
     * })
    **/
    count<T extends HistorialRecompensasCountArgs>(
      args?: Subset<T, HistorialRecompensasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HistorialRecompensasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HistorialRecompensas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistorialRecompensasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HistorialRecompensasAggregateArgs>(args: Subset<T, HistorialRecompensasAggregateArgs>): Prisma.PrismaPromise<GetHistorialRecompensasAggregateType<T>>

    /**
     * Group by HistorialRecompensas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistorialRecompensasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HistorialRecompensasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HistorialRecompensasGroupByArgs['orderBy'] }
        : { orderBy?: HistorialRecompensasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HistorialRecompensasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHistorialRecompensasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HistorialRecompensas model
   */
  readonly fields: HistorialRecompensasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HistorialRecompensas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HistorialRecompensasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Usuarios<T extends HistorialRecompensas$UsuariosArgs<ExtArgs> = {}>(args?: Subset<T, HistorialRecompensas$UsuariosArgs<ExtArgs>>): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    Servicios<T extends HistorialRecompensas$ServiciosArgs<ExtArgs> = {}>(args?: Subset<T, HistorialRecompensas$ServiciosArgs<ExtArgs>>): Prisma__ServiciosClient<$Result.GetResult<Prisma.$ServiciosPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the HistorialRecompensas model
   */ 
  interface HistorialRecompensasFieldRefs {
    readonly historialID: FieldRef<"HistorialRecompensas", 'Int'>
    readonly clienteID: FieldRef<"HistorialRecompensas", 'Int'>
    readonly servicioID: FieldRef<"HistorialRecompensas", 'Int'>
    readonly puntosCanjeados: FieldRef<"HistorialRecompensas", 'Int'>
    readonly fecha: FieldRef<"HistorialRecompensas", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * HistorialRecompensas findUnique
   */
  export type HistorialRecompensasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorialRecompensas
     */
    select?: HistorialRecompensasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistorialRecompensasInclude<ExtArgs> | null
    /**
     * Filter, which HistorialRecompensas to fetch.
     */
    where: HistorialRecompensasWhereUniqueInput
  }


  /**
   * HistorialRecompensas findUniqueOrThrow
   */
  export type HistorialRecompensasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorialRecompensas
     */
    select?: HistorialRecompensasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistorialRecompensasInclude<ExtArgs> | null
    /**
     * Filter, which HistorialRecompensas to fetch.
     */
    where: HistorialRecompensasWhereUniqueInput
  }


  /**
   * HistorialRecompensas findFirst
   */
  export type HistorialRecompensasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorialRecompensas
     */
    select?: HistorialRecompensasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistorialRecompensasInclude<ExtArgs> | null
    /**
     * Filter, which HistorialRecompensas to fetch.
     */
    where?: HistorialRecompensasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HistorialRecompensas to fetch.
     */
    orderBy?: HistorialRecompensasOrderByWithRelationInput | HistorialRecompensasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HistorialRecompensas.
     */
    cursor?: HistorialRecompensasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HistorialRecompensas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HistorialRecompensas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HistorialRecompensas.
     */
    distinct?: HistorialRecompensasScalarFieldEnum | HistorialRecompensasScalarFieldEnum[]
  }


  /**
   * HistorialRecompensas findFirstOrThrow
   */
  export type HistorialRecompensasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorialRecompensas
     */
    select?: HistorialRecompensasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistorialRecompensasInclude<ExtArgs> | null
    /**
     * Filter, which HistorialRecompensas to fetch.
     */
    where?: HistorialRecompensasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HistorialRecompensas to fetch.
     */
    orderBy?: HistorialRecompensasOrderByWithRelationInput | HistorialRecompensasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HistorialRecompensas.
     */
    cursor?: HistorialRecompensasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HistorialRecompensas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HistorialRecompensas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HistorialRecompensas.
     */
    distinct?: HistorialRecompensasScalarFieldEnum | HistorialRecompensasScalarFieldEnum[]
  }


  /**
   * HistorialRecompensas findMany
   */
  export type HistorialRecompensasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorialRecompensas
     */
    select?: HistorialRecompensasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistorialRecompensasInclude<ExtArgs> | null
    /**
     * Filter, which HistorialRecompensas to fetch.
     */
    where?: HistorialRecompensasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HistorialRecompensas to fetch.
     */
    orderBy?: HistorialRecompensasOrderByWithRelationInput | HistorialRecompensasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HistorialRecompensas.
     */
    cursor?: HistorialRecompensasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HistorialRecompensas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HistorialRecompensas.
     */
    skip?: number
    distinct?: HistorialRecompensasScalarFieldEnum | HistorialRecompensasScalarFieldEnum[]
  }


  /**
   * HistorialRecompensas create
   */
  export type HistorialRecompensasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorialRecompensas
     */
    select?: HistorialRecompensasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistorialRecompensasInclude<ExtArgs> | null
    /**
     * The data needed to create a HistorialRecompensas.
     */
    data?: XOR<HistorialRecompensasCreateInput, HistorialRecompensasUncheckedCreateInput>
  }


  /**
   * HistorialRecompensas createMany
   */
  export type HistorialRecompensasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HistorialRecompensas.
     */
    data: HistorialRecompensasCreateManyInput | HistorialRecompensasCreateManyInput[]
  }


  /**
   * HistorialRecompensas update
   */
  export type HistorialRecompensasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorialRecompensas
     */
    select?: HistorialRecompensasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistorialRecompensasInclude<ExtArgs> | null
    /**
     * The data needed to update a HistorialRecompensas.
     */
    data: XOR<HistorialRecompensasUpdateInput, HistorialRecompensasUncheckedUpdateInput>
    /**
     * Choose, which HistorialRecompensas to update.
     */
    where: HistorialRecompensasWhereUniqueInput
  }


  /**
   * HistorialRecompensas updateMany
   */
  export type HistorialRecompensasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HistorialRecompensas.
     */
    data: XOR<HistorialRecompensasUpdateManyMutationInput, HistorialRecompensasUncheckedUpdateManyInput>
    /**
     * Filter which HistorialRecompensas to update
     */
    where?: HistorialRecompensasWhereInput
  }


  /**
   * HistorialRecompensas upsert
   */
  export type HistorialRecompensasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorialRecompensas
     */
    select?: HistorialRecompensasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistorialRecompensasInclude<ExtArgs> | null
    /**
     * The filter to search for the HistorialRecompensas to update in case it exists.
     */
    where: HistorialRecompensasWhereUniqueInput
    /**
     * In case the HistorialRecompensas found by the `where` argument doesn't exist, create a new HistorialRecompensas with this data.
     */
    create: XOR<HistorialRecompensasCreateInput, HistorialRecompensasUncheckedCreateInput>
    /**
     * In case the HistorialRecompensas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HistorialRecompensasUpdateInput, HistorialRecompensasUncheckedUpdateInput>
  }


  /**
   * HistorialRecompensas delete
   */
  export type HistorialRecompensasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorialRecompensas
     */
    select?: HistorialRecompensasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistorialRecompensasInclude<ExtArgs> | null
    /**
     * Filter which HistorialRecompensas to delete.
     */
    where: HistorialRecompensasWhereUniqueInput
  }


  /**
   * HistorialRecompensas deleteMany
   */
  export type HistorialRecompensasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HistorialRecompensas to delete
     */
    where?: HistorialRecompensasWhereInput
  }


  /**
   * HistorialRecompensas.Usuarios
   */
  export type HistorialRecompensas$UsuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuariosInclude<ExtArgs> | null
    where?: UsuariosWhereInput
  }


  /**
   * HistorialRecompensas.Servicios
   */
  export type HistorialRecompensas$ServiciosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicios
     */
    select?: ServiciosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiciosInclude<ExtArgs> | null
    where?: ServiciosWhereInput
  }


  /**
   * HistorialRecompensas without action
   */
  export type HistorialRecompensasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorialRecompensas
     */
    select?: HistorialRecompensasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistorialRecompensasInclude<ExtArgs> | null
  }



  /**
   * Model Horarios
   */

  export type AggregateHorarios = {
    _count: HorariosCountAggregateOutputType | null
    _avg: HorariosAvgAggregateOutputType | null
    _sum: HorariosSumAggregateOutputType | null
    _min: HorariosMinAggregateOutputType | null
    _max: HorariosMaxAggregateOutputType | null
  }

  export type HorariosAvgAggregateOutputType = {
    horariosID: number | null
    estilistaID: number | null
  }

  export type HorariosSumAggregateOutputType = {
    horariosID: number | null
    estilistaID: number | null
  }

  export type HorariosMinAggregateOutputType = {
    horariosID: number | null
    estilistaID: number | null
    diaSemana: string | null
    horaInicio: Date | null
    horaFinal: Date | null
  }

  export type HorariosMaxAggregateOutputType = {
    horariosID: number | null
    estilistaID: number | null
    diaSemana: string | null
    horaInicio: Date | null
    horaFinal: Date | null
  }

  export type HorariosCountAggregateOutputType = {
    horariosID: number
    estilistaID: number
    diaSemana: number
    horaInicio: number
    horaFinal: number
    _all: number
  }


  export type HorariosAvgAggregateInputType = {
    horariosID?: true
    estilistaID?: true
  }

  export type HorariosSumAggregateInputType = {
    horariosID?: true
    estilistaID?: true
  }

  export type HorariosMinAggregateInputType = {
    horariosID?: true
    estilistaID?: true
    diaSemana?: true
    horaInicio?: true
    horaFinal?: true
  }

  export type HorariosMaxAggregateInputType = {
    horariosID?: true
    estilistaID?: true
    diaSemana?: true
    horaInicio?: true
    horaFinal?: true
  }

  export type HorariosCountAggregateInputType = {
    horariosID?: true
    estilistaID?: true
    diaSemana?: true
    horaInicio?: true
    horaFinal?: true
    _all?: true
  }

  export type HorariosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Horarios to aggregate.
     */
    where?: HorariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Horarios to fetch.
     */
    orderBy?: HorariosOrderByWithRelationInput | HorariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HorariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Horarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Horarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Horarios
    **/
    _count?: true | HorariosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HorariosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HorariosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HorariosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HorariosMaxAggregateInputType
  }

  export type GetHorariosAggregateType<T extends HorariosAggregateArgs> = {
        [P in keyof T & keyof AggregateHorarios]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHorarios[P]>
      : GetScalarType<T[P], AggregateHorarios[P]>
  }




  export type HorariosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HorariosWhereInput
    orderBy?: HorariosOrderByWithAggregationInput | HorariosOrderByWithAggregationInput[]
    by: HorariosScalarFieldEnum[] | HorariosScalarFieldEnum
    having?: HorariosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HorariosCountAggregateInputType | true
    _avg?: HorariosAvgAggregateInputType
    _sum?: HorariosSumAggregateInputType
    _min?: HorariosMinAggregateInputType
    _max?: HorariosMaxAggregateInputType
  }

  export type HorariosGroupByOutputType = {
    horariosID: number
    estilistaID: number | null
    diaSemana: string | null
    horaInicio: Date | null
    horaFinal: Date | null
    _count: HorariosCountAggregateOutputType | null
    _avg: HorariosAvgAggregateOutputType | null
    _sum: HorariosSumAggregateOutputType | null
    _min: HorariosMinAggregateOutputType | null
    _max: HorariosMaxAggregateOutputType | null
  }

  type GetHorariosGroupByPayload<T extends HorariosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HorariosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HorariosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HorariosGroupByOutputType[P]>
            : GetScalarType<T[P], HorariosGroupByOutputType[P]>
        }
      >
    >


  export type HorariosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    horariosID?: boolean
    estilistaID?: boolean
    diaSemana?: boolean
    horaInicio?: boolean
    horaFinal?: boolean
    Usuarios?: boolean | Horarios$UsuariosArgs<ExtArgs>
  }, ExtArgs["result"]["horarios"]>

  export type HorariosSelectScalar = {
    horariosID?: boolean
    estilistaID?: boolean
    diaSemana?: boolean
    horaInicio?: boolean
    horaFinal?: boolean
  }

  export type HorariosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Usuarios?: boolean | Horarios$UsuariosArgs<ExtArgs>
  }


  export type $HorariosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Horarios"
    objects: {
      Usuarios: Prisma.$UsuariosPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      horariosID: number
      estilistaID: number | null
      diaSemana: string | null
      horaInicio: Date | null
      horaFinal: Date | null
    }, ExtArgs["result"]["horarios"]>
    composites: {}
  }


  type HorariosGetPayload<S extends boolean | null | undefined | HorariosDefaultArgs> = $Result.GetResult<Prisma.$HorariosPayload, S>

  type HorariosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HorariosFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HorariosCountAggregateInputType | true
    }

  export interface HorariosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Horarios'], meta: { name: 'Horarios' } }
    /**
     * Find zero or one Horarios that matches the filter.
     * @param {HorariosFindUniqueArgs} args - Arguments to find a Horarios
     * @example
     * // Get one Horarios
     * const horarios = await prisma.horarios.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends HorariosFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, HorariosFindUniqueArgs<ExtArgs>>
    ): Prisma__HorariosClient<$Result.GetResult<Prisma.$HorariosPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Horarios that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {HorariosFindUniqueOrThrowArgs} args - Arguments to find a Horarios
     * @example
     * // Get one Horarios
     * const horarios = await prisma.horarios.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends HorariosFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, HorariosFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__HorariosClient<$Result.GetResult<Prisma.$HorariosPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Horarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HorariosFindFirstArgs} args - Arguments to find a Horarios
     * @example
     * // Get one Horarios
     * const horarios = await prisma.horarios.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends HorariosFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, HorariosFindFirstArgs<ExtArgs>>
    ): Prisma__HorariosClient<$Result.GetResult<Prisma.$HorariosPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Horarios that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HorariosFindFirstOrThrowArgs} args - Arguments to find a Horarios
     * @example
     * // Get one Horarios
     * const horarios = await prisma.horarios.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends HorariosFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, HorariosFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__HorariosClient<$Result.GetResult<Prisma.$HorariosPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Horarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HorariosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Horarios
     * const horarios = await prisma.horarios.findMany()
     * 
     * // Get first 10 Horarios
     * const horarios = await prisma.horarios.findMany({ take: 10 })
     * 
     * // Only select the `horariosID`
     * const horariosWithHorariosIDOnly = await prisma.horarios.findMany({ select: { horariosID: true } })
     * 
    **/
    findMany<T extends HorariosFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, HorariosFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HorariosPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Horarios.
     * @param {HorariosCreateArgs} args - Arguments to create a Horarios.
     * @example
     * // Create one Horarios
     * const Horarios = await prisma.horarios.create({
     *   data: {
     *     // ... data to create a Horarios
     *   }
     * })
     * 
    **/
    create<T extends HorariosCreateArgs<ExtArgs>>(
      args: SelectSubset<T, HorariosCreateArgs<ExtArgs>>
    ): Prisma__HorariosClient<$Result.GetResult<Prisma.$HorariosPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Horarios.
     *     @param {HorariosCreateManyArgs} args - Arguments to create many Horarios.
     *     @example
     *     // Create many Horarios
     *     const horarios = await prisma.horarios.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends HorariosCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, HorariosCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Horarios.
     * @param {HorariosDeleteArgs} args - Arguments to delete one Horarios.
     * @example
     * // Delete one Horarios
     * const Horarios = await prisma.horarios.delete({
     *   where: {
     *     // ... filter to delete one Horarios
     *   }
     * })
     * 
    **/
    delete<T extends HorariosDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, HorariosDeleteArgs<ExtArgs>>
    ): Prisma__HorariosClient<$Result.GetResult<Prisma.$HorariosPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Horarios.
     * @param {HorariosUpdateArgs} args - Arguments to update one Horarios.
     * @example
     * // Update one Horarios
     * const horarios = await prisma.horarios.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends HorariosUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, HorariosUpdateArgs<ExtArgs>>
    ): Prisma__HorariosClient<$Result.GetResult<Prisma.$HorariosPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Horarios.
     * @param {HorariosDeleteManyArgs} args - Arguments to filter Horarios to delete.
     * @example
     * // Delete a few Horarios
     * const { count } = await prisma.horarios.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends HorariosDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, HorariosDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Horarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HorariosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Horarios
     * const horarios = await prisma.horarios.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends HorariosUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, HorariosUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Horarios.
     * @param {HorariosUpsertArgs} args - Arguments to update or create a Horarios.
     * @example
     * // Update or create a Horarios
     * const horarios = await prisma.horarios.upsert({
     *   create: {
     *     // ... data to create a Horarios
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Horarios we want to update
     *   }
     * })
    **/
    upsert<T extends HorariosUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, HorariosUpsertArgs<ExtArgs>>
    ): Prisma__HorariosClient<$Result.GetResult<Prisma.$HorariosPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Horarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HorariosCountArgs} args - Arguments to filter Horarios to count.
     * @example
     * // Count the number of Horarios
     * const count = await prisma.horarios.count({
     *   where: {
     *     // ... the filter for the Horarios we want to count
     *   }
     * })
    **/
    count<T extends HorariosCountArgs>(
      args?: Subset<T, HorariosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HorariosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Horarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HorariosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HorariosAggregateArgs>(args: Subset<T, HorariosAggregateArgs>): Prisma.PrismaPromise<GetHorariosAggregateType<T>>

    /**
     * Group by Horarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HorariosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HorariosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HorariosGroupByArgs['orderBy'] }
        : { orderBy?: HorariosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HorariosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHorariosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Horarios model
   */
  readonly fields: HorariosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Horarios.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HorariosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Usuarios<T extends Horarios$UsuariosArgs<ExtArgs> = {}>(args?: Subset<T, Horarios$UsuariosArgs<ExtArgs>>): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Horarios model
   */ 
  interface HorariosFieldRefs {
    readonly horariosID: FieldRef<"Horarios", 'Int'>
    readonly estilistaID: FieldRef<"Horarios", 'Int'>
    readonly diaSemana: FieldRef<"Horarios", 'String'>
    readonly horaInicio: FieldRef<"Horarios", 'DateTime'>
    readonly horaFinal: FieldRef<"Horarios", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Horarios findUnique
   */
  export type HorariosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Horarios
     */
    select?: HorariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HorariosInclude<ExtArgs> | null
    /**
     * Filter, which Horarios to fetch.
     */
    where: HorariosWhereUniqueInput
  }


  /**
   * Horarios findUniqueOrThrow
   */
  export type HorariosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Horarios
     */
    select?: HorariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HorariosInclude<ExtArgs> | null
    /**
     * Filter, which Horarios to fetch.
     */
    where: HorariosWhereUniqueInput
  }


  /**
   * Horarios findFirst
   */
  export type HorariosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Horarios
     */
    select?: HorariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HorariosInclude<ExtArgs> | null
    /**
     * Filter, which Horarios to fetch.
     */
    where?: HorariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Horarios to fetch.
     */
    orderBy?: HorariosOrderByWithRelationInput | HorariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Horarios.
     */
    cursor?: HorariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Horarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Horarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Horarios.
     */
    distinct?: HorariosScalarFieldEnum | HorariosScalarFieldEnum[]
  }


  /**
   * Horarios findFirstOrThrow
   */
  export type HorariosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Horarios
     */
    select?: HorariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HorariosInclude<ExtArgs> | null
    /**
     * Filter, which Horarios to fetch.
     */
    where?: HorariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Horarios to fetch.
     */
    orderBy?: HorariosOrderByWithRelationInput | HorariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Horarios.
     */
    cursor?: HorariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Horarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Horarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Horarios.
     */
    distinct?: HorariosScalarFieldEnum | HorariosScalarFieldEnum[]
  }


  /**
   * Horarios findMany
   */
  export type HorariosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Horarios
     */
    select?: HorariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HorariosInclude<ExtArgs> | null
    /**
     * Filter, which Horarios to fetch.
     */
    where?: HorariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Horarios to fetch.
     */
    orderBy?: HorariosOrderByWithRelationInput | HorariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Horarios.
     */
    cursor?: HorariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Horarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Horarios.
     */
    skip?: number
    distinct?: HorariosScalarFieldEnum | HorariosScalarFieldEnum[]
  }


  /**
   * Horarios create
   */
  export type HorariosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Horarios
     */
    select?: HorariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HorariosInclude<ExtArgs> | null
    /**
     * The data needed to create a Horarios.
     */
    data?: XOR<HorariosCreateInput, HorariosUncheckedCreateInput>
  }


  /**
   * Horarios createMany
   */
  export type HorariosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Horarios.
     */
    data: HorariosCreateManyInput | HorariosCreateManyInput[]
  }


  /**
   * Horarios update
   */
  export type HorariosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Horarios
     */
    select?: HorariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HorariosInclude<ExtArgs> | null
    /**
     * The data needed to update a Horarios.
     */
    data: XOR<HorariosUpdateInput, HorariosUncheckedUpdateInput>
    /**
     * Choose, which Horarios to update.
     */
    where: HorariosWhereUniqueInput
  }


  /**
   * Horarios updateMany
   */
  export type HorariosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Horarios.
     */
    data: XOR<HorariosUpdateManyMutationInput, HorariosUncheckedUpdateManyInput>
    /**
     * Filter which Horarios to update
     */
    where?: HorariosWhereInput
  }


  /**
   * Horarios upsert
   */
  export type HorariosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Horarios
     */
    select?: HorariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HorariosInclude<ExtArgs> | null
    /**
     * The filter to search for the Horarios to update in case it exists.
     */
    where: HorariosWhereUniqueInput
    /**
     * In case the Horarios found by the `where` argument doesn't exist, create a new Horarios with this data.
     */
    create: XOR<HorariosCreateInput, HorariosUncheckedCreateInput>
    /**
     * In case the Horarios was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HorariosUpdateInput, HorariosUncheckedUpdateInput>
  }


  /**
   * Horarios delete
   */
  export type HorariosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Horarios
     */
    select?: HorariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HorariosInclude<ExtArgs> | null
    /**
     * Filter which Horarios to delete.
     */
    where: HorariosWhereUniqueInput
  }


  /**
   * Horarios deleteMany
   */
  export type HorariosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Horarios to delete
     */
    where?: HorariosWhereInput
  }


  /**
   * Horarios.Usuarios
   */
  export type Horarios$UsuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuariosInclude<ExtArgs> | null
    where?: UsuariosWhereInput
  }


  /**
   * Horarios without action
   */
  export type HorariosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Horarios
     */
    select?: HorariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HorariosInclude<ExtArgs> | null
  }



  /**
   * Model HorariosReservados
   */

  export type AggregateHorariosReservados = {
    _count: HorariosReservadosCountAggregateOutputType | null
    _avg: HorariosReservadosAvgAggregateOutputType | null
    _sum: HorariosReservadosSumAggregateOutputType | null
    _min: HorariosReservadosMinAggregateOutputType | null
    _max: HorariosReservadosMaxAggregateOutputType | null
  }

  export type HorariosReservadosAvgAggregateOutputType = {
    citaID: number | null
  }

  export type HorariosReservadosSumAggregateOutputType = {
    citaID: number | null
  }

  export type HorariosReservadosMinAggregateOutputType = {
    citaID: number | null
    dia: Date | null
    hora_inicio: Date | null
    hora_fin: Date | null
  }

  export type HorariosReservadosMaxAggregateOutputType = {
    citaID: number | null
    dia: Date | null
    hora_inicio: Date | null
    hora_fin: Date | null
  }

  export type HorariosReservadosCountAggregateOutputType = {
    citaID: number
    dia: number
    hora_inicio: number
    hora_fin: number
    _all: number
  }


  export type HorariosReservadosAvgAggregateInputType = {
    citaID?: true
  }

  export type HorariosReservadosSumAggregateInputType = {
    citaID?: true
  }

  export type HorariosReservadosMinAggregateInputType = {
    citaID?: true
    dia?: true
    hora_inicio?: true
    hora_fin?: true
  }

  export type HorariosReservadosMaxAggregateInputType = {
    citaID?: true
    dia?: true
    hora_inicio?: true
    hora_fin?: true
  }

  export type HorariosReservadosCountAggregateInputType = {
    citaID?: true
    dia?: true
    hora_inicio?: true
    hora_fin?: true
    _all?: true
  }

  export type HorariosReservadosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HorariosReservados to aggregate.
     */
    where?: HorariosReservadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HorariosReservados to fetch.
     */
    orderBy?: HorariosReservadosOrderByWithRelationInput | HorariosReservadosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HorariosReservadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HorariosReservados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HorariosReservados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HorariosReservados
    **/
    _count?: true | HorariosReservadosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HorariosReservadosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HorariosReservadosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HorariosReservadosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HorariosReservadosMaxAggregateInputType
  }

  export type GetHorariosReservadosAggregateType<T extends HorariosReservadosAggregateArgs> = {
        [P in keyof T & keyof AggregateHorariosReservados]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHorariosReservados[P]>
      : GetScalarType<T[P], AggregateHorariosReservados[P]>
  }




  export type HorariosReservadosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HorariosReservadosWhereInput
    orderBy?: HorariosReservadosOrderByWithAggregationInput | HorariosReservadosOrderByWithAggregationInput[]
    by: HorariosReservadosScalarFieldEnum[] | HorariosReservadosScalarFieldEnum
    having?: HorariosReservadosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HorariosReservadosCountAggregateInputType | true
    _avg?: HorariosReservadosAvgAggregateInputType
    _sum?: HorariosReservadosSumAggregateInputType
    _min?: HorariosReservadosMinAggregateInputType
    _max?: HorariosReservadosMaxAggregateInputType
  }

  export type HorariosReservadosGroupByOutputType = {
    citaID: number
    dia: Date | null
    hora_inicio: Date | null
    hora_fin: Date | null
    _count: HorariosReservadosCountAggregateOutputType | null
    _avg: HorariosReservadosAvgAggregateOutputType | null
    _sum: HorariosReservadosSumAggregateOutputType | null
    _min: HorariosReservadosMinAggregateOutputType | null
    _max: HorariosReservadosMaxAggregateOutputType | null
  }

  type GetHorariosReservadosGroupByPayload<T extends HorariosReservadosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HorariosReservadosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HorariosReservadosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HorariosReservadosGroupByOutputType[P]>
            : GetScalarType<T[P], HorariosReservadosGroupByOutputType[P]>
        }
      >
    >


  export type HorariosReservadosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    citaID?: boolean
    dia?: boolean
    hora_inicio?: boolean
    hora_fin?: boolean
    Citas?: boolean | CitasDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["horariosReservados"]>

  export type HorariosReservadosSelectScalar = {
    citaID?: boolean
    dia?: boolean
    hora_inicio?: boolean
    hora_fin?: boolean
  }

  export type HorariosReservadosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Citas?: boolean | CitasDefaultArgs<ExtArgs>
  }


  export type $HorariosReservadosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HorariosReservados"
    objects: {
      Citas: Prisma.$CitasPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      citaID: number
      dia: Date | null
      hora_inicio: Date | null
      hora_fin: Date | null
    }, ExtArgs["result"]["horariosReservados"]>
    composites: {}
  }


  type HorariosReservadosGetPayload<S extends boolean | null | undefined | HorariosReservadosDefaultArgs> = $Result.GetResult<Prisma.$HorariosReservadosPayload, S>

  type HorariosReservadosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HorariosReservadosFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HorariosReservadosCountAggregateInputType | true
    }

  export interface HorariosReservadosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HorariosReservados'], meta: { name: 'HorariosReservados' } }
    /**
     * Find zero or one HorariosReservados that matches the filter.
     * @param {HorariosReservadosFindUniqueArgs} args - Arguments to find a HorariosReservados
     * @example
     * // Get one HorariosReservados
     * const horariosReservados = await prisma.horariosReservados.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends HorariosReservadosFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, HorariosReservadosFindUniqueArgs<ExtArgs>>
    ): Prisma__HorariosReservadosClient<$Result.GetResult<Prisma.$HorariosReservadosPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one HorariosReservados that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {HorariosReservadosFindUniqueOrThrowArgs} args - Arguments to find a HorariosReservados
     * @example
     * // Get one HorariosReservados
     * const horariosReservados = await prisma.horariosReservados.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends HorariosReservadosFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, HorariosReservadosFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__HorariosReservadosClient<$Result.GetResult<Prisma.$HorariosReservadosPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first HorariosReservados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HorariosReservadosFindFirstArgs} args - Arguments to find a HorariosReservados
     * @example
     * // Get one HorariosReservados
     * const horariosReservados = await prisma.horariosReservados.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends HorariosReservadosFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, HorariosReservadosFindFirstArgs<ExtArgs>>
    ): Prisma__HorariosReservadosClient<$Result.GetResult<Prisma.$HorariosReservadosPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first HorariosReservados that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HorariosReservadosFindFirstOrThrowArgs} args - Arguments to find a HorariosReservados
     * @example
     * // Get one HorariosReservados
     * const horariosReservados = await prisma.horariosReservados.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends HorariosReservadosFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, HorariosReservadosFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__HorariosReservadosClient<$Result.GetResult<Prisma.$HorariosReservadosPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more HorariosReservados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HorariosReservadosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HorariosReservados
     * const horariosReservados = await prisma.horariosReservados.findMany()
     * 
     * // Get first 10 HorariosReservados
     * const horariosReservados = await prisma.horariosReservados.findMany({ take: 10 })
     * 
     * // Only select the `citaID`
     * const horariosReservadosWithCitaIDOnly = await prisma.horariosReservados.findMany({ select: { citaID: true } })
     * 
    **/
    findMany<T extends HorariosReservadosFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, HorariosReservadosFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HorariosReservadosPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a HorariosReservados.
     * @param {HorariosReservadosCreateArgs} args - Arguments to create a HorariosReservados.
     * @example
     * // Create one HorariosReservados
     * const HorariosReservados = await prisma.horariosReservados.create({
     *   data: {
     *     // ... data to create a HorariosReservados
     *   }
     * })
     * 
    **/
    create<T extends HorariosReservadosCreateArgs<ExtArgs>>(
      args: SelectSubset<T, HorariosReservadosCreateArgs<ExtArgs>>
    ): Prisma__HorariosReservadosClient<$Result.GetResult<Prisma.$HorariosReservadosPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many HorariosReservados.
     *     @param {HorariosReservadosCreateManyArgs} args - Arguments to create many HorariosReservados.
     *     @example
     *     // Create many HorariosReservados
     *     const horariosReservados = await prisma.horariosReservados.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends HorariosReservadosCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, HorariosReservadosCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a HorariosReservados.
     * @param {HorariosReservadosDeleteArgs} args - Arguments to delete one HorariosReservados.
     * @example
     * // Delete one HorariosReservados
     * const HorariosReservados = await prisma.horariosReservados.delete({
     *   where: {
     *     // ... filter to delete one HorariosReservados
     *   }
     * })
     * 
    **/
    delete<T extends HorariosReservadosDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, HorariosReservadosDeleteArgs<ExtArgs>>
    ): Prisma__HorariosReservadosClient<$Result.GetResult<Prisma.$HorariosReservadosPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one HorariosReservados.
     * @param {HorariosReservadosUpdateArgs} args - Arguments to update one HorariosReservados.
     * @example
     * // Update one HorariosReservados
     * const horariosReservados = await prisma.horariosReservados.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends HorariosReservadosUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, HorariosReservadosUpdateArgs<ExtArgs>>
    ): Prisma__HorariosReservadosClient<$Result.GetResult<Prisma.$HorariosReservadosPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more HorariosReservados.
     * @param {HorariosReservadosDeleteManyArgs} args - Arguments to filter HorariosReservados to delete.
     * @example
     * // Delete a few HorariosReservados
     * const { count } = await prisma.horariosReservados.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends HorariosReservadosDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, HorariosReservadosDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HorariosReservados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HorariosReservadosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HorariosReservados
     * const horariosReservados = await prisma.horariosReservados.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends HorariosReservadosUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, HorariosReservadosUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HorariosReservados.
     * @param {HorariosReservadosUpsertArgs} args - Arguments to update or create a HorariosReservados.
     * @example
     * // Update or create a HorariosReservados
     * const horariosReservados = await prisma.horariosReservados.upsert({
     *   create: {
     *     // ... data to create a HorariosReservados
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HorariosReservados we want to update
     *   }
     * })
    **/
    upsert<T extends HorariosReservadosUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, HorariosReservadosUpsertArgs<ExtArgs>>
    ): Prisma__HorariosReservadosClient<$Result.GetResult<Prisma.$HorariosReservadosPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of HorariosReservados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HorariosReservadosCountArgs} args - Arguments to filter HorariosReservados to count.
     * @example
     * // Count the number of HorariosReservados
     * const count = await prisma.horariosReservados.count({
     *   where: {
     *     // ... the filter for the HorariosReservados we want to count
     *   }
     * })
    **/
    count<T extends HorariosReservadosCountArgs>(
      args?: Subset<T, HorariosReservadosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HorariosReservadosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HorariosReservados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HorariosReservadosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HorariosReservadosAggregateArgs>(args: Subset<T, HorariosReservadosAggregateArgs>): Prisma.PrismaPromise<GetHorariosReservadosAggregateType<T>>

    /**
     * Group by HorariosReservados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HorariosReservadosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HorariosReservadosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HorariosReservadosGroupByArgs['orderBy'] }
        : { orderBy?: HorariosReservadosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HorariosReservadosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHorariosReservadosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HorariosReservados model
   */
  readonly fields: HorariosReservadosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HorariosReservados.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HorariosReservadosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Citas<T extends CitasDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CitasDefaultArgs<ExtArgs>>): Prisma__CitasClient<$Result.GetResult<Prisma.$CitasPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the HorariosReservados model
   */ 
  interface HorariosReservadosFieldRefs {
    readonly citaID: FieldRef<"HorariosReservados", 'Int'>
    readonly dia: FieldRef<"HorariosReservados", 'DateTime'>
    readonly hora_inicio: FieldRef<"HorariosReservados", 'DateTime'>
    readonly hora_fin: FieldRef<"HorariosReservados", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * HorariosReservados findUnique
   */
  export type HorariosReservadosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HorariosReservados
     */
    select?: HorariosReservadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HorariosReservadosInclude<ExtArgs> | null
    /**
     * Filter, which HorariosReservados to fetch.
     */
    where: HorariosReservadosWhereUniqueInput
  }


  /**
   * HorariosReservados findUniqueOrThrow
   */
  export type HorariosReservadosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HorariosReservados
     */
    select?: HorariosReservadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HorariosReservadosInclude<ExtArgs> | null
    /**
     * Filter, which HorariosReservados to fetch.
     */
    where: HorariosReservadosWhereUniqueInput
  }


  /**
   * HorariosReservados findFirst
   */
  export type HorariosReservadosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HorariosReservados
     */
    select?: HorariosReservadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HorariosReservadosInclude<ExtArgs> | null
    /**
     * Filter, which HorariosReservados to fetch.
     */
    where?: HorariosReservadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HorariosReservados to fetch.
     */
    orderBy?: HorariosReservadosOrderByWithRelationInput | HorariosReservadosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HorariosReservados.
     */
    cursor?: HorariosReservadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HorariosReservados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HorariosReservados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HorariosReservados.
     */
    distinct?: HorariosReservadosScalarFieldEnum | HorariosReservadosScalarFieldEnum[]
  }


  /**
   * HorariosReservados findFirstOrThrow
   */
  export type HorariosReservadosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HorariosReservados
     */
    select?: HorariosReservadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HorariosReservadosInclude<ExtArgs> | null
    /**
     * Filter, which HorariosReservados to fetch.
     */
    where?: HorariosReservadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HorariosReservados to fetch.
     */
    orderBy?: HorariosReservadosOrderByWithRelationInput | HorariosReservadosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HorariosReservados.
     */
    cursor?: HorariosReservadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HorariosReservados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HorariosReservados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HorariosReservados.
     */
    distinct?: HorariosReservadosScalarFieldEnum | HorariosReservadosScalarFieldEnum[]
  }


  /**
   * HorariosReservados findMany
   */
  export type HorariosReservadosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HorariosReservados
     */
    select?: HorariosReservadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HorariosReservadosInclude<ExtArgs> | null
    /**
     * Filter, which HorariosReservados to fetch.
     */
    where?: HorariosReservadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HorariosReservados to fetch.
     */
    orderBy?: HorariosReservadosOrderByWithRelationInput | HorariosReservadosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HorariosReservados.
     */
    cursor?: HorariosReservadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HorariosReservados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HorariosReservados.
     */
    skip?: number
    distinct?: HorariosReservadosScalarFieldEnum | HorariosReservadosScalarFieldEnum[]
  }


  /**
   * HorariosReservados create
   */
  export type HorariosReservadosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HorariosReservados
     */
    select?: HorariosReservadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HorariosReservadosInclude<ExtArgs> | null
    /**
     * The data needed to create a HorariosReservados.
     */
    data: XOR<HorariosReservadosCreateInput, HorariosReservadosUncheckedCreateInput>
  }


  /**
   * HorariosReservados createMany
   */
  export type HorariosReservadosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HorariosReservados.
     */
    data: HorariosReservadosCreateManyInput | HorariosReservadosCreateManyInput[]
  }


  /**
   * HorariosReservados update
   */
  export type HorariosReservadosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HorariosReservados
     */
    select?: HorariosReservadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HorariosReservadosInclude<ExtArgs> | null
    /**
     * The data needed to update a HorariosReservados.
     */
    data: XOR<HorariosReservadosUpdateInput, HorariosReservadosUncheckedUpdateInput>
    /**
     * Choose, which HorariosReservados to update.
     */
    where: HorariosReservadosWhereUniqueInput
  }


  /**
   * HorariosReservados updateMany
   */
  export type HorariosReservadosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HorariosReservados.
     */
    data: XOR<HorariosReservadosUpdateManyMutationInput, HorariosReservadosUncheckedUpdateManyInput>
    /**
     * Filter which HorariosReservados to update
     */
    where?: HorariosReservadosWhereInput
  }


  /**
   * HorariosReservados upsert
   */
  export type HorariosReservadosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HorariosReservados
     */
    select?: HorariosReservadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HorariosReservadosInclude<ExtArgs> | null
    /**
     * The filter to search for the HorariosReservados to update in case it exists.
     */
    where: HorariosReservadosWhereUniqueInput
    /**
     * In case the HorariosReservados found by the `where` argument doesn't exist, create a new HorariosReservados with this data.
     */
    create: XOR<HorariosReservadosCreateInput, HorariosReservadosUncheckedCreateInput>
    /**
     * In case the HorariosReservados was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HorariosReservadosUpdateInput, HorariosReservadosUncheckedUpdateInput>
  }


  /**
   * HorariosReservados delete
   */
  export type HorariosReservadosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HorariosReservados
     */
    select?: HorariosReservadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HorariosReservadosInclude<ExtArgs> | null
    /**
     * Filter which HorariosReservados to delete.
     */
    where: HorariosReservadosWhereUniqueInput
  }


  /**
   * HorariosReservados deleteMany
   */
  export type HorariosReservadosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HorariosReservados to delete
     */
    where?: HorariosReservadosWhereInput
  }


  /**
   * HorariosReservados without action
   */
  export type HorariosReservadosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HorariosReservados
     */
    select?: HorariosReservadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HorariosReservadosInclude<ExtArgs> | null
  }



  /**
   * Model PuntosClientes
   */

  export type AggregatePuntosClientes = {
    _count: PuntosClientesCountAggregateOutputType | null
    _avg: PuntosClientesAvgAggregateOutputType | null
    _sum: PuntosClientesSumAggregateOutputType | null
    _min: PuntosClientesMinAggregateOutputType | null
    _max: PuntosClientesMaxAggregateOutputType | null
  }

  export type PuntosClientesAvgAggregateOutputType = {
    puntosID: number | null
    clienteID: number | null
    puntosAcumulados: number | null
    puntosCanjeados: number | null
  }

  export type PuntosClientesSumAggregateOutputType = {
    puntosID: number | null
    clienteID: number | null
    puntosAcumulados: number | null
    puntosCanjeados: number | null
  }

  export type PuntosClientesMinAggregateOutputType = {
    puntosID: number | null
    clienteID: number | null
    puntosAcumulados: number | null
    puntosCanjeados: number | null
  }

  export type PuntosClientesMaxAggregateOutputType = {
    puntosID: number | null
    clienteID: number | null
    puntosAcumulados: number | null
    puntosCanjeados: number | null
  }

  export type PuntosClientesCountAggregateOutputType = {
    puntosID: number
    clienteID: number
    puntosAcumulados: number
    puntosCanjeados: number
    _all: number
  }


  export type PuntosClientesAvgAggregateInputType = {
    puntosID?: true
    clienteID?: true
    puntosAcumulados?: true
    puntosCanjeados?: true
  }

  export type PuntosClientesSumAggregateInputType = {
    puntosID?: true
    clienteID?: true
    puntosAcumulados?: true
    puntosCanjeados?: true
  }

  export type PuntosClientesMinAggregateInputType = {
    puntosID?: true
    clienteID?: true
    puntosAcumulados?: true
    puntosCanjeados?: true
  }

  export type PuntosClientesMaxAggregateInputType = {
    puntosID?: true
    clienteID?: true
    puntosAcumulados?: true
    puntosCanjeados?: true
  }

  export type PuntosClientesCountAggregateInputType = {
    puntosID?: true
    clienteID?: true
    puntosAcumulados?: true
    puntosCanjeados?: true
    _all?: true
  }

  export type PuntosClientesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PuntosClientes to aggregate.
     */
    where?: PuntosClientesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PuntosClientes to fetch.
     */
    orderBy?: PuntosClientesOrderByWithRelationInput | PuntosClientesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PuntosClientesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PuntosClientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PuntosClientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PuntosClientes
    **/
    _count?: true | PuntosClientesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PuntosClientesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PuntosClientesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PuntosClientesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PuntosClientesMaxAggregateInputType
  }

  export type GetPuntosClientesAggregateType<T extends PuntosClientesAggregateArgs> = {
        [P in keyof T & keyof AggregatePuntosClientes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePuntosClientes[P]>
      : GetScalarType<T[P], AggregatePuntosClientes[P]>
  }




  export type PuntosClientesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PuntosClientesWhereInput
    orderBy?: PuntosClientesOrderByWithAggregationInput | PuntosClientesOrderByWithAggregationInput[]
    by: PuntosClientesScalarFieldEnum[] | PuntosClientesScalarFieldEnum
    having?: PuntosClientesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PuntosClientesCountAggregateInputType | true
    _avg?: PuntosClientesAvgAggregateInputType
    _sum?: PuntosClientesSumAggregateInputType
    _min?: PuntosClientesMinAggregateInputType
    _max?: PuntosClientesMaxAggregateInputType
  }

  export type PuntosClientesGroupByOutputType = {
    puntosID: number
    clienteID: number | null
    puntosAcumulados: number | null
    puntosCanjeados: number | null
    _count: PuntosClientesCountAggregateOutputType | null
    _avg: PuntosClientesAvgAggregateOutputType | null
    _sum: PuntosClientesSumAggregateOutputType | null
    _min: PuntosClientesMinAggregateOutputType | null
    _max: PuntosClientesMaxAggregateOutputType | null
  }

  type GetPuntosClientesGroupByPayload<T extends PuntosClientesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PuntosClientesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PuntosClientesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PuntosClientesGroupByOutputType[P]>
            : GetScalarType<T[P], PuntosClientesGroupByOutputType[P]>
        }
      >
    >


  export type PuntosClientesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    puntosID?: boolean
    clienteID?: boolean
    puntosAcumulados?: boolean
    puntosCanjeados?: boolean
    Usuarios?: boolean | PuntosClientes$UsuariosArgs<ExtArgs>
  }, ExtArgs["result"]["puntosClientes"]>

  export type PuntosClientesSelectScalar = {
    puntosID?: boolean
    clienteID?: boolean
    puntosAcumulados?: boolean
    puntosCanjeados?: boolean
  }

  export type PuntosClientesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Usuarios?: boolean | PuntosClientes$UsuariosArgs<ExtArgs>
  }


  export type $PuntosClientesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PuntosClientes"
    objects: {
      Usuarios: Prisma.$UsuariosPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      puntosID: number
      clienteID: number | null
      puntosAcumulados: number | null
      puntosCanjeados: number | null
    }, ExtArgs["result"]["puntosClientes"]>
    composites: {}
  }


  type PuntosClientesGetPayload<S extends boolean | null | undefined | PuntosClientesDefaultArgs> = $Result.GetResult<Prisma.$PuntosClientesPayload, S>

  type PuntosClientesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PuntosClientesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PuntosClientesCountAggregateInputType | true
    }

  export interface PuntosClientesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PuntosClientes'], meta: { name: 'PuntosClientes' } }
    /**
     * Find zero or one PuntosClientes that matches the filter.
     * @param {PuntosClientesFindUniqueArgs} args - Arguments to find a PuntosClientes
     * @example
     * // Get one PuntosClientes
     * const puntosClientes = await prisma.puntosClientes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PuntosClientesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PuntosClientesFindUniqueArgs<ExtArgs>>
    ): Prisma__PuntosClientesClient<$Result.GetResult<Prisma.$PuntosClientesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one PuntosClientes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PuntosClientesFindUniqueOrThrowArgs} args - Arguments to find a PuntosClientes
     * @example
     * // Get one PuntosClientes
     * const puntosClientes = await prisma.puntosClientes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PuntosClientesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PuntosClientesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PuntosClientesClient<$Result.GetResult<Prisma.$PuntosClientesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first PuntosClientes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PuntosClientesFindFirstArgs} args - Arguments to find a PuntosClientes
     * @example
     * // Get one PuntosClientes
     * const puntosClientes = await prisma.puntosClientes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PuntosClientesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PuntosClientesFindFirstArgs<ExtArgs>>
    ): Prisma__PuntosClientesClient<$Result.GetResult<Prisma.$PuntosClientesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first PuntosClientes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PuntosClientesFindFirstOrThrowArgs} args - Arguments to find a PuntosClientes
     * @example
     * // Get one PuntosClientes
     * const puntosClientes = await prisma.puntosClientes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PuntosClientesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PuntosClientesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PuntosClientesClient<$Result.GetResult<Prisma.$PuntosClientesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more PuntosClientes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PuntosClientesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PuntosClientes
     * const puntosClientes = await prisma.puntosClientes.findMany()
     * 
     * // Get first 10 PuntosClientes
     * const puntosClientes = await prisma.puntosClientes.findMany({ take: 10 })
     * 
     * // Only select the `puntosID`
     * const puntosClientesWithPuntosIDOnly = await prisma.puntosClientes.findMany({ select: { puntosID: true } })
     * 
    **/
    findMany<T extends PuntosClientesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PuntosClientesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PuntosClientesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a PuntosClientes.
     * @param {PuntosClientesCreateArgs} args - Arguments to create a PuntosClientes.
     * @example
     * // Create one PuntosClientes
     * const PuntosClientes = await prisma.puntosClientes.create({
     *   data: {
     *     // ... data to create a PuntosClientes
     *   }
     * })
     * 
    **/
    create<T extends PuntosClientesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PuntosClientesCreateArgs<ExtArgs>>
    ): Prisma__PuntosClientesClient<$Result.GetResult<Prisma.$PuntosClientesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many PuntosClientes.
     *     @param {PuntosClientesCreateManyArgs} args - Arguments to create many PuntosClientes.
     *     @example
     *     // Create many PuntosClientes
     *     const puntosClientes = await prisma.puntosClientes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PuntosClientesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PuntosClientesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PuntosClientes.
     * @param {PuntosClientesDeleteArgs} args - Arguments to delete one PuntosClientes.
     * @example
     * // Delete one PuntosClientes
     * const PuntosClientes = await prisma.puntosClientes.delete({
     *   where: {
     *     // ... filter to delete one PuntosClientes
     *   }
     * })
     * 
    **/
    delete<T extends PuntosClientesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PuntosClientesDeleteArgs<ExtArgs>>
    ): Prisma__PuntosClientesClient<$Result.GetResult<Prisma.$PuntosClientesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one PuntosClientes.
     * @param {PuntosClientesUpdateArgs} args - Arguments to update one PuntosClientes.
     * @example
     * // Update one PuntosClientes
     * const puntosClientes = await prisma.puntosClientes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PuntosClientesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PuntosClientesUpdateArgs<ExtArgs>>
    ): Prisma__PuntosClientesClient<$Result.GetResult<Prisma.$PuntosClientesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more PuntosClientes.
     * @param {PuntosClientesDeleteManyArgs} args - Arguments to filter PuntosClientes to delete.
     * @example
     * // Delete a few PuntosClientes
     * const { count } = await prisma.puntosClientes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PuntosClientesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PuntosClientesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PuntosClientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PuntosClientesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PuntosClientes
     * const puntosClientes = await prisma.puntosClientes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PuntosClientesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PuntosClientesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PuntosClientes.
     * @param {PuntosClientesUpsertArgs} args - Arguments to update or create a PuntosClientes.
     * @example
     * // Update or create a PuntosClientes
     * const puntosClientes = await prisma.puntosClientes.upsert({
     *   create: {
     *     // ... data to create a PuntosClientes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PuntosClientes we want to update
     *   }
     * })
    **/
    upsert<T extends PuntosClientesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PuntosClientesUpsertArgs<ExtArgs>>
    ): Prisma__PuntosClientesClient<$Result.GetResult<Prisma.$PuntosClientesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of PuntosClientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PuntosClientesCountArgs} args - Arguments to filter PuntosClientes to count.
     * @example
     * // Count the number of PuntosClientes
     * const count = await prisma.puntosClientes.count({
     *   where: {
     *     // ... the filter for the PuntosClientes we want to count
     *   }
     * })
    **/
    count<T extends PuntosClientesCountArgs>(
      args?: Subset<T, PuntosClientesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PuntosClientesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PuntosClientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PuntosClientesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PuntosClientesAggregateArgs>(args: Subset<T, PuntosClientesAggregateArgs>): Prisma.PrismaPromise<GetPuntosClientesAggregateType<T>>

    /**
     * Group by PuntosClientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PuntosClientesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PuntosClientesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PuntosClientesGroupByArgs['orderBy'] }
        : { orderBy?: PuntosClientesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PuntosClientesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPuntosClientesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PuntosClientes model
   */
  readonly fields: PuntosClientesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PuntosClientes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PuntosClientesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Usuarios<T extends PuntosClientes$UsuariosArgs<ExtArgs> = {}>(args?: Subset<T, PuntosClientes$UsuariosArgs<ExtArgs>>): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the PuntosClientes model
   */ 
  interface PuntosClientesFieldRefs {
    readonly puntosID: FieldRef<"PuntosClientes", 'Int'>
    readonly clienteID: FieldRef<"PuntosClientes", 'Int'>
    readonly puntosAcumulados: FieldRef<"PuntosClientes", 'Int'>
    readonly puntosCanjeados: FieldRef<"PuntosClientes", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * PuntosClientes findUnique
   */
  export type PuntosClientesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PuntosClientes
     */
    select?: PuntosClientesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PuntosClientesInclude<ExtArgs> | null
    /**
     * Filter, which PuntosClientes to fetch.
     */
    where: PuntosClientesWhereUniqueInput
  }


  /**
   * PuntosClientes findUniqueOrThrow
   */
  export type PuntosClientesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PuntosClientes
     */
    select?: PuntosClientesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PuntosClientesInclude<ExtArgs> | null
    /**
     * Filter, which PuntosClientes to fetch.
     */
    where: PuntosClientesWhereUniqueInput
  }


  /**
   * PuntosClientes findFirst
   */
  export type PuntosClientesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PuntosClientes
     */
    select?: PuntosClientesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PuntosClientesInclude<ExtArgs> | null
    /**
     * Filter, which PuntosClientes to fetch.
     */
    where?: PuntosClientesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PuntosClientes to fetch.
     */
    orderBy?: PuntosClientesOrderByWithRelationInput | PuntosClientesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PuntosClientes.
     */
    cursor?: PuntosClientesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PuntosClientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PuntosClientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PuntosClientes.
     */
    distinct?: PuntosClientesScalarFieldEnum | PuntosClientesScalarFieldEnum[]
  }


  /**
   * PuntosClientes findFirstOrThrow
   */
  export type PuntosClientesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PuntosClientes
     */
    select?: PuntosClientesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PuntosClientesInclude<ExtArgs> | null
    /**
     * Filter, which PuntosClientes to fetch.
     */
    where?: PuntosClientesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PuntosClientes to fetch.
     */
    orderBy?: PuntosClientesOrderByWithRelationInput | PuntosClientesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PuntosClientes.
     */
    cursor?: PuntosClientesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PuntosClientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PuntosClientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PuntosClientes.
     */
    distinct?: PuntosClientesScalarFieldEnum | PuntosClientesScalarFieldEnum[]
  }


  /**
   * PuntosClientes findMany
   */
  export type PuntosClientesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PuntosClientes
     */
    select?: PuntosClientesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PuntosClientesInclude<ExtArgs> | null
    /**
     * Filter, which PuntosClientes to fetch.
     */
    where?: PuntosClientesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PuntosClientes to fetch.
     */
    orderBy?: PuntosClientesOrderByWithRelationInput | PuntosClientesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PuntosClientes.
     */
    cursor?: PuntosClientesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PuntosClientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PuntosClientes.
     */
    skip?: number
    distinct?: PuntosClientesScalarFieldEnum | PuntosClientesScalarFieldEnum[]
  }


  /**
   * PuntosClientes create
   */
  export type PuntosClientesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PuntosClientes
     */
    select?: PuntosClientesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PuntosClientesInclude<ExtArgs> | null
    /**
     * The data needed to create a PuntosClientes.
     */
    data?: XOR<PuntosClientesCreateInput, PuntosClientesUncheckedCreateInput>
  }


  /**
   * PuntosClientes createMany
   */
  export type PuntosClientesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PuntosClientes.
     */
    data: PuntosClientesCreateManyInput | PuntosClientesCreateManyInput[]
  }


  /**
   * PuntosClientes update
   */
  export type PuntosClientesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PuntosClientes
     */
    select?: PuntosClientesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PuntosClientesInclude<ExtArgs> | null
    /**
     * The data needed to update a PuntosClientes.
     */
    data: XOR<PuntosClientesUpdateInput, PuntosClientesUncheckedUpdateInput>
    /**
     * Choose, which PuntosClientes to update.
     */
    where: PuntosClientesWhereUniqueInput
  }


  /**
   * PuntosClientes updateMany
   */
  export type PuntosClientesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PuntosClientes.
     */
    data: XOR<PuntosClientesUpdateManyMutationInput, PuntosClientesUncheckedUpdateManyInput>
    /**
     * Filter which PuntosClientes to update
     */
    where?: PuntosClientesWhereInput
  }


  /**
   * PuntosClientes upsert
   */
  export type PuntosClientesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PuntosClientes
     */
    select?: PuntosClientesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PuntosClientesInclude<ExtArgs> | null
    /**
     * The filter to search for the PuntosClientes to update in case it exists.
     */
    where: PuntosClientesWhereUniqueInput
    /**
     * In case the PuntosClientes found by the `where` argument doesn't exist, create a new PuntosClientes with this data.
     */
    create: XOR<PuntosClientesCreateInput, PuntosClientesUncheckedCreateInput>
    /**
     * In case the PuntosClientes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PuntosClientesUpdateInput, PuntosClientesUncheckedUpdateInput>
  }


  /**
   * PuntosClientes delete
   */
  export type PuntosClientesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PuntosClientes
     */
    select?: PuntosClientesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PuntosClientesInclude<ExtArgs> | null
    /**
     * Filter which PuntosClientes to delete.
     */
    where: PuntosClientesWhereUniqueInput
  }


  /**
   * PuntosClientes deleteMany
   */
  export type PuntosClientesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PuntosClientes to delete
     */
    where?: PuntosClientesWhereInput
  }


  /**
   * PuntosClientes.Usuarios
   */
  export type PuntosClientes$UsuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuariosInclude<ExtArgs> | null
    where?: UsuariosWhereInput
  }


  /**
   * PuntosClientes without action
   */
  export type PuntosClientesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PuntosClientes
     */
    select?: PuntosClientesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PuntosClientesInclude<ExtArgs> | null
  }



  /**
   * Model PuntosServicio
   */

  export type AggregatePuntosServicio = {
    _count: PuntosServicioCountAggregateOutputType | null
    _avg: PuntosServicioAvgAggregateOutputType | null
    _sum: PuntosServicioSumAggregateOutputType | null
    _min: PuntosServicioMinAggregateOutputType | null
    _max: PuntosServicioMaxAggregateOutputType | null
  }

  export type PuntosServicioAvgAggregateOutputType = {
    servicioID: number | null
    puntosGenerados: number | null
  }

  export type PuntosServicioSumAggregateOutputType = {
    servicioID: number | null
    puntosGenerados: number | null
  }

  export type PuntosServicioMinAggregateOutputType = {
    servicioID: number | null
    puntosGenerados: number | null
  }

  export type PuntosServicioMaxAggregateOutputType = {
    servicioID: number | null
    puntosGenerados: number | null
  }

  export type PuntosServicioCountAggregateOutputType = {
    servicioID: number
    puntosGenerados: number
    _all: number
  }


  export type PuntosServicioAvgAggregateInputType = {
    servicioID?: true
    puntosGenerados?: true
  }

  export type PuntosServicioSumAggregateInputType = {
    servicioID?: true
    puntosGenerados?: true
  }

  export type PuntosServicioMinAggregateInputType = {
    servicioID?: true
    puntosGenerados?: true
  }

  export type PuntosServicioMaxAggregateInputType = {
    servicioID?: true
    puntosGenerados?: true
  }

  export type PuntosServicioCountAggregateInputType = {
    servicioID?: true
    puntosGenerados?: true
    _all?: true
  }

  export type PuntosServicioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PuntosServicio to aggregate.
     */
    where?: PuntosServicioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PuntosServicios to fetch.
     */
    orderBy?: PuntosServicioOrderByWithRelationInput | PuntosServicioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PuntosServicioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PuntosServicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PuntosServicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PuntosServicios
    **/
    _count?: true | PuntosServicioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PuntosServicioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PuntosServicioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PuntosServicioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PuntosServicioMaxAggregateInputType
  }

  export type GetPuntosServicioAggregateType<T extends PuntosServicioAggregateArgs> = {
        [P in keyof T & keyof AggregatePuntosServicio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePuntosServicio[P]>
      : GetScalarType<T[P], AggregatePuntosServicio[P]>
  }




  export type PuntosServicioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PuntosServicioWhereInput
    orderBy?: PuntosServicioOrderByWithAggregationInput | PuntosServicioOrderByWithAggregationInput[]
    by: PuntosServicioScalarFieldEnum[] | PuntosServicioScalarFieldEnum
    having?: PuntosServicioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PuntosServicioCountAggregateInputType | true
    _avg?: PuntosServicioAvgAggregateInputType
    _sum?: PuntosServicioSumAggregateInputType
    _min?: PuntosServicioMinAggregateInputType
    _max?: PuntosServicioMaxAggregateInputType
  }

  export type PuntosServicioGroupByOutputType = {
    servicioID: number
    puntosGenerados: number | null
    _count: PuntosServicioCountAggregateOutputType | null
    _avg: PuntosServicioAvgAggregateOutputType | null
    _sum: PuntosServicioSumAggregateOutputType | null
    _min: PuntosServicioMinAggregateOutputType | null
    _max: PuntosServicioMaxAggregateOutputType | null
  }

  type GetPuntosServicioGroupByPayload<T extends PuntosServicioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PuntosServicioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PuntosServicioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PuntosServicioGroupByOutputType[P]>
            : GetScalarType<T[P], PuntosServicioGroupByOutputType[P]>
        }
      >
    >


  export type PuntosServicioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    servicioID?: boolean
    puntosGenerados?: boolean
    Servicios?: boolean | ServiciosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["puntosServicio"]>

  export type PuntosServicioSelectScalar = {
    servicioID?: boolean
    puntosGenerados?: boolean
  }

  export type PuntosServicioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Servicios?: boolean | ServiciosDefaultArgs<ExtArgs>
  }


  export type $PuntosServicioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PuntosServicio"
    objects: {
      Servicios: Prisma.$ServiciosPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      servicioID: number
      puntosGenerados: number | null
    }, ExtArgs["result"]["puntosServicio"]>
    composites: {}
  }


  type PuntosServicioGetPayload<S extends boolean | null | undefined | PuntosServicioDefaultArgs> = $Result.GetResult<Prisma.$PuntosServicioPayload, S>

  type PuntosServicioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PuntosServicioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PuntosServicioCountAggregateInputType | true
    }

  export interface PuntosServicioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PuntosServicio'], meta: { name: 'PuntosServicio' } }
    /**
     * Find zero or one PuntosServicio that matches the filter.
     * @param {PuntosServicioFindUniqueArgs} args - Arguments to find a PuntosServicio
     * @example
     * // Get one PuntosServicio
     * const puntosServicio = await prisma.puntosServicio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PuntosServicioFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PuntosServicioFindUniqueArgs<ExtArgs>>
    ): Prisma__PuntosServicioClient<$Result.GetResult<Prisma.$PuntosServicioPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one PuntosServicio that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PuntosServicioFindUniqueOrThrowArgs} args - Arguments to find a PuntosServicio
     * @example
     * // Get one PuntosServicio
     * const puntosServicio = await prisma.puntosServicio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PuntosServicioFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PuntosServicioFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PuntosServicioClient<$Result.GetResult<Prisma.$PuntosServicioPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first PuntosServicio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PuntosServicioFindFirstArgs} args - Arguments to find a PuntosServicio
     * @example
     * // Get one PuntosServicio
     * const puntosServicio = await prisma.puntosServicio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PuntosServicioFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PuntosServicioFindFirstArgs<ExtArgs>>
    ): Prisma__PuntosServicioClient<$Result.GetResult<Prisma.$PuntosServicioPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first PuntosServicio that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PuntosServicioFindFirstOrThrowArgs} args - Arguments to find a PuntosServicio
     * @example
     * // Get one PuntosServicio
     * const puntosServicio = await prisma.puntosServicio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PuntosServicioFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PuntosServicioFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PuntosServicioClient<$Result.GetResult<Prisma.$PuntosServicioPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more PuntosServicios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PuntosServicioFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PuntosServicios
     * const puntosServicios = await prisma.puntosServicio.findMany()
     * 
     * // Get first 10 PuntosServicios
     * const puntosServicios = await prisma.puntosServicio.findMany({ take: 10 })
     * 
     * // Only select the `servicioID`
     * const puntosServicioWithServicioIDOnly = await prisma.puntosServicio.findMany({ select: { servicioID: true } })
     * 
    **/
    findMany<T extends PuntosServicioFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PuntosServicioFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PuntosServicioPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a PuntosServicio.
     * @param {PuntosServicioCreateArgs} args - Arguments to create a PuntosServicio.
     * @example
     * // Create one PuntosServicio
     * const PuntosServicio = await prisma.puntosServicio.create({
     *   data: {
     *     // ... data to create a PuntosServicio
     *   }
     * })
     * 
    **/
    create<T extends PuntosServicioCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PuntosServicioCreateArgs<ExtArgs>>
    ): Prisma__PuntosServicioClient<$Result.GetResult<Prisma.$PuntosServicioPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many PuntosServicios.
     *     @param {PuntosServicioCreateManyArgs} args - Arguments to create many PuntosServicios.
     *     @example
     *     // Create many PuntosServicios
     *     const puntosServicio = await prisma.puntosServicio.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PuntosServicioCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PuntosServicioCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PuntosServicio.
     * @param {PuntosServicioDeleteArgs} args - Arguments to delete one PuntosServicio.
     * @example
     * // Delete one PuntosServicio
     * const PuntosServicio = await prisma.puntosServicio.delete({
     *   where: {
     *     // ... filter to delete one PuntosServicio
     *   }
     * })
     * 
    **/
    delete<T extends PuntosServicioDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PuntosServicioDeleteArgs<ExtArgs>>
    ): Prisma__PuntosServicioClient<$Result.GetResult<Prisma.$PuntosServicioPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one PuntosServicio.
     * @param {PuntosServicioUpdateArgs} args - Arguments to update one PuntosServicio.
     * @example
     * // Update one PuntosServicio
     * const puntosServicio = await prisma.puntosServicio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PuntosServicioUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PuntosServicioUpdateArgs<ExtArgs>>
    ): Prisma__PuntosServicioClient<$Result.GetResult<Prisma.$PuntosServicioPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more PuntosServicios.
     * @param {PuntosServicioDeleteManyArgs} args - Arguments to filter PuntosServicios to delete.
     * @example
     * // Delete a few PuntosServicios
     * const { count } = await prisma.puntosServicio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PuntosServicioDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PuntosServicioDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PuntosServicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PuntosServicioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PuntosServicios
     * const puntosServicio = await prisma.puntosServicio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PuntosServicioUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PuntosServicioUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PuntosServicio.
     * @param {PuntosServicioUpsertArgs} args - Arguments to update or create a PuntosServicio.
     * @example
     * // Update or create a PuntosServicio
     * const puntosServicio = await prisma.puntosServicio.upsert({
     *   create: {
     *     // ... data to create a PuntosServicio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PuntosServicio we want to update
     *   }
     * })
    **/
    upsert<T extends PuntosServicioUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PuntosServicioUpsertArgs<ExtArgs>>
    ): Prisma__PuntosServicioClient<$Result.GetResult<Prisma.$PuntosServicioPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of PuntosServicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PuntosServicioCountArgs} args - Arguments to filter PuntosServicios to count.
     * @example
     * // Count the number of PuntosServicios
     * const count = await prisma.puntosServicio.count({
     *   where: {
     *     // ... the filter for the PuntosServicios we want to count
     *   }
     * })
    **/
    count<T extends PuntosServicioCountArgs>(
      args?: Subset<T, PuntosServicioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PuntosServicioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PuntosServicio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PuntosServicioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PuntosServicioAggregateArgs>(args: Subset<T, PuntosServicioAggregateArgs>): Prisma.PrismaPromise<GetPuntosServicioAggregateType<T>>

    /**
     * Group by PuntosServicio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PuntosServicioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PuntosServicioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PuntosServicioGroupByArgs['orderBy'] }
        : { orderBy?: PuntosServicioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PuntosServicioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPuntosServicioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PuntosServicio model
   */
  readonly fields: PuntosServicioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PuntosServicio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PuntosServicioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Servicios<T extends ServiciosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiciosDefaultArgs<ExtArgs>>): Prisma__ServiciosClient<$Result.GetResult<Prisma.$ServiciosPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the PuntosServicio model
   */ 
  interface PuntosServicioFieldRefs {
    readonly servicioID: FieldRef<"PuntosServicio", 'Int'>
    readonly puntosGenerados: FieldRef<"PuntosServicio", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * PuntosServicio findUnique
   */
  export type PuntosServicioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PuntosServicio
     */
    select?: PuntosServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PuntosServicioInclude<ExtArgs> | null
    /**
     * Filter, which PuntosServicio to fetch.
     */
    where: PuntosServicioWhereUniqueInput
  }


  /**
   * PuntosServicio findUniqueOrThrow
   */
  export type PuntosServicioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PuntosServicio
     */
    select?: PuntosServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PuntosServicioInclude<ExtArgs> | null
    /**
     * Filter, which PuntosServicio to fetch.
     */
    where: PuntosServicioWhereUniqueInput
  }


  /**
   * PuntosServicio findFirst
   */
  export type PuntosServicioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PuntosServicio
     */
    select?: PuntosServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PuntosServicioInclude<ExtArgs> | null
    /**
     * Filter, which PuntosServicio to fetch.
     */
    where?: PuntosServicioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PuntosServicios to fetch.
     */
    orderBy?: PuntosServicioOrderByWithRelationInput | PuntosServicioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PuntosServicios.
     */
    cursor?: PuntosServicioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PuntosServicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PuntosServicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PuntosServicios.
     */
    distinct?: PuntosServicioScalarFieldEnum | PuntosServicioScalarFieldEnum[]
  }


  /**
   * PuntosServicio findFirstOrThrow
   */
  export type PuntosServicioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PuntosServicio
     */
    select?: PuntosServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PuntosServicioInclude<ExtArgs> | null
    /**
     * Filter, which PuntosServicio to fetch.
     */
    where?: PuntosServicioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PuntosServicios to fetch.
     */
    orderBy?: PuntosServicioOrderByWithRelationInput | PuntosServicioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PuntosServicios.
     */
    cursor?: PuntosServicioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PuntosServicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PuntosServicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PuntosServicios.
     */
    distinct?: PuntosServicioScalarFieldEnum | PuntosServicioScalarFieldEnum[]
  }


  /**
   * PuntosServicio findMany
   */
  export type PuntosServicioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PuntosServicio
     */
    select?: PuntosServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PuntosServicioInclude<ExtArgs> | null
    /**
     * Filter, which PuntosServicios to fetch.
     */
    where?: PuntosServicioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PuntosServicios to fetch.
     */
    orderBy?: PuntosServicioOrderByWithRelationInput | PuntosServicioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PuntosServicios.
     */
    cursor?: PuntosServicioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PuntosServicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PuntosServicios.
     */
    skip?: number
    distinct?: PuntosServicioScalarFieldEnum | PuntosServicioScalarFieldEnum[]
  }


  /**
   * PuntosServicio create
   */
  export type PuntosServicioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PuntosServicio
     */
    select?: PuntosServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PuntosServicioInclude<ExtArgs> | null
    /**
     * The data needed to create a PuntosServicio.
     */
    data: XOR<PuntosServicioCreateInput, PuntosServicioUncheckedCreateInput>
  }


  /**
   * PuntosServicio createMany
   */
  export type PuntosServicioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PuntosServicios.
     */
    data: PuntosServicioCreateManyInput | PuntosServicioCreateManyInput[]
  }


  /**
   * PuntosServicio update
   */
  export type PuntosServicioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PuntosServicio
     */
    select?: PuntosServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PuntosServicioInclude<ExtArgs> | null
    /**
     * The data needed to update a PuntosServicio.
     */
    data: XOR<PuntosServicioUpdateInput, PuntosServicioUncheckedUpdateInput>
    /**
     * Choose, which PuntosServicio to update.
     */
    where: PuntosServicioWhereUniqueInput
  }


  /**
   * PuntosServicio updateMany
   */
  export type PuntosServicioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PuntosServicios.
     */
    data: XOR<PuntosServicioUpdateManyMutationInput, PuntosServicioUncheckedUpdateManyInput>
    /**
     * Filter which PuntosServicios to update
     */
    where?: PuntosServicioWhereInput
  }


  /**
   * PuntosServicio upsert
   */
  export type PuntosServicioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PuntosServicio
     */
    select?: PuntosServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PuntosServicioInclude<ExtArgs> | null
    /**
     * The filter to search for the PuntosServicio to update in case it exists.
     */
    where: PuntosServicioWhereUniqueInput
    /**
     * In case the PuntosServicio found by the `where` argument doesn't exist, create a new PuntosServicio with this data.
     */
    create: XOR<PuntosServicioCreateInput, PuntosServicioUncheckedCreateInput>
    /**
     * In case the PuntosServicio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PuntosServicioUpdateInput, PuntosServicioUncheckedUpdateInput>
  }


  /**
   * PuntosServicio delete
   */
  export type PuntosServicioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PuntosServicio
     */
    select?: PuntosServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PuntosServicioInclude<ExtArgs> | null
    /**
     * Filter which PuntosServicio to delete.
     */
    where: PuntosServicioWhereUniqueInput
  }


  /**
   * PuntosServicio deleteMany
   */
  export type PuntosServicioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PuntosServicios to delete
     */
    where?: PuntosServicioWhereInput
  }


  /**
   * PuntosServicio without action
   */
  export type PuntosServicioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PuntosServicio
     */
    select?: PuntosServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PuntosServicioInclude<ExtArgs> | null
  }



  /**
   * Model Roles
   */

  export type AggregateRoles = {
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  export type RolesAvgAggregateOutputType = {
    rolID: number | null
  }

  export type RolesSumAggregateOutputType = {
    rolID: number | null
  }

  export type RolesMinAggregateOutputType = {
    rolID: number | null
    nombreRol: string | null
  }

  export type RolesMaxAggregateOutputType = {
    rolID: number | null
    nombreRol: string | null
  }

  export type RolesCountAggregateOutputType = {
    rolID: number
    nombreRol: number
    _all: number
  }


  export type RolesAvgAggregateInputType = {
    rolID?: true
  }

  export type RolesSumAggregateInputType = {
    rolID?: true
  }

  export type RolesMinAggregateInputType = {
    rolID?: true
    nombreRol?: true
  }

  export type RolesMaxAggregateInputType = {
    rolID?: true
    nombreRol?: true
  }

  export type RolesCountAggregateInputType = {
    rolID?: true
    nombreRol?: true
    _all?: true
  }

  export type RolesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to aggregate.
     */
    where?: RolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RolesOrderByWithRelationInput | RolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolesMaxAggregateInputType
  }

  export type GetRolesAggregateType<T extends RolesAggregateArgs> = {
        [P in keyof T & keyof AggregateRoles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoles[P]>
      : GetScalarType<T[P], AggregateRoles[P]>
  }




  export type RolesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolesWhereInput
    orderBy?: RolesOrderByWithAggregationInput | RolesOrderByWithAggregationInput[]
    by: RolesScalarFieldEnum[] | RolesScalarFieldEnum
    having?: RolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolesCountAggregateInputType | true
    _avg?: RolesAvgAggregateInputType
    _sum?: RolesSumAggregateInputType
    _min?: RolesMinAggregateInputType
    _max?: RolesMaxAggregateInputType
  }

  export type RolesGroupByOutputType = {
    rolID: number
    nombreRol: string | null
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  type GetRolesGroupByPayload<T extends RolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolesGroupByOutputType[P]>
            : GetScalarType<T[P], RolesGroupByOutputType[P]>
        }
      >
    >


  export type RolesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    rolID?: boolean
    nombreRol?: boolean
    Usuarios?: boolean | Roles$UsuariosArgs<ExtArgs>
    _count?: boolean | RolesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roles"]>

  export type RolesSelectScalar = {
    rolID?: boolean
    nombreRol?: boolean
  }

  export type RolesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Usuarios?: boolean | Roles$UsuariosArgs<ExtArgs>
    _count?: boolean | RolesCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $RolesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Roles"
    objects: {
      Usuarios: Prisma.$UsuariosPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      rolID: number
      nombreRol: string | null
    }, ExtArgs["result"]["roles"]>
    composites: {}
  }


  type RolesGetPayload<S extends boolean | null | undefined | RolesDefaultArgs> = $Result.GetResult<Prisma.$RolesPayload, S>

  type RolesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RolesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RolesCountAggregateInputType | true
    }

  export interface RolesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Roles'], meta: { name: 'Roles' } }
    /**
     * Find zero or one Roles that matches the filter.
     * @param {RolesFindUniqueArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RolesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RolesFindUniqueArgs<ExtArgs>>
    ): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Roles that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RolesFindUniqueOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RolesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RolesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesFindFirstArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RolesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RolesFindFirstArgs<ExtArgs>>
    ): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Roles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesFindFirstOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RolesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RolesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.roles.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.roles.findMany({ take: 10 })
     * 
     * // Only select the `rolID`
     * const rolesWithRolIDOnly = await prisma.roles.findMany({ select: { rolID: true } })
     * 
    **/
    findMany<T extends RolesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RolesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Roles.
     * @param {RolesCreateArgs} args - Arguments to create a Roles.
     * @example
     * // Create one Roles
     * const Roles = await prisma.roles.create({
     *   data: {
     *     // ... data to create a Roles
     *   }
     * })
     * 
    **/
    create<T extends RolesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RolesCreateArgs<ExtArgs>>
    ): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Roles.
     *     @param {RolesCreateManyArgs} args - Arguments to create many Roles.
     *     @example
     *     // Create many Roles
     *     const roles = await prisma.roles.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RolesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RolesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Roles.
     * @param {RolesDeleteArgs} args - Arguments to delete one Roles.
     * @example
     * // Delete one Roles
     * const Roles = await prisma.roles.delete({
     *   where: {
     *     // ... filter to delete one Roles
     *   }
     * })
     * 
    **/
    delete<T extends RolesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RolesDeleteArgs<ExtArgs>>
    ): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Roles.
     * @param {RolesUpdateArgs} args - Arguments to update one Roles.
     * @example
     * // Update one Roles
     * const roles = await prisma.roles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RolesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RolesUpdateArgs<ExtArgs>>
    ): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Roles.
     * @param {RolesDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.roles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RolesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RolesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const roles = await prisma.roles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RolesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RolesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Roles.
     * @param {RolesUpsertArgs} args - Arguments to update or create a Roles.
     * @example
     * // Update or create a Roles
     * const roles = await prisma.roles.upsert({
     *   create: {
     *     // ... data to create a Roles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Roles we want to update
     *   }
     * })
    **/
    upsert<T extends RolesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RolesUpsertArgs<ExtArgs>>
    ): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.roles.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RolesCountArgs>(
      args?: Subset<T, RolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolesAggregateArgs>(args: Subset<T, RolesAggregateArgs>): Prisma.PrismaPromise<GetRolesAggregateType<T>>

    /**
     * Group by Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolesGroupByArgs['orderBy'] }
        : { orderBy?: RolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Roles model
   */
  readonly fields: RolesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Roles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Usuarios<T extends Roles$UsuariosArgs<ExtArgs> = {}>(args?: Subset<T, Roles$UsuariosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Roles model
   */ 
  interface RolesFieldRefs {
    readonly rolID: FieldRef<"Roles", 'Int'>
    readonly nombreRol: FieldRef<"Roles", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Roles findUnique
   */
  export type RolesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where: RolesWhereUniqueInput
  }


  /**
   * Roles findUniqueOrThrow
   */
  export type RolesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where: RolesWhereUniqueInput
  }


  /**
   * Roles findFirst
   */
  export type RolesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RolesOrderByWithRelationInput | RolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }


  /**
   * Roles findFirstOrThrow
   */
  export type RolesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RolesOrderByWithRelationInput | RolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }


  /**
   * Roles findMany
   */
  export type RolesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RolesOrderByWithRelationInput | RolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }


  /**
   * Roles create
   */
  export type RolesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * The data needed to create a Roles.
     */
    data?: XOR<RolesCreateInput, RolesUncheckedCreateInput>
  }


  /**
   * Roles createMany
   */
  export type RolesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RolesCreateManyInput | RolesCreateManyInput[]
  }


  /**
   * Roles update
   */
  export type RolesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * The data needed to update a Roles.
     */
    data: XOR<RolesUpdateInput, RolesUncheckedUpdateInput>
    /**
     * Choose, which Roles to update.
     */
    where: RolesWhereUniqueInput
  }


  /**
   * Roles updateMany
   */
  export type RolesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RolesUpdateManyMutationInput, RolesUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RolesWhereInput
  }


  /**
   * Roles upsert
   */
  export type RolesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * The filter to search for the Roles to update in case it exists.
     */
    where: RolesWhereUniqueInput
    /**
     * In case the Roles found by the `where` argument doesn't exist, create a new Roles with this data.
     */
    create: XOR<RolesCreateInput, RolesUncheckedCreateInput>
    /**
     * In case the Roles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolesUpdateInput, RolesUncheckedUpdateInput>
  }


  /**
   * Roles delete
   */
  export type RolesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * Filter which Roles to delete.
     */
    where: RolesWhereUniqueInput
  }


  /**
   * Roles deleteMany
   */
  export type RolesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RolesWhereInput
  }


  /**
   * Roles.Usuarios
   */
  export type Roles$UsuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuariosInclude<ExtArgs> | null
    where?: UsuariosWhereInput
    orderBy?: UsuariosOrderByWithRelationInput | UsuariosOrderByWithRelationInput[]
    cursor?: UsuariosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsuariosScalarFieldEnum | UsuariosScalarFieldEnum[]
  }


  /**
   * Roles without action
   */
  export type RolesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RolesInclude<ExtArgs> | null
  }



  /**
   * Model Servicios
   */

  export type AggregateServicios = {
    _count: ServiciosCountAggregateOutputType | null
    _avg: ServiciosAvgAggregateOutputType | null
    _sum: ServiciosSumAggregateOutputType | null
    _min: ServiciosMinAggregateOutputType | null
    _max: ServiciosMaxAggregateOutputType | null
  }

  export type ServiciosAvgAggregateOutputType = {
    servicioID: number | null
    precio: number | null
  }

  export type ServiciosSumAggregateOutputType = {
    servicioID: number | null
    precio: number | null
  }

  export type ServiciosMinAggregateOutputType = {
    servicioID: number | null
    nombreServicio: string | null
    descripcion: string | null
    tiempoEstimado: Date | null
    precio: number | null
    rutaImagen: string | null
  }

  export type ServiciosMaxAggregateOutputType = {
    servicioID: number | null
    nombreServicio: string | null
    descripcion: string | null
    tiempoEstimado: Date | null
    precio: number | null
    rutaImagen: string | null
  }

  export type ServiciosCountAggregateOutputType = {
    servicioID: number
    nombreServicio: number
    descripcion: number
    tiempoEstimado: number
    precio: number
    rutaImagen: number
    _all: number
  }


  export type ServiciosAvgAggregateInputType = {
    servicioID?: true
    precio?: true
  }

  export type ServiciosSumAggregateInputType = {
    servicioID?: true
    precio?: true
  }

  export type ServiciosMinAggregateInputType = {
    servicioID?: true
    nombreServicio?: true
    descripcion?: true
    tiempoEstimado?: true
    precio?: true
    rutaImagen?: true
  }

  export type ServiciosMaxAggregateInputType = {
    servicioID?: true
    nombreServicio?: true
    descripcion?: true
    tiempoEstimado?: true
    precio?: true
    rutaImagen?: true
  }

  export type ServiciosCountAggregateInputType = {
    servicioID?: true
    nombreServicio?: true
    descripcion?: true
    tiempoEstimado?: true
    precio?: true
    rutaImagen?: true
    _all?: true
  }

  export type ServiciosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Servicios to aggregate.
     */
    where?: ServiciosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Servicios to fetch.
     */
    orderBy?: ServiciosOrderByWithRelationInput | ServiciosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiciosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Servicios
    **/
    _count?: true | ServiciosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiciosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiciosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiciosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiciosMaxAggregateInputType
  }

  export type GetServiciosAggregateType<T extends ServiciosAggregateArgs> = {
        [P in keyof T & keyof AggregateServicios]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServicios[P]>
      : GetScalarType<T[P], AggregateServicios[P]>
  }




  export type ServiciosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiciosWhereInput
    orderBy?: ServiciosOrderByWithAggregationInput | ServiciosOrderByWithAggregationInput[]
    by: ServiciosScalarFieldEnum[] | ServiciosScalarFieldEnum
    having?: ServiciosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiciosCountAggregateInputType | true
    _avg?: ServiciosAvgAggregateInputType
    _sum?: ServiciosSumAggregateInputType
    _min?: ServiciosMinAggregateInputType
    _max?: ServiciosMaxAggregateInputType
  }

  export type ServiciosGroupByOutputType = {
    servicioID: number
    nombreServicio: string | null
    descripcion: string | null
    tiempoEstimado: Date | null
    precio: number | null
    rutaImagen: string | null
    _count: ServiciosCountAggregateOutputType | null
    _avg: ServiciosAvgAggregateOutputType | null
    _sum: ServiciosSumAggregateOutputType | null
    _min: ServiciosMinAggregateOutputType | null
    _max: ServiciosMaxAggregateOutputType | null
  }

  type GetServiciosGroupByPayload<T extends ServiciosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiciosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiciosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiciosGroupByOutputType[P]>
            : GetScalarType<T[P], ServiciosGroupByOutputType[P]>
        }
      >
    >


  export type ServiciosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    servicioID?: boolean
    nombreServicio?: boolean
    descripcion?: boolean
    tiempoEstimado?: boolean
    precio?: boolean
    rutaImagen?: boolean
    DetallesCita?: boolean | Servicios$DetallesCitaArgs<ExtArgs>
    HistorialRecompensas?: boolean | Servicios$HistorialRecompensasArgs<ExtArgs>
    PuntosServicio?: boolean | Servicios$PuntosServicioArgs<ExtArgs>
    _count?: boolean | ServiciosCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["servicios"]>

  export type ServiciosSelectScalar = {
    servicioID?: boolean
    nombreServicio?: boolean
    descripcion?: boolean
    tiempoEstimado?: boolean
    precio?: boolean
    rutaImagen?: boolean
  }

  export type ServiciosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DetallesCita?: boolean | Servicios$DetallesCitaArgs<ExtArgs>
    HistorialRecompensas?: boolean | Servicios$HistorialRecompensasArgs<ExtArgs>
    PuntosServicio?: boolean | Servicios$PuntosServicioArgs<ExtArgs>
    _count?: boolean | ServiciosCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ServiciosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Servicios"
    objects: {
      DetallesCita: Prisma.$DetallesCitaPayload<ExtArgs>[]
      HistorialRecompensas: Prisma.$HistorialRecompensasPayload<ExtArgs>[]
      PuntosServicio: Prisma.$PuntosServicioPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      servicioID: number
      nombreServicio: string | null
      descripcion: string | null
      tiempoEstimado: Date | null
      precio: number | null
      rutaImagen: string | null
    }, ExtArgs["result"]["servicios"]>
    composites: {}
  }


  type ServiciosGetPayload<S extends boolean | null | undefined | ServiciosDefaultArgs> = $Result.GetResult<Prisma.$ServiciosPayload, S>

  type ServiciosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ServiciosFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServiciosCountAggregateInputType | true
    }

  export interface ServiciosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Servicios'], meta: { name: 'Servicios' } }
    /**
     * Find zero or one Servicios that matches the filter.
     * @param {ServiciosFindUniqueArgs} args - Arguments to find a Servicios
     * @example
     * // Get one Servicios
     * const servicios = await prisma.servicios.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ServiciosFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ServiciosFindUniqueArgs<ExtArgs>>
    ): Prisma__ServiciosClient<$Result.GetResult<Prisma.$ServiciosPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Servicios that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ServiciosFindUniqueOrThrowArgs} args - Arguments to find a Servicios
     * @example
     * // Get one Servicios
     * const servicios = await prisma.servicios.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ServiciosFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiciosFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ServiciosClient<$Result.GetResult<Prisma.$ServiciosPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Servicios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiciosFindFirstArgs} args - Arguments to find a Servicios
     * @example
     * // Get one Servicios
     * const servicios = await prisma.servicios.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ServiciosFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiciosFindFirstArgs<ExtArgs>>
    ): Prisma__ServiciosClient<$Result.GetResult<Prisma.$ServiciosPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Servicios that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiciosFindFirstOrThrowArgs} args - Arguments to find a Servicios
     * @example
     * // Get one Servicios
     * const servicios = await prisma.servicios.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ServiciosFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiciosFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ServiciosClient<$Result.GetResult<Prisma.$ServiciosPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Servicios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiciosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Servicios
     * const servicios = await prisma.servicios.findMany()
     * 
     * // Get first 10 Servicios
     * const servicios = await prisma.servicios.findMany({ take: 10 })
     * 
     * // Only select the `servicioID`
     * const serviciosWithServicioIDOnly = await prisma.servicios.findMany({ select: { servicioID: true } })
     * 
    **/
    findMany<T extends ServiciosFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiciosFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiciosPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Servicios.
     * @param {ServiciosCreateArgs} args - Arguments to create a Servicios.
     * @example
     * // Create one Servicios
     * const Servicios = await prisma.servicios.create({
     *   data: {
     *     // ... data to create a Servicios
     *   }
     * })
     * 
    **/
    create<T extends ServiciosCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ServiciosCreateArgs<ExtArgs>>
    ): Prisma__ServiciosClient<$Result.GetResult<Prisma.$ServiciosPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Servicios.
     *     @param {ServiciosCreateManyArgs} args - Arguments to create many Servicios.
     *     @example
     *     // Create many Servicios
     *     const servicios = await prisma.servicios.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ServiciosCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiciosCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Servicios.
     * @param {ServiciosDeleteArgs} args - Arguments to delete one Servicios.
     * @example
     * // Delete one Servicios
     * const Servicios = await prisma.servicios.delete({
     *   where: {
     *     // ... filter to delete one Servicios
     *   }
     * })
     * 
    **/
    delete<T extends ServiciosDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ServiciosDeleteArgs<ExtArgs>>
    ): Prisma__ServiciosClient<$Result.GetResult<Prisma.$ServiciosPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Servicios.
     * @param {ServiciosUpdateArgs} args - Arguments to update one Servicios.
     * @example
     * // Update one Servicios
     * const servicios = await prisma.servicios.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ServiciosUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ServiciosUpdateArgs<ExtArgs>>
    ): Prisma__ServiciosClient<$Result.GetResult<Prisma.$ServiciosPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Servicios.
     * @param {ServiciosDeleteManyArgs} args - Arguments to filter Servicios to delete.
     * @example
     * // Delete a few Servicios
     * const { count } = await prisma.servicios.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ServiciosDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiciosDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiciosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Servicios
     * const servicios = await prisma.servicios.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ServiciosUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ServiciosUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Servicios.
     * @param {ServiciosUpsertArgs} args - Arguments to update or create a Servicios.
     * @example
     * // Update or create a Servicios
     * const servicios = await prisma.servicios.upsert({
     *   create: {
     *     // ... data to create a Servicios
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Servicios we want to update
     *   }
     * })
    **/
    upsert<T extends ServiciosUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ServiciosUpsertArgs<ExtArgs>>
    ): Prisma__ServiciosClient<$Result.GetResult<Prisma.$ServiciosPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiciosCountArgs} args - Arguments to filter Servicios to count.
     * @example
     * // Count the number of Servicios
     * const count = await prisma.servicios.count({
     *   where: {
     *     // ... the filter for the Servicios we want to count
     *   }
     * })
    **/
    count<T extends ServiciosCountArgs>(
      args?: Subset<T, ServiciosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiciosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiciosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiciosAggregateArgs>(args: Subset<T, ServiciosAggregateArgs>): Prisma.PrismaPromise<GetServiciosAggregateType<T>>

    /**
     * Group by Servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiciosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiciosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiciosGroupByArgs['orderBy'] }
        : { orderBy?: ServiciosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiciosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiciosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Servicios model
   */
  readonly fields: ServiciosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Servicios.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiciosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    DetallesCita<T extends Servicios$DetallesCitaArgs<ExtArgs> = {}>(args?: Subset<T, Servicios$DetallesCitaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DetallesCitaPayload<ExtArgs>, T, 'findMany'> | Null>;

    HistorialRecompensas<T extends Servicios$HistorialRecompensasArgs<ExtArgs> = {}>(args?: Subset<T, Servicios$HistorialRecompensasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HistorialRecompensasPayload<ExtArgs>, T, 'findMany'> | Null>;

    PuntosServicio<T extends Servicios$PuntosServicioArgs<ExtArgs> = {}>(args?: Subset<T, Servicios$PuntosServicioArgs<ExtArgs>>): Prisma__PuntosServicioClient<$Result.GetResult<Prisma.$PuntosServicioPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Servicios model
   */ 
  interface ServiciosFieldRefs {
    readonly servicioID: FieldRef<"Servicios", 'Int'>
    readonly nombreServicio: FieldRef<"Servicios", 'String'>
    readonly descripcion: FieldRef<"Servicios", 'String'>
    readonly tiempoEstimado: FieldRef<"Servicios", 'DateTime'>
    readonly precio: FieldRef<"Servicios", 'Int'>
    readonly rutaImagen: FieldRef<"Servicios", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Servicios findUnique
   */
  export type ServiciosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicios
     */
    select?: ServiciosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiciosInclude<ExtArgs> | null
    /**
     * Filter, which Servicios to fetch.
     */
    where: ServiciosWhereUniqueInput
  }


  /**
   * Servicios findUniqueOrThrow
   */
  export type ServiciosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicios
     */
    select?: ServiciosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiciosInclude<ExtArgs> | null
    /**
     * Filter, which Servicios to fetch.
     */
    where: ServiciosWhereUniqueInput
  }


  /**
   * Servicios findFirst
   */
  export type ServiciosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicios
     */
    select?: ServiciosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiciosInclude<ExtArgs> | null
    /**
     * Filter, which Servicios to fetch.
     */
    where?: ServiciosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Servicios to fetch.
     */
    orderBy?: ServiciosOrderByWithRelationInput | ServiciosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Servicios.
     */
    cursor?: ServiciosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Servicios.
     */
    distinct?: ServiciosScalarFieldEnum | ServiciosScalarFieldEnum[]
  }


  /**
   * Servicios findFirstOrThrow
   */
  export type ServiciosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicios
     */
    select?: ServiciosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiciosInclude<ExtArgs> | null
    /**
     * Filter, which Servicios to fetch.
     */
    where?: ServiciosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Servicios to fetch.
     */
    orderBy?: ServiciosOrderByWithRelationInput | ServiciosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Servicios.
     */
    cursor?: ServiciosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Servicios.
     */
    distinct?: ServiciosScalarFieldEnum | ServiciosScalarFieldEnum[]
  }


  /**
   * Servicios findMany
   */
  export type ServiciosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicios
     */
    select?: ServiciosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiciosInclude<ExtArgs> | null
    /**
     * Filter, which Servicios to fetch.
     */
    where?: ServiciosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Servicios to fetch.
     */
    orderBy?: ServiciosOrderByWithRelationInput | ServiciosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Servicios.
     */
    cursor?: ServiciosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Servicios.
     */
    skip?: number
    distinct?: ServiciosScalarFieldEnum | ServiciosScalarFieldEnum[]
  }


  /**
   * Servicios create
   */
  export type ServiciosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicios
     */
    select?: ServiciosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiciosInclude<ExtArgs> | null
    /**
     * The data needed to create a Servicios.
     */
    data?: XOR<ServiciosCreateInput, ServiciosUncheckedCreateInput>
  }


  /**
   * Servicios createMany
   */
  export type ServiciosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Servicios.
     */
    data: ServiciosCreateManyInput | ServiciosCreateManyInput[]
  }


  /**
   * Servicios update
   */
  export type ServiciosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicios
     */
    select?: ServiciosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiciosInclude<ExtArgs> | null
    /**
     * The data needed to update a Servicios.
     */
    data: XOR<ServiciosUpdateInput, ServiciosUncheckedUpdateInput>
    /**
     * Choose, which Servicios to update.
     */
    where: ServiciosWhereUniqueInput
  }


  /**
   * Servicios updateMany
   */
  export type ServiciosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Servicios.
     */
    data: XOR<ServiciosUpdateManyMutationInput, ServiciosUncheckedUpdateManyInput>
    /**
     * Filter which Servicios to update
     */
    where?: ServiciosWhereInput
  }


  /**
   * Servicios upsert
   */
  export type ServiciosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicios
     */
    select?: ServiciosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiciosInclude<ExtArgs> | null
    /**
     * The filter to search for the Servicios to update in case it exists.
     */
    where: ServiciosWhereUniqueInput
    /**
     * In case the Servicios found by the `where` argument doesn't exist, create a new Servicios with this data.
     */
    create: XOR<ServiciosCreateInput, ServiciosUncheckedCreateInput>
    /**
     * In case the Servicios was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiciosUpdateInput, ServiciosUncheckedUpdateInput>
  }


  /**
   * Servicios delete
   */
  export type ServiciosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicios
     */
    select?: ServiciosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiciosInclude<ExtArgs> | null
    /**
     * Filter which Servicios to delete.
     */
    where: ServiciosWhereUniqueInput
  }


  /**
   * Servicios deleteMany
   */
  export type ServiciosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Servicios to delete
     */
    where?: ServiciosWhereInput
  }


  /**
   * Servicios.DetallesCita
   */
  export type Servicios$DetallesCitaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetallesCita
     */
    select?: DetallesCitaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DetallesCitaInclude<ExtArgs> | null
    where?: DetallesCitaWhereInput
    orderBy?: DetallesCitaOrderByWithRelationInput | DetallesCitaOrderByWithRelationInput[]
    cursor?: DetallesCitaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DetallesCitaScalarFieldEnum | DetallesCitaScalarFieldEnum[]
  }


  /**
   * Servicios.HistorialRecompensas
   */
  export type Servicios$HistorialRecompensasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorialRecompensas
     */
    select?: HistorialRecompensasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistorialRecompensasInclude<ExtArgs> | null
    where?: HistorialRecompensasWhereInput
    orderBy?: HistorialRecompensasOrderByWithRelationInput | HistorialRecompensasOrderByWithRelationInput[]
    cursor?: HistorialRecompensasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HistorialRecompensasScalarFieldEnum | HistorialRecompensasScalarFieldEnum[]
  }


  /**
   * Servicios.PuntosServicio
   */
  export type Servicios$PuntosServicioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PuntosServicio
     */
    select?: PuntosServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PuntosServicioInclude<ExtArgs> | null
    where?: PuntosServicioWhereInput
  }


  /**
   * Servicios without action
   */
  export type ServiciosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicios
     */
    select?: ServiciosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiciosInclude<ExtArgs> | null
  }



  /**
   * Model Usuarios
   */

  export type AggregateUsuarios = {
    _count: UsuariosCountAggregateOutputType | null
    _avg: UsuariosAvgAggregateOutputType | null
    _sum: UsuariosSumAggregateOutputType | null
    _min: UsuariosMinAggregateOutputType | null
    _max: UsuariosMaxAggregateOutputType | null
  }

  export type UsuariosAvgAggregateOutputType = {
    usuarioID: number | null
    rolID: number | null
  }

  export type UsuariosSumAggregateOutputType = {
    usuarioID: number | null
    rolID: number | null
  }

  export type UsuariosMinAggregateOutputType = {
    usuarioID: number | null
    nombre: string | null
    apellidos: string | null
    telefono: string | null
    correo: string | null
    direccion: string | null
    contra: string | null
    rolID: number | null
    estado: string | null
  }

  export type UsuariosMaxAggregateOutputType = {
    usuarioID: number | null
    nombre: string | null
    apellidos: string | null
    telefono: string | null
    correo: string | null
    direccion: string | null
    contra: string | null
    rolID: number | null
    estado: string | null
  }

  export type UsuariosCountAggregateOutputType = {
    usuarioID: number
    nombre: number
    apellidos: number
    telefono: number
    correo: number
    direccion: number
    contra: number
    rolID: number
    estado: number
    _all: number
  }


  export type UsuariosAvgAggregateInputType = {
    usuarioID?: true
    rolID?: true
  }

  export type UsuariosSumAggregateInputType = {
    usuarioID?: true
    rolID?: true
  }

  export type UsuariosMinAggregateInputType = {
    usuarioID?: true
    nombre?: true
    apellidos?: true
    telefono?: true
    correo?: true
    direccion?: true
    contra?: true
    rolID?: true
    estado?: true
  }

  export type UsuariosMaxAggregateInputType = {
    usuarioID?: true
    nombre?: true
    apellidos?: true
    telefono?: true
    correo?: true
    direccion?: true
    contra?: true
    rolID?: true
    estado?: true
  }

  export type UsuariosCountAggregateInputType = {
    usuarioID?: true
    nombre?: true
    apellidos?: true
    telefono?: true
    correo?: true
    direccion?: true
    contra?: true
    rolID?: true
    estado?: true
    _all?: true
  }

  export type UsuariosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuarios to aggregate.
     */
    where?: UsuariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuariosOrderByWithRelationInput | UsuariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsuariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Usuarios
    **/
    _count?: true | UsuariosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuariosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuariosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuariosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuariosMaxAggregateInputType
  }

  export type GetUsuariosAggregateType<T extends UsuariosAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuarios]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuarios[P]>
      : GetScalarType<T[P], AggregateUsuarios[P]>
  }




  export type UsuariosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuariosWhereInput
    orderBy?: UsuariosOrderByWithAggregationInput | UsuariosOrderByWithAggregationInput[]
    by: UsuariosScalarFieldEnum[] | UsuariosScalarFieldEnum
    having?: UsuariosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuariosCountAggregateInputType | true
    _avg?: UsuariosAvgAggregateInputType
    _sum?: UsuariosSumAggregateInputType
    _min?: UsuariosMinAggregateInputType
    _max?: UsuariosMaxAggregateInputType
  }

  export type UsuariosGroupByOutputType = {
    usuarioID: number
    nombre: string
    apellidos: string
    telefono: string | null
    correo: string
    direccion: string | null
    contra: string
    rolID: number | null
    estado: string | null
    _count: UsuariosCountAggregateOutputType | null
    _avg: UsuariosAvgAggregateOutputType | null
    _sum: UsuariosSumAggregateOutputType | null
    _min: UsuariosMinAggregateOutputType | null
    _max: UsuariosMaxAggregateOutputType | null
  }

  type GetUsuariosGroupByPayload<T extends UsuariosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuariosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuariosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuariosGroupByOutputType[P]>
            : GetScalarType<T[P], UsuariosGroupByOutputType[P]>
        }
      >
    >


  export type UsuariosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    usuarioID?: boolean
    nombre?: boolean
    apellidos?: boolean
    telefono?: boolean
    correo?: boolean
    direccion?: boolean
    contra?: boolean
    rolID?: boolean
    estado?: boolean
    ActividadCliente?: boolean | Usuarios$ActividadClienteArgs<ExtArgs>
    BitacoraCliente?: boolean | Usuarios$BitacoraClienteArgs<ExtArgs>
    BitacoraEstilista?: boolean | Usuarios$BitacoraEstilistaArgs<ExtArgs>
    BloqueoHorarios?: boolean | Usuarios$BloqueoHorariosArgs<ExtArgs>
    Citas_Citas_clienteIDToUsuarios?: boolean | Usuarios$Citas_Citas_clienteIDToUsuariosArgs<ExtArgs>
    Citas_Citas_estilistaIDToUsuarios?: boolean | Usuarios$Citas_Citas_estilistaIDToUsuariosArgs<ExtArgs>
    HistorialCitas?: boolean | Usuarios$HistorialCitasArgs<ExtArgs>
    HistorialRecompensas?: boolean | Usuarios$HistorialRecompensasArgs<ExtArgs>
    Horarios?: boolean | Usuarios$HorariosArgs<ExtArgs>
    PuntosClientes?: boolean | Usuarios$PuntosClientesArgs<ExtArgs>
    Roles?: boolean | Usuarios$RolesArgs<ExtArgs>
    _count?: boolean | UsuariosCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuarios"]>

  export type UsuariosSelectScalar = {
    usuarioID?: boolean
    nombre?: boolean
    apellidos?: boolean
    telefono?: boolean
    correo?: boolean
    direccion?: boolean
    contra?: boolean
    rolID?: boolean
    estado?: boolean
  }

  export type UsuariosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ActividadCliente?: boolean | Usuarios$ActividadClienteArgs<ExtArgs>
    BitacoraCliente?: boolean | Usuarios$BitacoraClienteArgs<ExtArgs>
    BitacoraEstilista?: boolean | Usuarios$BitacoraEstilistaArgs<ExtArgs>
    BloqueoHorarios?: boolean | Usuarios$BloqueoHorariosArgs<ExtArgs>
    Citas_Citas_clienteIDToUsuarios?: boolean | Usuarios$Citas_Citas_clienteIDToUsuariosArgs<ExtArgs>
    Citas_Citas_estilistaIDToUsuarios?: boolean | Usuarios$Citas_Citas_estilistaIDToUsuariosArgs<ExtArgs>
    HistorialCitas?: boolean | Usuarios$HistorialCitasArgs<ExtArgs>
    HistorialRecompensas?: boolean | Usuarios$HistorialRecompensasArgs<ExtArgs>
    Horarios?: boolean | Usuarios$HorariosArgs<ExtArgs>
    PuntosClientes?: boolean | Usuarios$PuntosClientesArgs<ExtArgs>
    Roles?: boolean | Usuarios$RolesArgs<ExtArgs>
    _count?: boolean | UsuariosCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $UsuariosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Usuarios"
    objects: {
      ActividadCliente: Prisma.$ActividadClientePayload<ExtArgs>[]
      BitacoraCliente: Prisma.$BitacoraClientePayload<ExtArgs>[]
      BitacoraEstilista: Prisma.$BitacoraEstilistaPayload<ExtArgs>[]
      BloqueoHorarios: Prisma.$BloqueoHorariosPayload<ExtArgs>[]
      Citas_Citas_clienteIDToUsuarios: Prisma.$CitasPayload<ExtArgs>[]
      Citas_Citas_estilistaIDToUsuarios: Prisma.$CitasPayload<ExtArgs>[]
      HistorialCitas: Prisma.$HistorialCitasPayload<ExtArgs>[]
      HistorialRecompensas: Prisma.$HistorialRecompensasPayload<ExtArgs>[]
      Horarios: Prisma.$HorariosPayload<ExtArgs>[]
      PuntosClientes: Prisma.$PuntosClientesPayload<ExtArgs>[]
      Roles: Prisma.$RolesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      usuarioID: number
      nombre: string
      apellidos: string
      telefono: string | null
      correo: string
      direccion: string | null
      contra: string
      rolID: number | null
      estado: string | null
    }, ExtArgs["result"]["usuarios"]>
    composites: {}
  }


  type UsuariosGetPayload<S extends boolean | null | undefined | UsuariosDefaultArgs> = $Result.GetResult<Prisma.$UsuariosPayload, S>

  type UsuariosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UsuariosFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsuariosCountAggregateInputType | true
    }

  export interface UsuariosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Usuarios'], meta: { name: 'Usuarios' } }
    /**
     * Find zero or one Usuarios that matches the filter.
     * @param {UsuariosFindUniqueArgs} args - Arguments to find a Usuarios
     * @example
     * // Get one Usuarios
     * const usuarios = await prisma.usuarios.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UsuariosFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UsuariosFindUniqueArgs<ExtArgs>>
    ): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Usuarios that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UsuariosFindUniqueOrThrowArgs} args - Arguments to find a Usuarios
     * @example
     * // Get one Usuarios
     * const usuarios = await prisma.usuarios.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UsuariosFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UsuariosFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuariosFindFirstArgs} args - Arguments to find a Usuarios
     * @example
     * // Get one Usuarios
     * const usuarios = await prisma.usuarios.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UsuariosFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UsuariosFindFirstArgs<ExtArgs>>
    ): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Usuarios that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuariosFindFirstOrThrowArgs} args - Arguments to find a Usuarios
     * @example
     * // Get one Usuarios
     * const usuarios = await prisma.usuarios.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UsuariosFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UsuariosFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuariosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuarios.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuarios.findMany({ take: 10 })
     * 
     * // Only select the `usuarioID`
     * const usuariosWithUsuarioIDOnly = await prisma.usuarios.findMany({ select: { usuarioID: true } })
     * 
    **/
    findMany<T extends UsuariosFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UsuariosFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Usuarios.
     * @param {UsuariosCreateArgs} args - Arguments to create a Usuarios.
     * @example
     * // Create one Usuarios
     * const Usuarios = await prisma.usuarios.create({
     *   data: {
     *     // ... data to create a Usuarios
     *   }
     * })
     * 
    **/
    create<T extends UsuariosCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UsuariosCreateArgs<ExtArgs>>
    ): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Usuarios.
     *     @param {UsuariosCreateManyArgs} args - Arguments to create many Usuarios.
     *     @example
     *     // Create many Usuarios
     *     const usuarios = await prisma.usuarios.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UsuariosCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UsuariosCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Usuarios.
     * @param {UsuariosDeleteArgs} args - Arguments to delete one Usuarios.
     * @example
     * // Delete one Usuarios
     * const Usuarios = await prisma.usuarios.delete({
     *   where: {
     *     // ... filter to delete one Usuarios
     *   }
     * })
     * 
    **/
    delete<T extends UsuariosDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UsuariosDeleteArgs<ExtArgs>>
    ): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Usuarios.
     * @param {UsuariosUpdateArgs} args - Arguments to update one Usuarios.
     * @example
     * // Update one Usuarios
     * const usuarios = await prisma.usuarios.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UsuariosUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UsuariosUpdateArgs<ExtArgs>>
    ): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Usuarios.
     * @param {UsuariosDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuarios.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UsuariosDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UsuariosDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuariosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuarios = await prisma.usuarios.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UsuariosUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UsuariosUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Usuarios.
     * @param {UsuariosUpsertArgs} args - Arguments to update or create a Usuarios.
     * @example
     * // Update or create a Usuarios
     * const usuarios = await prisma.usuarios.upsert({
     *   create: {
     *     // ... data to create a Usuarios
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuarios we want to update
     *   }
     * })
    **/
    upsert<T extends UsuariosUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UsuariosUpsertArgs<ExtArgs>>
    ): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuariosCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuarios.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends UsuariosCountArgs>(
      args?: Subset<T, UsuariosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuariosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuariosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuariosAggregateArgs>(args: Subset<T, UsuariosAggregateArgs>): Prisma.PrismaPromise<GetUsuariosAggregateType<T>>

    /**
     * Group by Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuariosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuariosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuariosGroupByArgs['orderBy'] }
        : { orderBy?: UsuariosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuariosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuariosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Usuarios model
   */
  readonly fields: UsuariosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Usuarios.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsuariosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    ActividadCliente<T extends Usuarios$ActividadClienteArgs<ExtArgs> = {}>(args?: Subset<T, Usuarios$ActividadClienteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActividadClientePayload<ExtArgs>, T, 'findMany'> | Null>;

    BitacoraCliente<T extends Usuarios$BitacoraClienteArgs<ExtArgs> = {}>(args?: Subset<T, Usuarios$BitacoraClienteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BitacoraClientePayload<ExtArgs>, T, 'findMany'> | Null>;

    BitacoraEstilista<T extends Usuarios$BitacoraEstilistaArgs<ExtArgs> = {}>(args?: Subset<T, Usuarios$BitacoraEstilistaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BitacoraEstilistaPayload<ExtArgs>, T, 'findMany'> | Null>;

    BloqueoHorarios<T extends Usuarios$BloqueoHorariosArgs<ExtArgs> = {}>(args?: Subset<T, Usuarios$BloqueoHorariosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BloqueoHorariosPayload<ExtArgs>, T, 'findMany'> | Null>;

    Citas_Citas_clienteIDToUsuarios<T extends Usuarios$Citas_Citas_clienteIDToUsuariosArgs<ExtArgs> = {}>(args?: Subset<T, Usuarios$Citas_Citas_clienteIDToUsuariosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CitasPayload<ExtArgs>, T, 'findMany'> | Null>;

    Citas_Citas_estilistaIDToUsuarios<T extends Usuarios$Citas_Citas_estilistaIDToUsuariosArgs<ExtArgs> = {}>(args?: Subset<T, Usuarios$Citas_Citas_estilistaIDToUsuariosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CitasPayload<ExtArgs>, T, 'findMany'> | Null>;

    HistorialCitas<T extends Usuarios$HistorialCitasArgs<ExtArgs> = {}>(args?: Subset<T, Usuarios$HistorialCitasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HistorialCitasPayload<ExtArgs>, T, 'findMany'> | Null>;

    HistorialRecompensas<T extends Usuarios$HistorialRecompensasArgs<ExtArgs> = {}>(args?: Subset<T, Usuarios$HistorialRecompensasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HistorialRecompensasPayload<ExtArgs>, T, 'findMany'> | Null>;

    Horarios<T extends Usuarios$HorariosArgs<ExtArgs> = {}>(args?: Subset<T, Usuarios$HorariosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HorariosPayload<ExtArgs>, T, 'findMany'> | Null>;

    PuntosClientes<T extends Usuarios$PuntosClientesArgs<ExtArgs> = {}>(args?: Subset<T, Usuarios$PuntosClientesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PuntosClientesPayload<ExtArgs>, T, 'findMany'> | Null>;

    Roles<T extends Usuarios$RolesArgs<ExtArgs> = {}>(args?: Subset<T, Usuarios$RolesArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Usuarios model
   */ 
  interface UsuariosFieldRefs {
    readonly usuarioID: FieldRef<"Usuarios", 'Int'>
    readonly nombre: FieldRef<"Usuarios", 'String'>
    readonly apellidos: FieldRef<"Usuarios", 'String'>
    readonly telefono: FieldRef<"Usuarios", 'String'>
    readonly correo: FieldRef<"Usuarios", 'String'>
    readonly direccion: FieldRef<"Usuarios", 'String'>
    readonly contra: FieldRef<"Usuarios", 'String'>
    readonly rolID: FieldRef<"Usuarios", 'Int'>
    readonly estado: FieldRef<"Usuarios", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Usuarios findUnique
   */
  export type UsuariosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuariosInclude<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where: UsuariosWhereUniqueInput
  }


  /**
   * Usuarios findUniqueOrThrow
   */
  export type UsuariosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuariosInclude<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where: UsuariosWhereUniqueInput
  }


  /**
   * Usuarios findFirst
   */
  export type UsuariosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuariosInclude<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where?: UsuariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuariosOrderByWithRelationInput | UsuariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuariosScalarFieldEnum | UsuariosScalarFieldEnum[]
  }


  /**
   * Usuarios findFirstOrThrow
   */
  export type UsuariosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuariosInclude<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where?: UsuariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuariosOrderByWithRelationInput | UsuariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuariosScalarFieldEnum | UsuariosScalarFieldEnum[]
  }


  /**
   * Usuarios findMany
   */
  export type UsuariosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuariosInclude<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where?: UsuariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuariosOrderByWithRelationInput | UsuariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Usuarios.
     */
    cursor?: UsuariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    distinct?: UsuariosScalarFieldEnum | UsuariosScalarFieldEnum[]
  }


  /**
   * Usuarios create
   */
  export type UsuariosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuariosInclude<ExtArgs> | null
    /**
     * The data needed to create a Usuarios.
     */
    data: XOR<UsuariosCreateInput, UsuariosUncheckedCreateInput>
  }


  /**
   * Usuarios createMany
   */
  export type UsuariosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Usuarios.
     */
    data: UsuariosCreateManyInput | UsuariosCreateManyInput[]
  }


  /**
   * Usuarios update
   */
  export type UsuariosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuariosInclude<ExtArgs> | null
    /**
     * The data needed to update a Usuarios.
     */
    data: XOR<UsuariosUpdateInput, UsuariosUncheckedUpdateInput>
    /**
     * Choose, which Usuarios to update.
     */
    where: UsuariosWhereUniqueInput
  }


  /**
   * Usuarios updateMany
   */
  export type UsuariosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Usuarios.
     */
    data: XOR<UsuariosUpdateManyMutationInput, UsuariosUncheckedUpdateManyInput>
    /**
     * Filter which Usuarios to update
     */
    where?: UsuariosWhereInput
  }


  /**
   * Usuarios upsert
   */
  export type UsuariosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuariosInclude<ExtArgs> | null
    /**
     * The filter to search for the Usuarios to update in case it exists.
     */
    where: UsuariosWhereUniqueInput
    /**
     * In case the Usuarios found by the `where` argument doesn't exist, create a new Usuarios with this data.
     */
    create: XOR<UsuariosCreateInput, UsuariosUncheckedCreateInput>
    /**
     * In case the Usuarios was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsuariosUpdateInput, UsuariosUncheckedUpdateInput>
  }


  /**
   * Usuarios delete
   */
  export type UsuariosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuariosInclude<ExtArgs> | null
    /**
     * Filter which Usuarios to delete.
     */
    where: UsuariosWhereUniqueInput
  }


  /**
   * Usuarios deleteMany
   */
  export type UsuariosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuarios to delete
     */
    where?: UsuariosWhereInput
  }


  /**
   * Usuarios.ActividadCliente
   */
  export type Usuarios$ActividadClienteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActividadCliente
     */
    select?: ActividadClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActividadClienteInclude<ExtArgs> | null
    where?: ActividadClienteWhereInput
    orderBy?: ActividadClienteOrderByWithRelationInput | ActividadClienteOrderByWithRelationInput[]
    cursor?: ActividadClienteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActividadClienteScalarFieldEnum | ActividadClienteScalarFieldEnum[]
  }


  /**
   * Usuarios.BitacoraCliente
   */
  export type Usuarios$BitacoraClienteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BitacoraCliente
     */
    select?: BitacoraClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BitacoraClienteInclude<ExtArgs> | null
    where?: BitacoraClienteWhereInput
    orderBy?: BitacoraClienteOrderByWithRelationInput | BitacoraClienteOrderByWithRelationInput[]
    cursor?: BitacoraClienteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BitacoraClienteScalarFieldEnum | BitacoraClienteScalarFieldEnum[]
  }


  /**
   * Usuarios.BitacoraEstilista
   */
  export type Usuarios$BitacoraEstilistaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BitacoraEstilista
     */
    select?: BitacoraEstilistaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BitacoraEstilistaInclude<ExtArgs> | null
    where?: BitacoraEstilistaWhereInput
    orderBy?: BitacoraEstilistaOrderByWithRelationInput | BitacoraEstilistaOrderByWithRelationInput[]
    cursor?: BitacoraEstilistaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BitacoraEstilistaScalarFieldEnum | BitacoraEstilistaScalarFieldEnum[]
  }


  /**
   * Usuarios.BloqueoHorarios
   */
  export type Usuarios$BloqueoHorariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BloqueoHorarios
     */
    select?: BloqueoHorariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BloqueoHorariosInclude<ExtArgs> | null
    where?: BloqueoHorariosWhereInput
    orderBy?: BloqueoHorariosOrderByWithRelationInput | BloqueoHorariosOrderByWithRelationInput[]
    cursor?: BloqueoHorariosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BloqueoHorariosScalarFieldEnum | BloqueoHorariosScalarFieldEnum[]
  }


  /**
   * Usuarios.Citas_Citas_clienteIDToUsuarios
   */
  export type Usuarios$Citas_Citas_clienteIDToUsuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Citas
     */
    select?: CitasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CitasInclude<ExtArgs> | null
    where?: CitasWhereInput
    orderBy?: CitasOrderByWithRelationInput | CitasOrderByWithRelationInput[]
    cursor?: CitasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CitasScalarFieldEnum | CitasScalarFieldEnum[]
  }


  /**
   * Usuarios.Citas_Citas_estilistaIDToUsuarios
   */
  export type Usuarios$Citas_Citas_estilistaIDToUsuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Citas
     */
    select?: CitasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CitasInclude<ExtArgs> | null
    where?: CitasWhereInput
    orderBy?: CitasOrderByWithRelationInput | CitasOrderByWithRelationInput[]
    cursor?: CitasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CitasScalarFieldEnum | CitasScalarFieldEnum[]
  }


  /**
   * Usuarios.HistorialCitas
   */
  export type Usuarios$HistorialCitasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorialCitas
     */
    select?: HistorialCitasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistorialCitasInclude<ExtArgs> | null
    where?: HistorialCitasWhereInput
    orderBy?: HistorialCitasOrderByWithRelationInput | HistorialCitasOrderByWithRelationInput[]
    cursor?: HistorialCitasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HistorialCitasScalarFieldEnum | HistorialCitasScalarFieldEnum[]
  }


  /**
   * Usuarios.HistorialRecompensas
   */
  export type Usuarios$HistorialRecompensasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorialRecompensas
     */
    select?: HistorialRecompensasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistorialRecompensasInclude<ExtArgs> | null
    where?: HistorialRecompensasWhereInput
    orderBy?: HistorialRecompensasOrderByWithRelationInput | HistorialRecompensasOrderByWithRelationInput[]
    cursor?: HistorialRecompensasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HistorialRecompensasScalarFieldEnum | HistorialRecompensasScalarFieldEnum[]
  }


  /**
   * Usuarios.Horarios
   */
  export type Usuarios$HorariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Horarios
     */
    select?: HorariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HorariosInclude<ExtArgs> | null
    where?: HorariosWhereInput
    orderBy?: HorariosOrderByWithRelationInput | HorariosOrderByWithRelationInput[]
    cursor?: HorariosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HorariosScalarFieldEnum | HorariosScalarFieldEnum[]
  }


  /**
   * Usuarios.PuntosClientes
   */
  export type Usuarios$PuntosClientesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PuntosClientes
     */
    select?: PuntosClientesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PuntosClientesInclude<ExtArgs> | null
    where?: PuntosClientesWhereInput
    orderBy?: PuntosClientesOrderByWithRelationInput | PuntosClientesOrderByWithRelationInput[]
    cursor?: PuntosClientesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PuntosClientesScalarFieldEnum | PuntosClientesScalarFieldEnum[]
  }


  /**
   * Usuarios.Roles
   */
  export type Usuarios$RolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RolesInclude<ExtArgs> | null
    where?: RolesWhereInput
  }


  /**
   * Usuarios without action
   */
  export type UsuariosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuariosInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable',
    Snapshot: 'Snapshot'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ActividadClienteScalarFieldEnum: {
    actividadID: 'actividadID',
    clienteID: 'clienteID',
    ultimaConexion: 'ultimaConexion',
    ultimaCitaID: 'ultimaCitaID'
  };

  export type ActividadClienteScalarFieldEnum = (typeof ActividadClienteScalarFieldEnum)[keyof typeof ActividadClienteScalarFieldEnum]


  export const BitacoraClienteScalarFieldEnum: {
    bitacoraID: 'bitacoraID',
    clienteID: 'clienteID',
    fechaRegistro: 'fechaRegistro'
  };

  export type BitacoraClienteScalarFieldEnum = (typeof BitacoraClienteScalarFieldEnum)[keyof typeof BitacoraClienteScalarFieldEnum]


  export const BitacoraEstilistaScalarFieldEnum: {
    bitacoraID: 'bitacoraID',
    estilistaID: 'estilistaID',
    fechaIngreso: 'fechaIngreso',
    fechaSalida: 'fechaSalida'
  };

  export type BitacoraEstilistaScalarFieldEnum = (typeof BitacoraEstilistaScalarFieldEnum)[keyof typeof BitacoraEstilistaScalarFieldEnum]


  export const BloqueoHorariosScalarFieldEnum: {
    bloqueoID: 'bloqueoID',
    estilistaID: 'estilistaID',
    dia: 'dia',
    horaInicio: 'horaInicio',
    horaFinal: 'horaFinal',
    motivo: 'motivo'
  };

  export type BloqueoHorariosScalarFieldEnum = (typeof BloqueoHorariosScalarFieldEnum)[keyof typeof BloqueoHorariosScalarFieldEnum]


  export const CitasScalarFieldEnum: {
    citaID: 'citaID',
    clienteID: 'clienteID',
    estilistaID: 'estilistaID',
    comentarios: 'comentarios',
    estadoID: 'estadoID'
  };

  export type CitasScalarFieldEnum = (typeof CitasScalarFieldEnum)[keyof typeof CitasScalarFieldEnum]


  export const DetallesCitaScalarFieldEnum: {
    detalleID: 'detalleID',
    citaID: 'citaID',
    servicioID: 'servicioID'
  };

  export type DetallesCitaScalarFieldEnum = (typeof DetallesCitaScalarFieldEnum)[keyof typeof DetallesCitaScalarFieldEnum]


  export const EstadoCitaScalarFieldEnum: {
    estadoID: 'estadoID',
    nombre: 'nombre'
  };

  export type EstadoCitaScalarFieldEnum = (typeof EstadoCitaScalarFieldEnum)[keyof typeof EstadoCitaScalarFieldEnum]


  export const HistorialCitasScalarFieldEnum: {
    historialCitasID: 'historialCitasID',
    clienteID: 'clienteID',
    citaID: 'citaID'
  };

  export type HistorialCitasScalarFieldEnum = (typeof HistorialCitasScalarFieldEnum)[keyof typeof HistorialCitasScalarFieldEnum]


  export const HistorialRecompensasScalarFieldEnum: {
    historialID: 'historialID',
    clienteID: 'clienteID',
    servicioID: 'servicioID',
    puntosCanjeados: 'puntosCanjeados',
    fecha: 'fecha'
  };

  export type HistorialRecompensasScalarFieldEnum = (typeof HistorialRecompensasScalarFieldEnum)[keyof typeof HistorialRecompensasScalarFieldEnum]


  export const HorariosScalarFieldEnum: {
    horariosID: 'horariosID',
    estilistaID: 'estilistaID',
    diaSemana: 'diaSemana',
    horaInicio: 'horaInicio',
    horaFinal: 'horaFinal'
  };

  export type HorariosScalarFieldEnum = (typeof HorariosScalarFieldEnum)[keyof typeof HorariosScalarFieldEnum]


  export const HorariosReservadosScalarFieldEnum: {
    citaID: 'citaID',
    dia: 'dia',
    hora_inicio: 'hora_inicio',
    hora_fin: 'hora_fin'
  };

  export type HorariosReservadosScalarFieldEnum = (typeof HorariosReservadosScalarFieldEnum)[keyof typeof HorariosReservadosScalarFieldEnum]


  export const PuntosClientesScalarFieldEnum: {
    puntosID: 'puntosID',
    clienteID: 'clienteID',
    puntosAcumulados: 'puntosAcumulados',
    puntosCanjeados: 'puntosCanjeados'
  };

  export type PuntosClientesScalarFieldEnum = (typeof PuntosClientesScalarFieldEnum)[keyof typeof PuntosClientesScalarFieldEnum]


  export const PuntosServicioScalarFieldEnum: {
    servicioID: 'servicioID',
    puntosGenerados: 'puntosGenerados'
  };

  export type PuntosServicioScalarFieldEnum = (typeof PuntosServicioScalarFieldEnum)[keyof typeof PuntosServicioScalarFieldEnum]


  export const RolesScalarFieldEnum: {
    rolID: 'rolID',
    nombreRol: 'nombreRol'
  };

  export type RolesScalarFieldEnum = (typeof RolesScalarFieldEnum)[keyof typeof RolesScalarFieldEnum]


  export const ServiciosScalarFieldEnum: {
    servicioID: 'servicioID',
    nombreServicio: 'nombreServicio',
    descripcion: 'descripcion',
    tiempoEstimado: 'tiempoEstimado',
    precio: 'precio',
    rutaImagen: 'rutaImagen'
  };

  export type ServiciosScalarFieldEnum = (typeof ServiciosScalarFieldEnum)[keyof typeof ServiciosScalarFieldEnum]


  export const UsuariosScalarFieldEnum: {
    usuarioID: 'usuarioID',
    nombre: 'nombre',
    apellidos: 'apellidos',
    telefono: 'telefono',
    correo: 'correo',
    direccion: 'direccion',
    contra: 'contra',
    rolID: 'rolID',
    estado: 'estado'
  };

  export type UsuariosScalarFieldEnum = (typeof UsuariosScalarFieldEnum)[keyof typeof UsuariosScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type ActividadClienteWhereInput = {
    AND?: ActividadClienteWhereInput | ActividadClienteWhereInput[]
    OR?: ActividadClienteWhereInput[]
    NOT?: ActividadClienteWhereInput | ActividadClienteWhereInput[]
    actividadID?: IntFilter<"ActividadCliente"> | number
    clienteID?: IntNullableFilter<"ActividadCliente"> | number | null
    ultimaConexion?: DateTimeNullableFilter<"ActividadCliente"> | Date | string | null
    ultimaCitaID?: IntNullableFilter<"ActividadCliente"> | number | null
    Usuarios?: XOR<UsuariosNullableRelationFilter, UsuariosWhereInput> | null
    Citas?: XOR<CitasNullableRelationFilter, CitasWhereInput> | null
  }

  export type ActividadClienteOrderByWithRelationInput = {
    actividadID?: SortOrder
    clienteID?: SortOrderInput | SortOrder
    ultimaConexion?: SortOrderInput | SortOrder
    ultimaCitaID?: SortOrderInput | SortOrder
    Usuarios?: UsuariosOrderByWithRelationInput
    Citas?: CitasOrderByWithRelationInput
  }

  export type ActividadClienteWhereUniqueInput = Prisma.AtLeast<{
    actividadID?: number
    AND?: ActividadClienteWhereInput | ActividadClienteWhereInput[]
    OR?: ActividadClienteWhereInput[]
    NOT?: ActividadClienteWhereInput | ActividadClienteWhereInput[]
    clienteID?: IntNullableFilter<"ActividadCliente"> | number | null
    ultimaConexion?: DateTimeNullableFilter<"ActividadCliente"> | Date | string | null
    ultimaCitaID?: IntNullableFilter<"ActividadCliente"> | number | null
    Usuarios?: XOR<UsuariosNullableRelationFilter, UsuariosWhereInput> | null
    Citas?: XOR<CitasNullableRelationFilter, CitasWhereInput> | null
  }, "actividadID">

  export type ActividadClienteOrderByWithAggregationInput = {
    actividadID?: SortOrder
    clienteID?: SortOrderInput | SortOrder
    ultimaConexion?: SortOrderInput | SortOrder
    ultimaCitaID?: SortOrderInput | SortOrder
    _count?: ActividadClienteCountOrderByAggregateInput
    _avg?: ActividadClienteAvgOrderByAggregateInput
    _max?: ActividadClienteMaxOrderByAggregateInput
    _min?: ActividadClienteMinOrderByAggregateInput
    _sum?: ActividadClienteSumOrderByAggregateInput
  }

  export type ActividadClienteScalarWhereWithAggregatesInput = {
    AND?: ActividadClienteScalarWhereWithAggregatesInput | ActividadClienteScalarWhereWithAggregatesInput[]
    OR?: ActividadClienteScalarWhereWithAggregatesInput[]
    NOT?: ActividadClienteScalarWhereWithAggregatesInput | ActividadClienteScalarWhereWithAggregatesInput[]
    actividadID?: IntWithAggregatesFilter<"ActividadCliente"> | number
    clienteID?: IntNullableWithAggregatesFilter<"ActividadCliente"> | number | null
    ultimaConexion?: DateTimeNullableWithAggregatesFilter<"ActividadCliente"> | Date | string | null
    ultimaCitaID?: IntNullableWithAggregatesFilter<"ActividadCliente"> | number | null
  }

  export type BitacoraClienteWhereInput = {
    AND?: BitacoraClienteWhereInput | BitacoraClienteWhereInput[]
    OR?: BitacoraClienteWhereInput[]
    NOT?: BitacoraClienteWhereInput | BitacoraClienteWhereInput[]
    bitacoraID?: IntFilter<"BitacoraCliente"> | number
    clienteID?: IntNullableFilter<"BitacoraCliente"> | number | null
    fechaRegistro?: DateTimeNullableFilter<"BitacoraCliente"> | Date | string | null
    Usuarios?: XOR<UsuariosNullableRelationFilter, UsuariosWhereInput> | null
  }

  export type BitacoraClienteOrderByWithRelationInput = {
    bitacoraID?: SortOrder
    clienteID?: SortOrderInput | SortOrder
    fechaRegistro?: SortOrderInput | SortOrder
    Usuarios?: UsuariosOrderByWithRelationInput
  }

  export type BitacoraClienteWhereUniqueInput = Prisma.AtLeast<{
    bitacoraID?: number
    AND?: BitacoraClienteWhereInput | BitacoraClienteWhereInput[]
    OR?: BitacoraClienteWhereInput[]
    NOT?: BitacoraClienteWhereInput | BitacoraClienteWhereInput[]
    clienteID?: IntNullableFilter<"BitacoraCliente"> | number | null
    fechaRegistro?: DateTimeNullableFilter<"BitacoraCliente"> | Date | string | null
    Usuarios?: XOR<UsuariosNullableRelationFilter, UsuariosWhereInput> | null
  }, "bitacoraID">

  export type BitacoraClienteOrderByWithAggregationInput = {
    bitacoraID?: SortOrder
    clienteID?: SortOrderInput | SortOrder
    fechaRegistro?: SortOrderInput | SortOrder
    _count?: BitacoraClienteCountOrderByAggregateInput
    _avg?: BitacoraClienteAvgOrderByAggregateInput
    _max?: BitacoraClienteMaxOrderByAggregateInput
    _min?: BitacoraClienteMinOrderByAggregateInput
    _sum?: BitacoraClienteSumOrderByAggregateInput
  }

  export type BitacoraClienteScalarWhereWithAggregatesInput = {
    AND?: BitacoraClienteScalarWhereWithAggregatesInput | BitacoraClienteScalarWhereWithAggregatesInput[]
    OR?: BitacoraClienteScalarWhereWithAggregatesInput[]
    NOT?: BitacoraClienteScalarWhereWithAggregatesInput | BitacoraClienteScalarWhereWithAggregatesInput[]
    bitacoraID?: IntWithAggregatesFilter<"BitacoraCliente"> | number
    clienteID?: IntNullableWithAggregatesFilter<"BitacoraCliente"> | number | null
    fechaRegistro?: DateTimeNullableWithAggregatesFilter<"BitacoraCliente"> | Date | string | null
  }

  export type BitacoraEstilistaWhereInput = {
    AND?: BitacoraEstilistaWhereInput | BitacoraEstilistaWhereInput[]
    OR?: BitacoraEstilistaWhereInput[]
    NOT?: BitacoraEstilistaWhereInput | BitacoraEstilistaWhereInput[]
    bitacoraID?: IntFilter<"BitacoraEstilista"> | number
    estilistaID?: IntNullableFilter<"BitacoraEstilista"> | number | null
    fechaIngreso?: DateTimeNullableFilter<"BitacoraEstilista"> | Date | string | null
    fechaSalida?: DateTimeNullableFilter<"BitacoraEstilista"> | Date | string | null
    Usuarios?: XOR<UsuariosNullableRelationFilter, UsuariosWhereInput> | null
  }

  export type BitacoraEstilistaOrderByWithRelationInput = {
    bitacoraID?: SortOrder
    estilistaID?: SortOrderInput | SortOrder
    fechaIngreso?: SortOrderInput | SortOrder
    fechaSalida?: SortOrderInput | SortOrder
    Usuarios?: UsuariosOrderByWithRelationInput
  }

  export type BitacoraEstilistaWhereUniqueInput = Prisma.AtLeast<{
    bitacoraID?: number
    AND?: BitacoraEstilistaWhereInput | BitacoraEstilistaWhereInput[]
    OR?: BitacoraEstilistaWhereInput[]
    NOT?: BitacoraEstilistaWhereInput | BitacoraEstilistaWhereInput[]
    estilistaID?: IntNullableFilter<"BitacoraEstilista"> | number | null
    fechaIngreso?: DateTimeNullableFilter<"BitacoraEstilista"> | Date | string | null
    fechaSalida?: DateTimeNullableFilter<"BitacoraEstilista"> | Date | string | null
    Usuarios?: XOR<UsuariosNullableRelationFilter, UsuariosWhereInput> | null
  }, "bitacoraID">

  export type BitacoraEstilistaOrderByWithAggregationInput = {
    bitacoraID?: SortOrder
    estilistaID?: SortOrderInput | SortOrder
    fechaIngreso?: SortOrderInput | SortOrder
    fechaSalida?: SortOrderInput | SortOrder
    _count?: BitacoraEstilistaCountOrderByAggregateInput
    _avg?: BitacoraEstilistaAvgOrderByAggregateInput
    _max?: BitacoraEstilistaMaxOrderByAggregateInput
    _min?: BitacoraEstilistaMinOrderByAggregateInput
    _sum?: BitacoraEstilistaSumOrderByAggregateInput
  }

  export type BitacoraEstilistaScalarWhereWithAggregatesInput = {
    AND?: BitacoraEstilistaScalarWhereWithAggregatesInput | BitacoraEstilistaScalarWhereWithAggregatesInput[]
    OR?: BitacoraEstilistaScalarWhereWithAggregatesInput[]
    NOT?: BitacoraEstilistaScalarWhereWithAggregatesInput | BitacoraEstilistaScalarWhereWithAggregatesInput[]
    bitacoraID?: IntWithAggregatesFilter<"BitacoraEstilista"> | number
    estilistaID?: IntNullableWithAggregatesFilter<"BitacoraEstilista"> | number | null
    fechaIngreso?: DateTimeNullableWithAggregatesFilter<"BitacoraEstilista"> | Date | string | null
    fechaSalida?: DateTimeNullableWithAggregatesFilter<"BitacoraEstilista"> | Date | string | null
  }

  export type BloqueoHorariosWhereInput = {
    AND?: BloqueoHorariosWhereInput | BloqueoHorariosWhereInput[]
    OR?: BloqueoHorariosWhereInput[]
    NOT?: BloqueoHorariosWhereInput | BloqueoHorariosWhereInput[]
    bloqueoID?: IntFilter<"BloqueoHorarios"> | number
    estilistaID?: IntNullableFilter<"BloqueoHorarios"> | number | null
    dia?: StringNullableFilter<"BloqueoHorarios"> | string | null
    horaInicio?: DateTimeNullableFilter<"BloqueoHorarios"> | Date | string | null
    horaFinal?: DateTimeNullableFilter<"BloqueoHorarios"> | Date | string | null
    motivo?: StringNullableFilter<"BloqueoHorarios"> | string | null
    Usuarios?: XOR<UsuariosNullableRelationFilter, UsuariosWhereInput> | null
  }

  export type BloqueoHorariosOrderByWithRelationInput = {
    bloqueoID?: SortOrder
    estilistaID?: SortOrderInput | SortOrder
    dia?: SortOrderInput | SortOrder
    horaInicio?: SortOrderInput | SortOrder
    horaFinal?: SortOrderInput | SortOrder
    motivo?: SortOrderInput | SortOrder
    Usuarios?: UsuariosOrderByWithRelationInput
  }

  export type BloqueoHorariosWhereUniqueInput = Prisma.AtLeast<{
    bloqueoID?: number
    AND?: BloqueoHorariosWhereInput | BloqueoHorariosWhereInput[]
    OR?: BloqueoHorariosWhereInput[]
    NOT?: BloqueoHorariosWhereInput | BloqueoHorariosWhereInput[]
    estilistaID?: IntNullableFilter<"BloqueoHorarios"> | number | null
    dia?: StringNullableFilter<"BloqueoHorarios"> | string | null
    horaInicio?: DateTimeNullableFilter<"BloqueoHorarios"> | Date | string | null
    horaFinal?: DateTimeNullableFilter<"BloqueoHorarios"> | Date | string | null
    motivo?: StringNullableFilter<"BloqueoHorarios"> | string | null
    Usuarios?: XOR<UsuariosNullableRelationFilter, UsuariosWhereInput> | null
  }, "bloqueoID">

  export type BloqueoHorariosOrderByWithAggregationInput = {
    bloqueoID?: SortOrder
    estilistaID?: SortOrderInput | SortOrder
    dia?: SortOrderInput | SortOrder
    horaInicio?: SortOrderInput | SortOrder
    horaFinal?: SortOrderInput | SortOrder
    motivo?: SortOrderInput | SortOrder
    _count?: BloqueoHorariosCountOrderByAggregateInput
    _avg?: BloqueoHorariosAvgOrderByAggregateInput
    _max?: BloqueoHorariosMaxOrderByAggregateInput
    _min?: BloqueoHorariosMinOrderByAggregateInput
    _sum?: BloqueoHorariosSumOrderByAggregateInput
  }

  export type BloqueoHorariosScalarWhereWithAggregatesInput = {
    AND?: BloqueoHorariosScalarWhereWithAggregatesInput | BloqueoHorariosScalarWhereWithAggregatesInput[]
    OR?: BloqueoHorariosScalarWhereWithAggregatesInput[]
    NOT?: BloqueoHorariosScalarWhereWithAggregatesInput | BloqueoHorariosScalarWhereWithAggregatesInput[]
    bloqueoID?: IntWithAggregatesFilter<"BloqueoHorarios"> | number
    estilistaID?: IntNullableWithAggregatesFilter<"BloqueoHorarios"> | number | null
    dia?: StringNullableWithAggregatesFilter<"BloqueoHorarios"> | string | null
    horaInicio?: DateTimeNullableWithAggregatesFilter<"BloqueoHorarios"> | Date | string | null
    horaFinal?: DateTimeNullableWithAggregatesFilter<"BloqueoHorarios"> | Date | string | null
    motivo?: StringNullableWithAggregatesFilter<"BloqueoHorarios"> | string | null
  }

  export type CitasWhereInput = {
    AND?: CitasWhereInput | CitasWhereInput[]
    OR?: CitasWhereInput[]
    NOT?: CitasWhereInput | CitasWhereInput[]
    citaID?: IntFilter<"Citas"> | number
    clienteID?: IntNullableFilter<"Citas"> | number | null
    estilistaID?: IntNullableFilter<"Citas"> | number | null
    comentarios?: StringNullableFilter<"Citas"> | string | null
    estadoID?: IntNullableFilter<"Citas"> | number | null
    ActividadCliente?: ActividadClienteListRelationFilter
    Usuarios_Citas_clienteIDToUsuarios?: XOR<UsuariosNullableRelationFilter, UsuariosWhereInput> | null
    EstadoCita?: XOR<EstadoCitaNullableRelationFilter, EstadoCitaWhereInput> | null
    Usuarios_Citas_estilistaIDToUsuarios?: XOR<UsuariosNullableRelationFilter, UsuariosWhereInput> | null
    DetallesCita?: DetallesCitaListRelationFilter
    HistorialCitas?: HistorialCitasListRelationFilter
    HorariosReservados?: XOR<HorariosReservadosNullableRelationFilter, HorariosReservadosWhereInput> | null
  }

  export type CitasOrderByWithRelationInput = {
    citaID?: SortOrder
    clienteID?: SortOrderInput | SortOrder
    estilistaID?: SortOrderInput | SortOrder
    comentarios?: SortOrderInput | SortOrder
    estadoID?: SortOrderInput | SortOrder
    ActividadCliente?: ActividadClienteOrderByRelationAggregateInput
    Usuarios_Citas_clienteIDToUsuarios?: UsuariosOrderByWithRelationInput
    EstadoCita?: EstadoCitaOrderByWithRelationInput
    Usuarios_Citas_estilistaIDToUsuarios?: UsuariosOrderByWithRelationInput
    DetallesCita?: DetallesCitaOrderByRelationAggregateInput
    HistorialCitas?: HistorialCitasOrderByRelationAggregateInput
    HorariosReservados?: HorariosReservadosOrderByWithRelationInput
  }

  export type CitasWhereUniqueInput = Prisma.AtLeast<{
    citaID?: number
    AND?: CitasWhereInput | CitasWhereInput[]
    OR?: CitasWhereInput[]
    NOT?: CitasWhereInput | CitasWhereInput[]
    clienteID?: IntNullableFilter<"Citas"> | number | null
    estilistaID?: IntNullableFilter<"Citas"> | number | null
    comentarios?: StringNullableFilter<"Citas"> | string | null
    estadoID?: IntNullableFilter<"Citas"> | number | null
    ActividadCliente?: ActividadClienteListRelationFilter
    Usuarios_Citas_clienteIDToUsuarios?: XOR<UsuariosNullableRelationFilter, UsuariosWhereInput> | null
    EstadoCita?: XOR<EstadoCitaNullableRelationFilter, EstadoCitaWhereInput> | null
    Usuarios_Citas_estilistaIDToUsuarios?: XOR<UsuariosNullableRelationFilter, UsuariosWhereInput> | null
    DetallesCita?: DetallesCitaListRelationFilter
    HistorialCitas?: HistorialCitasListRelationFilter
    HorariosReservados?: XOR<HorariosReservadosNullableRelationFilter, HorariosReservadosWhereInput> | null
  }, "citaID">

  export type CitasOrderByWithAggregationInput = {
    citaID?: SortOrder
    clienteID?: SortOrderInput | SortOrder
    estilistaID?: SortOrderInput | SortOrder
    comentarios?: SortOrderInput | SortOrder
    estadoID?: SortOrderInput | SortOrder
    _count?: CitasCountOrderByAggregateInput
    _avg?: CitasAvgOrderByAggregateInput
    _max?: CitasMaxOrderByAggregateInput
    _min?: CitasMinOrderByAggregateInput
    _sum?: CitasSumOrderByAggregateInput
  }

  export type CitasScalarWhereWithAggregatesInput = {
    AND?: CitasScalarWhereWithAggregatesInput | CitasScalarWhereWithAggregatesInput[]
    OR?: CitasScalarWhereWithAggregatesInput[]
    NOT?: CitasScalarWhereWithAggregatesInput | CitasScalarWhereWithAggregatesInput[]
    citaID?: IntWithAggregatesFilter<"Citas"> | number
    clienteID?: IntNullableWithAggregatesFilter<"Citas"> | number | null
    estilistaID?: IntNullableWithAggregatesFilter<"Citas"> | number | null
    comentarios?: StringNullableWithAggregatesFilter<"Citas"> | string | null
    estadoID?: IntNullableWithAggregatesFilter<"Citas"> | number | null
  }

  export type DetallesCitaWhereInput = {
    AND?: DetallesCitaWhereInput | DetallesCitaWhereInput[]
    OR?: DetallesCitaWhereInput[]
    NOT?: DetallesCitaWhereInput | DetallesCitaWhereInput[]
    detalleID?: IntFilter<"DetallesCita"> | number
    citaID?: IntNullableFilter<"DetallesCita"> | number | null
    servicioID?: IntNullableFilter<"DetallesCita"> | number | null
    Citas?: XOR<CitasNullableRelationFilter, CitasWhereInput> | null
    Servicios?: XOR<ServiciosNullableRelationFilter, ServiciosWhereInput> | null
  }

  export type DetallesCitaOrderByWithRelationInput = {
    detalleID?: SortOrder
    citaID?: SortOrderInput | SortOrder
    servicioID?: SortOrderInput | SortOrder
    Citas?: CitasOrderByWithRelationInput
    Servicios?: ServiciosOrderByWithRelationInput
  }

  export type DetallesCitaWhereUniqueInput = Prisma.AtLeast<{
    detalleID?: number
    AND?: DetallesCitaWhereInput | DetallesCitaWhereInput[]
    OR?: DetallesCitaWhereInput[]
    NOT?: DetallesCitaWhereInput | DetallesCitaWhereInput[]
    citaID?: IntNullableFilter<"DetallesCita"> | number | null
    servicioID?: IntNullableFilter<"DetallesCita"> | number | null
    Citas?: XOR<CitasNullableRelationFilter, CitasWhereInput> | null
    Servicios?: XOR<ServiciosNullableRelationFilter, ServiciosWhereInput> | null
  }, "detalleID">

  export type DetallesCitaOrderByWithAggregationInput = {
    detalleID?: SortOrder
    citaID?: SortOrderInput | SortOrder
    servicioID?: SortOrderInput | SortOrder
    _count?: DetallesCitaCountOrderByAggregateInput
    _avg?: DetallesCitaAvgOrderByAggregateInput
    _max?: DetallesCitaMaxOrderByAggregateInput
    _min?: DetallesCitaMinOrderByAggregateInput
    _sum?: DetallesCitaSumOrderByAggregateInput
  }

  export type DetallesCitaScalarWhereWithAggregatesInput = {
    AND?: DetallesCitaScalarWhereWithAggregatesInput | DetallesCitaScalarWhereWithAggregatesInput[]
    OR?: DetallesCitaScalarWhereWithAggregatesInput[]
    NOT?: DetallesCitaScalarWhereWithAggregatesInput | DetallesCitaScalarWhereWithAggregatesInput[]
    detalleID?: IntWithAggregatesFilter<"DetallesCita"> | number
    citaID?: IntNullableWithAggregatesFilter<"DetallesCita"> | number | null
    servicioID?: IntNullableWithAggregatesFilter<"DetallesCita"> | number | null
  }

  export type EstadoCitaWhereInput = {
    AND?: EstadoCitaWhereInput | EstadoCitaWhereInput[]
    OR?: EstadoCitaWhereInput[]
    NOT?: EstadoCitaWhereInput | EstadoCitaWhereInput[]
    estadoID?: IntFilter<"EstadoCita"> | number
    nombre?: StringNullableFilter<"EstadoCita"> | string | null
    Citas?: CitasListRelationFilter
  }

  export type EstadoCitaOrderByWithRelationInput = {
    estadoID?: SortOrder
    nombre?: SortOrderInput | SortOrder
    Citas?: CitasOrderByRelationAggregateInput
  }

  export type EstadoCitaWhereUniqueInput = Prisma.AtLeast<{
    estadoID?: number
    AND?: EstadoCitaWhereInput | EstadoCitaWhereInput[]
    OR?: EstadoCitaWhereInput[]
    NOT?: EstadoCitaWhereInput | EstadoCitaWhereInput[]
    nombre?: StringNullableFilter<"EstadoCita"> | string | null
    Citas?: CitasListRelationFilter
  }, "estadoID">

  export type EstadoCitaOrderByWithAggregationInput = {
    estadoID?: SortOrder
    nombre?: SortOrderInput | SortOrder
    _count?: EstadoCitaCountOrderByAggregateInput
    _avg?: EstadoCitaAvgOrderByAggregateInput
    _max?: EstadoCitaMaxOrderByAggregateInput
    _min?: EstadoCitaMinOrderByAggregateInput
    _sum?: EstadoCitaSumOrderByAggregateInput
  }

  export type EstadoCitaScalarWhereWithAggregatesInput = {
    AND?: EstadoCitaScalarWhereWithAggregatesInput | EstadoCitaScalarWhereWithAggregatesInput[]
    OR?: EstadoCitaScalarWhereWithAggregatesInput[]
    NOT?: EstadoCitaScalarWhereWithAggregatesInput | EstadoCitaScalarWhereWithAggregatesInput[]
    estadoID?: IntWithAggregatesFilter<"EstadoCita"> | number
    nombre?: StringNullableWithAggregatesFilter<"EstadoCita"> | string | null
  }

  export type HistorialCitasWhereInput = {
    AND?: HistorialCitasWhereInput | HistorialCitasWhereInput[]
    OR?: HistorialCitasWhereInput[]
    NOT?: HistorialCitasWhereInput | HistorialCitasWhereInput[]
    historialCitasID?: IntFilter<"HistorialCitas"> | number
    clienteID?: IntNullableFilter<"HistorialCitas"> | number | null
    citaID?: IntNullableFilter<"HistorialCitas"> | number | null
    Citas?: XOR<CitasNullableRelationFilter, CitasWhereInput> | null
    Usuarios?: XOR<UsuariosNullableRelationFilter, UsuariosWhereInput> | null
  }

  export type HistorialCitasOrderByWithRelationInput = {
    historialCitasID?: SortOrder
    clienteID?: SortOrderInput | SortOrder
    citaID?: SortOrderInput | SortOrder
    Citas?: CitasOrderByWithRelationInput
    Usuarios?: UsuariosOrderByWithRelationInput
  }

  export type HistorialCitasWhereUniqueInput = Prisma.AtLeast<{
    historialCitasID?: number
    AND?: HistorialCitasWhereInput | HistorialCitasWhereInput[]
    OR?: HistorialCitasWhereInput[]
    NOT?: HistorialCitasWhereInput | HistorialCitasWhereInput[]
    clienteID?: IntNullableFilter<"HistorialCitas"> | number | null
    citaID?: IntNullableFilter<"HistorialCitas"> | number | null
    Citas?: XOR<CitasNullableRelationFilter, CitasWhereInput> | null
    Usuarios?: XOR<UsuariosNullableRelationFilter, UsuariosWhereInput> | null
  }, "historialCitasID">

  export type HistorialCitasOrderByWithAggregationInput = {
    historialCitasID?: SortOrder
    clienteID?: SortOrderInput | SortOrder
    citaID?: SortOrderInput | SortOrder
    _count?: HistorialCitasCountOrderByAggregateInput
    _avg?: HistorialCitasAvgOrderByAggregateInput
    _max?: HistorialCitasMaxOrderByAggregateInput
    _min?: HistorialCitasMinOrderByAggregateInput
    _sum?: HistorialCitasSumOrderByAggregateInput
  }

  export type HistorialCitasScalarWhereWithAggregatesInput = {
    AND?: HistorialCitasScalarWhereWithAggregatesInput | HistorialCitasScalarWhereWithAggregatesInput[]
    OR?: HistorialCitasScalarWhereWithAggregatesInput[]
    NOT?: HistorialCitasScalarWhereWithAggregatesInput | HistorialCitasScalarWhereWithAggregatesInput[]
    historialCitasID?: IntWithAggregatesFilter<"HistorialCitas"> | number
    clienteID?: IntNullableWithAggregatesFilter<"HistorialCitas"> | number | null
    citaID?: IntNullableWithAggregatesFilter<"HistorialCitas"> | number | null
  }

  export type HistorialRecompensasWhereInput = {
    AND?: HistorialRecompensasWhereInput | HistorialRecompensasWhereInput[]
    OR?: HistorialRecompensasWhereInput[]
    NOT?: HistorialRecompensasWhereInput | HistorialRecompensasWhereInput[]
    historialID?: IntFilter<"HistorialRecompensas"> | number
    clienteID?: IntNullableFilter<"HistorialRecompensas"> | number | null
    servicioID?: IntNullableFilter<"HistorialRecompensas"> | number | null
    puntosCanjeados?: IntNullableFilter<"HistorialRecompensas"> | number | null
    fecha?: DateTimeNullableFilter<"HistorialRecompensas"> | Date | string | null
    Usuarios?: XOR<UsuariosNullableRelationFilter, UsuariosWhereInput> | null
    Servicios?: XOR<ServiciosNullableRelationFilter, ServiciosWhereInput> | null
  }

  export type HistorialRecompensasOrderByWithRelationInput = {
    historialID?: SortOrder
    clienteID?: SortOrderInput | SortOrder
    servicioID?: SortOrderInput | SortOrder
    puntosCanjeados?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    Usuarios?: UsuariosOrderByWithRelationInput
    Servicios?: ServiciosOrderByWithRelationInput
  }

  export type HistorialRecompensasWhereUniqueInput = Prisma.AtLeast<{
    historialID?: number
    AND?: HistorialRecompensasWhereInput | HistorialRecompensasWhereInput[]
    OR?: HistorialRecompensasWhereInput[]
    NOT?: HistorialRecompensasWhereInput | HistorialRecompensasWhereInput[]
    clienteID?: IntNullableFilter<"HistorialRecompensas"> | number | null
    servicioID?: IntNullableFilter<"HistorialRecompensas"> | number | null
    puntosCanjeados?: IntNullableFilter<"HistorialRecompensas"> | number | null
    fecha?: DateTimeNullableFilter<"HistorialRecompensas"> | Date | string | null
    Usuarios?: XOR<UsuariosNullableRelationFilter, UsuariosWhereInput> | null
    Servicios?: XOR<ServiciosNullableRelationFilter, ServiciosWhereInput> | null
  }, "historialID">

  export type HistorialRecompensasOrderByWithAggregationInput = {
    historialID?: SortOrder
    clienteID?: SortOrderInput | SortOrder
    servicioID?: SortOrderInput | SortOrder
    puntosCanjeados?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    _count?: HistorialRecompensasCountOrderByAggregateInput
    _avg?: HistorialRecompensasAvgOrderByAggregateInput
    _max?: HistorialRecompensasMaxOrderByAggregateInput
    _min?: HistorialRecompensasMinOrderByAggregateInput
    _sum?: HistorialRecompensasSumOrderByAggregateInput
  }

  export type HistorialRecompensasScalarWhereWithAggregatesInput = {
    AND?: HistorialRecompensasScalarWhereWithAggregatesInput | HistorialRecompensasScalarWhereWithAggregatesInput[]
    OR?: HistorialRecompensasScalarWhereWithAggregatesInput[]
    NOT?: HistorialRecompensasScalarWhereWithAggregatesInput | HistorialRecompensasScalarWhereWithAggregatesInput[]
    historialID?: IntWithAggregatesFilter<"HistorialRecompensas"> | number
    clienteID?: IntNullableWithAggregatesFilter<"HistorialRecompensas"> | number | null
    servicioID?: IntNullableWithAggregatesFilter<"HistorialRecompensas"> | number | null
    puntosCanjeados?: IntNullableWithAggregatesFilter<"HistorialRecompensas"> | number | null
    fecha?: DateTimeNullableWithAggregatesFilter<"HistorialRecompensas"> | Date | string | null
  }

  export type HorariosWhereInput = {
    AND?: HorariosWhereInput | HorariosWhereInput[]
    OR?: HorariosWhereInput[]
    NOT?: HorariosWhereInput | HorariosWhereInput[]
    horariosID?: IntFilter<"Horarios"> | number
    estilistaID?: IntNullableFilter<"Horarios"> | number | null
    diaSemana?: StringNullableFilter<"Horarios"> | string | null
    horaInicio?: DateTimeNullableFilter<"Horarios"> | Date | string | null
    horaFinal?: DateTimeNullableFilter<"Horarios"> | Date | string | null
    Usuarios?: XOR<UsuariosNullableRelationFilter, UsuariosWhereInput> | null
  }

  export type HorariosOrderByWithRelationInput = {
    horariosID?: SortOrder
    estilistaID?: SortOrderInput | SortOrder
    diaSemana?: SortOrderInput | SortOrder
    horaInicio?: SortOrderInput | SortOrder
    horaFinal?: SortOrderInput | SortOrder
    Usuarios?: UsuariosOrderByWithRelationInput
  }

  export type HorariosWhereUniqueInput = Prisma.AtLeast<{
    horariosID?: number
    AND?: HorariosWhereInput | HorariosWhereInput[]
    OR?: HorariosWhereInput[]
    NOT?: HorariosWhereInput | HorariosWhereInput[]
    estilistaID?: IntNullableFilter<"Horarios"> | number | null
    diaSemana?: StringNullableFilter<"Horarios"> | string | null
    horaInicio?: DateTimeNullableFilter<"Horarios"> | Date | string | null
    horaFinal?: DateTimeNullableFilter<"Horarios"> | Date | string | null
    Usuarios?: XOR<UsuariosNullableRelationFilter, UsuariosWhereInput> | null
  }, "horariosID">

  export type HorariosOrderByWithAggregationInput = {
    horariosID?: SortOrder
    estilistaID?: SortOrderInput | SortOrder
    diaSemana?: SortOrderInput | SortOrder
    horaInicio?: SortOrderInput | SortOrder
    horaFinal?: SortOrderInput | SortOrder
    _count?: HorariosCountOrderByAggregateInput
    _avg?: HorariosAvgOrderByAggregateInput
    _max?: HorariosMaxOrderByAggregateInput
    _min?: HorariosMinOrderByAggregateInput
    _sum?: HorariosSumOrderByAggregateInput
  }

  export type HorariosScalarWhereWithAggregatesInput = {
    AND?: HorariosScalarWhereWithAggregatesInput | HorariosScalarWhereWithAggregatesInput[]
    OR?: HorariosScalarWhereWithAggregatesInput[]
    NOT?: HorariosScalarWhereWithAggregatesInput | HorariosScalarWhereWithAggregatesInput[]
    horariosID?: IntWithAggregatesFilter<"Horarios"> | number
    estilistaID?: IntNullableWithAggregatesFilter<"Horarios"> | number | null
    diaSemana?: StringNullableWithAggregatesFilter<"Horarios"> | string | null
    horaInicio?: DateTimeNullableWithAggregatesFilter<"Horarios"> | Date | string | null
    horaFinal?: DateTimeNullableWithAggregatesFilter<"Horarios"> | Date | string | null
  }

  export type HorariosReservadosWhereInput = {
    AND?: HorariosReservadosWhereInput | HorariosReservadosWhereInput[]
    OR?: HorariosReservadosWhereInput[]
    NOT?: HorariosReservadosWhereInput | HorariosReservadosWhereInput[]
    citaID?: IntFilter<"HorariosReservados"> | number
    dia?: DateTimeNullableFilter<"HorariosReservados"> | Date | string | null
    hora_inicio?: DateTimeNullableFilter<"HorariosReservados"> | Date | string | null
    hora_fin?: DateTimeNullableFilter<"HorariosReservados"> | Date | string | null
    Citas?: XOR<CitasRelationFilter, CitasWhereInput>
  }

  export type HorariosReservadosOrderByWithRelationInput = {
    citaID?: SortOrder
    dia?: SortOrderInput | SortOrder
    hora_inicio?: SortOrderInput | SortOrder
    hora_fin?: SortOrderInput | SortOrder
    Citas?: CitasOrderByWithRelationInput
  }

  export type HorariosReservadosWhereUniqueInput = Prisma.AtLeast<{
    citaID?: number
    AND?: HorariosReservadosWhereInput | HorariosReservadosWhereInput[]
    OR?: HorariosReservadosWhereInput[]
    NOT?: HorariosReservadosWhereInput | HorariosReservadosWhereInput[]
    dia?: DateTimeNullableFilter<"HorariosReservados"> | Date | string | null
    hora_inicio?: DateTimeNullableFilter<"HorariosReservados"> | Date | string | null
    hora_fin?: DateTimeNullableFilter<"HorariosReservados"> | Date | string | null
    Citas?: XOR<CitasRelationFilter, CitasWhereInput>
  }, "citaID">

  export type HorariosReservadosOrderByWithAggregationInput = {
    citaID?: SortOrder
    dia?: SortOrderInput | SortOrder
    hora_inicio?: SortOrderInput | SortOrder
    hora_fin?: SortOrderInput | SortOrder
    _count?: HorariosReservadosCountOrderByAggregateInput
    _avg?: HorariosReservadosAvgOrderByAggregateInput
    _max?: HorariosReservadosMaxOrderByAggregateInput
    _min?: HorariosReservadosMinOrderByAggregateInput
    _sum?: HorariosReservadosSumOrderByAggregateInput
  }

  export type HorariosReservadosScalarWhereWithAggregatesInput = {
    AND?: HorariosReservadosScalarWhereWithAggregatesInput | HorariosReservadosScalarWhereWithAggregatesInput[]
    OR?: HorariosReservadosScalarWhereWithAggregatesInput[]
    NOT?: HorariosReservadosScalarWhereWithAggregatesInput | HorariosReservadosScalarWhereWithAggregatesInput[]
    citaID?: IntWithAggregatesFilter<"HorariosReservados"> | number
    dia?: DateTimeNullableWithAggregatesFilter<"HorariosReservados"> | Date | string | null
    hora_inicio?: DateTimeNullableWithAggregatesFilter<"HorariosReservados"> | Date | string | null
    hora_fin?: DateTimeNullableWithAggregatesFilter<"HorariosReservados"> | Date | string | null
  }

  export type PuntosClientesWhereInput = {
    AND?: PuntosClientesWhereInput | PuntosClientesWhereInput[]
    OR?: PuntosClientesWhereInput[]
    NOT?: PuntosClientesWhereInput | PuntosClientesWhereInput[]
    puntosID?: IntFilter<"PuntosClientes"> | number
    clienteID?: IntNullableFilter<"PuntosClientes"> | number | null
    puntosAcumulados?: IntNullableFilter<"PuntosClientes"> | number | null
    puntosCanjeados?: IntNullableFilter<"PuntosClientes"> | number | null
    Usuarios?: XOR<UsuariosNullableRelationFilter, UsuariosWhereInput> | null
  }

  export type PuntosClientesOrderByWithRelationInput = {
    puntosID?: SortOrder
    clienteID?: SortOrderInput | SortOrder
    puntosAcumulados?: SortOrderInput | SortOrder
    puntosCanjeados?: SortOrderInput | SortOrder
    Usuarios?: UsuariosOrderByWithRelationInput
  }

  export type PuntosClientesWhereUniqueInput = Prisma.AtLeast<{
    puntosID?: number
    AND?: PuntosClientesWhereInput | PuntosClientesWhereInput[]
    OR?: PuntosClientesWhereInput[]
    NOT?: PuntosClientesWhereInput | PuntosClientesWhereInput[]
    clienteID?: IntNullableFilter<"PuntosClientes"> | number | null
    puntosAcumulados?: IntNullableFilter<"PuntosClientes"> | number | null
    puntosCanjeados?: IntNullableFilter<"PuntosClientes"> | number | null
    Usuarios?: XOR<UsuariosNullableRelationFilter, UsuariosWhereInput> | null
  }, "puntosID">

  export type PuntosClientesOrderByWithAggregationInput = {
    puntosID?: SortOrder
    clienteID?: SortOrderInput | SortOrder
    puntosAcumulados?: SortOrderInput | SortOrder
    puntosCanjeados?: SortOrderInput | SortOrder
    _count?: PuntosClientesCountOrderByAggregateInput
    _avg?: PuntosClientesAvgOrderByAggregateInput
    _max?: PuntosClientesMaxOrderByAggregateInput
    _min?: PuntosClientesMinOrderByAggregateInput
    _sum?: PuntosClientesSumOrderByAggregateInput
  }

  export type PuntosClientesScalarWhereWithAggregatesInput = {
    AND?: PuntosClientesScalarWhereWithAggregatesInput | PuntosClientesScalarWhereWithAggregatesInput[]
    OR?: PuntosClientesScalarWhereWithAggregatesInput[]
    NOT?: PuntosClientesScalarWhereWithAggregatesInput | PuntosClientesScalarWhereWithAggregatesInput[]
    puntosID?: IntWithAggregatesFilter<"PuntosClientes"> | number
    clienteID?: IntNullableWithAggregatesFilter<"PuntosClientes"> | number | null
    puntosAcumulados?: IntNullableWithAggregatesFilter<"PuntosClientes"> | number | null
    puntosCanjeados?: IntNullableWithAggregatesFilter<"PuntosClientes"> | number | null
  }

  export type PuntosServicioWhereInput = {
    AND?: PuntosServicioWhereInput | PuntosServicioWhereInput[]
    OR?: PuntosServicioWhereInput[]
    NOT?: PuntosServicioWhereInput | PuntosServicioWhereInput[]
    servicioID?: IntFilter<"PuntosServicio"> | number
    puntosGenerados?: IntNullableFilter<"PuntosServicio"> | number | null
    Servicios?: XOR<ServiciosRelationFilter, ServiciosWhereInput>
  }

  export type PuntosServicioOrderByWithRelationInput = {
    servicioID?: SortOrder
    puntosGenerados?: SortOrderInput | SortOrder
    Servicios?: ServiciosOrderByWithRelationInput
  }

  export type PuntosServicioWhereUniqueInput = Prisma.AtLeast<{
    servicioID?: number
    AND?: PuntosServicioWhereInput | PuntosServicioWhereInput[]
    OR?: PuntosServicioWhereInput[]
    NOT?: PuntosServicioWhereInput | PuntosServicioWhereInput[]
    puntosGenerados?: IntNullableFilter<"PuntosServicio"> | number | null
    Servicios?: XOR<ServiciosRelationFilter, ServiciosWhereInput>
  }, "servicioID">

  export type PuntosServicioOrderByWithAggregationInput = {
    servicioID?: SortOrder
    puntosGenerados?: SortOrderInput | SortOrder
    _count?: PuntosServicioCountOrderByAggregateInput
    _avg?: PuntosServicioAvgOrderByAggregateInput
    _max?: PuntosServicioMaxOrderByAggregateInput
    _min?: PuntosServicioMinOrderByAggregateInput
    _sum?: PuntosServicioSumOrderByAggregateInput
  }

  export type PuntosServicioScalarWhereWithAggregatesInput = {
    AND?: PuntosServicioScalarWhereWithAggregatesInput | PuntosServicioScalarWhereWithAggregatesInput[]
    OR?: PuntosServicioScalarWhereWithAggregatesInput[]
    NOT?: PuntosServicioScalarWhereWithAggregatesInput | PuntosServicioScalarWhereWithAggregatesInput[]
    servicioID?: IntWithAggregatesFilter<"PuntosServicio"> | number
    puntosGenerados?: IntNullableWithAggregatesFilter<"PuntosServicio"> | number | null
  }

  export type RolesWhereInput = {
    AND?: RolesWhereInput | RolesWhereInput[]
    OR?: RolesWhereInput[]
    NOT?: RolesWhereInput | RolesWhereInput[]
    rolID?: IntFilter<"Roles"> | number
    nombreRol?: StringNullableFilter<"Roles"> | string | null
    Usuarios?: UsuariosListRelationFilter
  }

  export type RolesOrderByWithRelationInput = {
    rolID?: SortOrder
    nombreRol?: SortOrderInput | SortOrder
    Usuarios?: UsuariosOrderByRelationAggregateInput
  }

  export type RolesWhereUniqueInput = Prisma.AtLeast<{
    rolID?: number
    AND?: RolesWhereInput | RolesWhereInput[]
    OR?: RolesWhereInput[]
    NOT?: RolesWhereInput | RolesWhereInput[]
    nombreRol?: StringNullableFilter<"Roles"> | string | null
    Usuarios?: UsuariosListRelationFilter
  }, "rolID">

  export type RolesOrderByWithAggregationInput = {
    rolID?: SortOrder
    nombreRol?: SortOrderInput | SortOrder
    _count?: RolesCountOrderByAggregateInput
    _avg?: RolesAvgOrderByAggregateInput
    _max?: RolesMaxOrderByAggregateInput
    _min?: RolesMinOrderByAggregateInput
    _sum?: RolesSumOrderByAggregateInput
  }

  export type RolesScalarWhereWithAggregatesInput = {
    AND?: RolesScalarWhereWithAggregatesInput | RolesScalarWhereWithAggregatesInput[]
    OR?: RolesScalarWhereWithAggregatesInput[]
    NOT?: RolesScalarWhereWithAggregatesInput | RolesScalarWhereWithAggregatesInput[]
    rolID?: IntWithAggregatesFilter<"Roles"> | number
    nombreRol?: StringNullableWithAggregatesFilter<"Roles"> | string | null
  }

  export type ServiciosWhereInput = {
    AND?: ServiciosWhereInput | ServiciosWhereInput[]
    OR?: ServiciosWhereInput[]
    NOT?: ServiciosWhereInput | ServiciosWhereInput[]
    servicioID?: IntFilter<"Servicios"> | number
    nombreServicio?: StringNullableFilter<"Servicios"> | string | null
    descripcion?: StringNullableFilter<"Servicios"> | string | null
    tiempoEstimado?: DateTimeNullableFilter<"Servicios"> | Date | string | null
    precio?: IntNullableFilter<"Servicios"> | number | null
    rutaImagen?: StringNullableFilter<"Servicios"> | string | null
    DetallesCita?: DetallesCitaListRelationFilter
    HistorialRecompensas?: HistorialRecompensasListRelationFilter
    PuntosServicio?: XOR<PuntosServicioNullableRelationFilter, PuntosServicioWhereInput> | null
  }

  export type ServiciosOrderByWithRelationInput = {
    servicioID?: SortOrder
    nombreServicio?: SortOrderInput | SortOrder
    descripcion?: SortOrderInput | SortOrder
    tiempoEstimado?: SortOrderInput | SortOrder
    precio?: SortOrderInput | SortOrder
    rutaImagen?: SortOrderInput | SortOrder
    DetallesCita?: DetallesCitaOrderByRelationAggregateInput
    HistorialRecompensas?: HistorialRecompensasOrderByRelationAggregateInput
    PuntosServicio?: PuntosServicioOrderByWithRelationInput
  }

  export type ServiciosWhereUniqueInput = Prisma.AtLeast<{
    servicioID?: number
    AND?: ServiciosWhereInput | ServiciosWhereInput[]
    OR?: ServiciosWhereInput[]
    NOT?: ServiciosWhereInput | ServiciosWhereInput[]
    nombreServicio?: StringNullableFilter<"Servicios"> | string | null
    descripcion?: StringNullableFilter<"Servicios"> | string | null
    tiempoEstimado?: DateTimeNullableFilter<"Servicios"> | Date | string | null
    precio?: IntNullableFilter<"Servicios"> | number | null
    rutaImagen?: StringNullableFilter<"Servicios"> | string | null
    DetallesCita?: DetallesCitaListRelationFilter
    HistorialRecompensas?: HistorialRecompensasListRelationFilter
    PuntosServicio?: XOR<PuntosServicioNullableRelationFilter, PuntosServicioWhereInput> | null
  }, "servicioID">

  export type ServiciosOrderByWithAggregationInput = {
    servicioID?: SortOrder
    nombreServicio?: SortOrderInput | SortOrder
    descripcion?: SortOrderInput | SortOrder
    tiempoEstimado?: SortOrderInput | SortOrder
    precio?: SortOrderInput | SortOrder
    rutaImagen?: SortOrderInput | SortOrder
    _count?: ServiciosCountOrderByAggregateInput
    _avg?: ServiciosAvgOrderByAggregateInput
    _max?: ServiciosMaxOrderByAggregateInput
    _min?: ServiciosMinOrderByAggregateInput
    _sum?: ServiciosSumOrderByAggregateInput
  }

  export type ServiciosScalarWhereWithAggregatesInput = {
    AND?: ServiciosScalarWhereWithAggregatesInput | ServiciosScalarWhereWithAggregatesInput[]
    OR?: ServiciosScalarWhereWithAggregatesInput[]
    NOT?: ServiciosScalarWhereWithAggregatesInput | ServiciosScalarWhereWithAggregatesInput[]
    servicioID?: IntWithAggregatesFilter<"Servicios"> | number
    nombreServicio?: StringNullableWithAggregatesFilter<"Servicios"> | string | null
    descripcion?: StringNullableWithAggregatesFilter<"Servicios"> | string | null
    tiempoEstimado?: DateTimeNullableWithAggregatesFilter<"Servicios"> | Date | string | null
    precio?: IntNullableWithAggregatesFilter<"Servicios"> | number | null
    rutaImagen?: StringNullableWithAggregatesFilter<"Servicios"> | string | null
  }

  export type UsuariosWhereInput = {
    AND?: UsuariosWhereInput | UsuariosWhereInput[]
    OR?: UsuariosWhereInput[]
    NOT?: UsuariosWhereInput | UsuariosWhereInput[]
    usuarioID?: IntFilter<"Usuarios"> | number
    nombre?: StringFilter<"Usuarios"> | string
    apellidos?: StringFilter<"Usuarios"> | string
    telefono?: StringNullableFilter<"Usuarios"> | string | null
    correo?: StringFilter<"Usuarios"> | string
    direccion?: StringNullableFilter<"Usuarios"> | string | null
    contra?: StringFilter<"Usuarios"> | string
    rolID?: IntNullableFilter<"Usuarios"> | number | null
    estado?: StringNullableFilter<"Usuarios"> | string | null
    ActividadCliente?: ActividadClienteListRelationFilter
    BitacoraCliente?: BitacoraClienteListRelationFilter
    BitacoraEstilista?: BitacoraEstilistaListRelationFilter
    BloqueoHorarios?: BloqueoHorariosListRelationFilter
    Citas_Citas_clienteIDToUsuarios?: CitasListRelationFilter
    Citas_Citas_estilistaIDToUsuarios?: CitasListRelationFilter
    HistorialCitas?: HistorialCitasListRelationFilter
    HistorialRecompensas?: HistorialRecompensasListRelationFilter
    Horarios?: HorariosListRelationFilter
    PuntosClientes?: PuntosClientesListRelationFilter
    Roles?: XOR<RolesNullableRelationFilter, RolesWhereInput> | null
  }

  export type UsuariosOrderByWithRelationInput = {
    usuarioID?: SortOrder
    nombre?: SortOrder
    apellidos?: SortOrder
    telefono?: SortOrderInput | SortOrder
    correo?: SortOrder
    direccion?: SortOrderInput | SortOrder
    contra?: SortOrder
    rolID?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    ActividadCliente?: ActividadClienteOrderByRelationAggregateInput
    BitacoraCliente?: BitacoraClienteOrderByRelationAggregateInput
    BitacoraEstilista?: BitacoraEstilistaOrderByRelationAggregateInput
    BloqueoHorarios?: BloqueoHorariosOrderByRelationAggregateInput
    Citas_Citas_clienteIDToUsuarios?: CitasOrderByRelationAggregateInput
    Citas_Citas_estilistaIDToUsuarios?: CitasOrderByRelationAggregateInput
    HistorialCitas?: HistorialCitasOrderByRelationAggregateInput
    HistorialRecompensas?: HistorialRecompensasOrderByRelationAggregateInput
    Horarios?: HorariosOrderByRelationAggregateInput
    PuntosClientes?: PuntosClientesOrderByRelationAggregateInput
    Roles?: RolesOrderByWithRelationInput
  }

  export type UsuariosWhereUniqueInput = Prisma.AtLeast<{
    usuarioID?: number
    AND?: UsuariosWhereInput | UsuariosWhereInput[]
    OR?: UsuariosWhereInput[]
    NOT?: UsuariosWhereInput | UsuariosWhereInput[]
    nombre?: StringFilter<"Usuarios"> | string
    apellidos?: StringFilter<"Usuarios"> | string
    telefono?: StringNullableFilter<"Usuarios"> | string | null
    correo?: StringFilter<"Usuarios"> | string
    direccion?: StringNullableFilter<"Usuarios"> | string | null
    contra?: StringFilter<"Usuarios"> | string
    rolID?: IntNullableFilter<"Usuarios"> | number | null
    estado?: StringNullableFilter<"Usuarios"> | string | null
    ActividadCliente?: ActividadClienteListRelationFilter
    BitacoraCliente?: BitacoraClienteListRelationFilter
    BitacoraEstilista?: BitacoraEstilistaListRelationFilter
    BloqueoHorarios?: BloqueoHorariosListRelationFilter
    Citas_Citas_clienteIDToUsuarios?: CitasListRelationFilter
    Citas_Citas_estilistaIDToUsuarios?: CitasListRelationFilter
    HistorialCitas?: HistorialCitasListRelationFilter
    HistorialRecompensas?: HistorialRecompensasListRelationFilter
    Horarios?: HorariosListRelationFilter
    PuntosClientes?: PuntosClientesListRelationFilter
    Roles?: XOR<RolesNullableRelationFilter, RolesWhereInput> | null
  }, "usuarioID">

  export type UsuariosOrderByWithAggregationInput = {
    usuarioID?: SortOrder
    nombre?: SortOrder
    apellidos?: SortOrder
    telefono?: SortOrderInput | SortOrder
    correo?: SortOrder
    direccion?: SortOrderInput | SortOrder
    contra?: SortOrder
    rolID?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    _count?: UsuariosCountOrderByAggregateInput
    _avg?: UsuariosAvgOrderByAggregateInput
    _max?: UsuariosMaxOrderByAggregateInput
    _min?: UsuariosMinOrderByAggregateInput
    _sum?: UsuariosSumOrderByAggregateInput
  }

  export type UsuariosScalarWhereWithAggregatesInput = {
    AND?: UsuariosScalarWhereWithAggregatesInput | UsuariosScalarWhereWithAggregatesInput[]
    OR?: UsuariosScalarWhereWithAggregatesInput[]
    NOT?: UsuariosScalarWhereWithAggregatesInput | UsuariosScalarWhereWithAggregatesInput[]
    usuarioID?: IntWithAggregatesFilter<"Usuarios"> | number
    nombre?: StringWithAggregatesFilter<"Usuarios"> | string
    apellidos?: StringWithAggregatesFilter<"Usuarios"> | string
    telefono?: StringNullableWithAggregatesFilter<"Usuarios"> | string | null
    correo?: StringWithAggregatesFilter<"Usuarios"> | string
    direccion?: StringNullableWithAggregatesFilter<"Usuarios"> | string | null
    contra?: StringWithAggregatesFilter<"Usuarios"> | string
    rolID?: IntNullableWithAggregatesFilter<"Usuarios"> | number | null
    estado?: StringNullableWithAggregatesFilter<"Usuarios"> | string | null
  }

  export type ActividadClienteCreateInput = {
    ultimaConexion?: Date | string | null
    Usuarios?: UsuariosCreateNestedOneWithoutActividadClienteInput
    Citas?: CitasCreateNestedOneWithoutActividadClienteInput
  }

  export type ActividadClienteUncheckedCreateInput = {
    actividadID?: number
    clienteID?: number | null
    ultimaConexion?: Date | string | null
    ultimaCitaID?: number | null
  }

  export type ActividadClienteUpdateInput = {
    ultimaConexion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Usuarios?: UsuariosUpdateOneWithoutActividadClienteNestedInput
    Citas?: CitasUpdateOneWithoutActividadClienteNestedInput
  }

  export type ActividadClienteUncheckedUpdateInput = {
    actividadID?: IntFieldUpdateOperationsInput | number
    clienteID?: NullableIntFieldUpdateOperationsInput | number | null
    ultimaConexion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimaCitaID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ActividadClienteCreateManyInput = {
    clienteID?: number | null
    ultimaConexion?: Date | string | null
    ultimaCitaID?: number | null
  }

  export type ActividadClienteUpdateManyMutationInput = {
    ultimaConexion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ActividadClienteUncheckedUpdateManyInput = {
    actividadID?: IntFieldUpdateOperationsInput | number
    clienteID?: NullableIntFieldUpdateOperationsInput | number | null
    ultimaConexion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimaCitaID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BitacoraClienteCreateInput = {
    fechaRegistro?: Date | string | null
    Usuarios?: UsuariosCreateNestedOneWithoutBitacoraClienteInput
  }

  export type BitacoraClienteUncheckedCreateInput = {
    bitacoraID?: number
    clienteID?: number | null
    fechaRegistro?: Date | string | null
  }

  export type BitacoraClienteUpdateInput = {
    fechaRegistro?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Usuarios?: UsuariosUpdateOneWithoutBitacoraClienteNestedInput
  }

  export type BitacoraClienteUncheckedUpdateInput = {
    bitacoraID?: IntFieldUpdateOperationsInput | number
    clienteID?: NullableIntFieldUpdateOperationsInput | number | null
    fechaRegistro?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BitacoraClienteCreateManyInput = {
    clienteID?: number | null
    fechaRegistro?: Date | string | null
  }

  export type BitacoraClienteUpdateManyMutationInput = {
    fechaRegistro?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BitacoraClienteUncheckedUpdateManyInput = {
    bitacoraID?: IntFieldUpdateOperationsInput | number
    clienteID?: NullableIntFieldUpdateOperationsInput | number | null
    fechaRegistro?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BitacoraEstilistaCreateInput = {
    fechaIngreso?: Date | string | null
    fechaSalida?: Date | string | null
    Usuarios?: UsuariosCreateNestedOneWithoutBitacoraEstilistaInput
  }

  export type BitacoraEstilistaUncheckedCreateInput = {
    bitacoraID?: number
    estilistaID?: number | null
    fechaIngreso?: Date | string | null
    fechaSalida?: Date | string | null
  }

  export type BitacoraEstilistaUpdateInput = {
    fechaIngreso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaSalida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Usuarios?: UsuariosUpdateOneWithoutBitacoraEstilistaNestedInput
  }

  export type BitacoraEstilistaUncheckedUpdateInput = {
    bitacoraID?: IntFieldUpdateOperationsInput | number
    estilistaID?: NullableIntFieldUpdateOperationsInput | number | null
    fechaIngreso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaSalida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BitacoraEstilistaCreateManyInput = {
    estilistaID?: number | null
    fechaIngreso?: Date | string | null
    fechaSalida?: Date | string | null
  }

  export type BitacoraEstilistaUpdateManyMutationInput = {
    fechaIngreso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaSalida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BitacoraEstilistaUncheckedUpdateManyInput = {
    bitacoraID?: IntFieldUpdateOperationsInput | number
    estilistaID?: NullableIntFieldUpdateOperationsInput | number | null
    fechaIngreso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaSalida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BloqueoHorariosCreateInput = {
    dia?: string | null
    horaInicio?: Date | string | null
    horaFinal?: Date | string | null
    motivo?: string | null
    Usuarios?: UsuariosCreateNestedOneWithoutBloqueoHorariosInput
  }

  export type BloqueoHorariosUncheckedCreateInput = {
    bloqueoID?: number
    estilistaID?: number | null
    dia?: string | null
    horaInicio?: Date | string | null
    horaFinal?: Date | string | null
    motivo?: string | null
  }

  export type BloqueoHorariosUpdateInput = {
    dia?: NullableStringFieldUpdateOperationsInput | string | null
    horaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horaFinal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    Usuarios?: UsuariosUpdateOneWithoutBloqueoHorariosNestedInput
  }

  export type BloqueoHorariosUncheckedUpdateInput = {
    bloqueoID?: IntFieldUpdateOperationsInput | number
    estilistaID?: NullableIntFieldUpdateOperationsInput | number | null
    dia?: NullableStringFieldUpdateOperationsInput | string | null
    horaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horaFinal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BloqueoHorariosCreateManyInput = {
    estilistaID?: number | null
    dia?: string | null
    horaInicio?: Date | string | null
    horaFinal?: Date | string | null
    motivo?: string | null
  }

  export type BloqueoHorariosUpdateManyMutationInput = {
    dia?: NullableStringFieldUpdateOperationsInput | string | null
    horaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horaFinal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BloqueoHorariosUncheckedUpdateManyInput = {
    bloqueoID?: IntFieldUpdateOperationsInput | number
    estilistaID?: NullableIntFieldUpdateOperationsInput | number | null
    dia?: NullableStringFieldUpdateOperationsInput | string | null
    horaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horaFinal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CitasCreateInput = {
    comentarios?: string | null
    ActividadCliente?: ActividadClienteCreateNestedManyWithoutCitasInput
    Usuarios_Citas_clienteIDToUsuarios?: UsuariosCreateNestedOneWithoutCitas_Citas_clienteIDToUsuariosInput
    EstadoCita?: EstadoCitaCreateNestedOneWithoutCitasInput
    Usuarios_Citas_estilistaIDToUsuarios?: UsuariosCreateNestedOneWithoutCitas_Citas_estilistaIDToUsuariosInput
    DetallesCita?: DetallesCitaCreateNestedManyWithoutCitasInput
    HistorialCitas?: HistorialCitasCreateNestedManyWithoutCitasInput
    HorariosReservados?: HorariosReservadosCreateNestedOneWithoutCitasInput
  }

  export type CitasUncheckedCreateInput = {
    citaID?: number
    clienteID?: number | null
    estilistaID?: number | null
    comentarios?: string | null
    estadoID?: number | null
    ActividadCliente?: ActividadClienteUncheckedCreateNestedManyWithoutCitasInput
    DetallesCita?: DetallesCitaUncheckedCreateNestedManyWithoutCitasInput
    HistorialCitas?: HistorialCitasUncheckedCreateNestedManyWithoutCitasInput
    HorariosReservados?: HorariosReservadosUncheckedCreateNestedOneWithoutCitasInput
  }

  export type CitasUpdateInput = {
    comentarios?: NullableStringFieldUpdateOperationsInput | string | null
    ActividadCliente?: ActividadClienteUpdateManyWithoutCitasNestedInput
    Usuarios_Citas_clienteIDToUsuarios?: UsuariosUpdateOneWithoutCitas_Citas_clienteIDToUsuariosNestedInput
    EstadoCita?: EstadoCitaUpdateOneWithoutCitasNestedInput
    Usuarios_Citas_estilistaIDToUsuarios?: UsuariosUpdateOneWithoutCitas_Citas_estilistaIDToUsuariosNestedInput
    DetallesCita?: DetallesCitaUpdateManyWithoutCitasNestedInput
    HistorialCitas?: HistorialCitasUpdateManyWithoutCitasNestedInput
    HorariosReservados?: HorariosReservadosUpdateOneWithoutCitasNestedInput
  }

  export type CitasUncheckedUpdateInput = {
    citaID?: IntFieldUpdateOperationsInput | number
    clienteID?: NullableIntFieldUpdateOperationsInput | number | null
    estilistaID?: NullableIntFieldUpdateOperationsInput | number | null
    comentarios?: NullableStringFieldUpdateOperationsInput | string | null
    estadoID?: NullableIntFieldUpdateOperationsInput | number | null
    ActividadCliente?: ActividadClienteUncheckedUpdateManyWithoutCitasNestedInput
    DetallesCita?: DetallesCitaUncheckedUpdateManyWithoutCitasNestedInput
    HistorialCitas?: HistorialCitasUncheckedUpdateManyWithoutCitasNestedInput
    HorariosReservados?: HorariosReservadosUncheckedUpdateOneWithoutCitasNestedInput
  }

  export type CitasCreateManyInput = {
    clienteID?: number | null
    estilistaID?: number | null
    comentarios?: string | null
    estadoID?: number | null
  }

  export type CitasUpdateManyMutationInput = {
    comentarios?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CitasUncheckedUpdateManyInput = {
    citaID?: IntFieldUpdateOperationsInput | number
    clienteID?: NullableIntFieldUpdateOperationsInput | number | null
    estilistaID?: NullableIntFieldUpdateOperationsInput | number | null
    comentarios?: NullableStringFieldUpdateOperationsInput | string | null
    estadoID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DetallesCitaCreateInput = {
    Citas?: CitasCreateNestedOneWithoutDetallesCitaInput
    Servicios?: ServiciosCreateNestedOneWithoutDetallesCitaInput
  }

  export type DetallesCitaUncheckedCreateInput = {
    detalleID?: number
    citaID?: number | null
    servicioID?: number | null
  }

  export type DetallesCitaUpdateInput = {
    Citas?: CitasUpdateOneWithoutDetallesCitaNestedInput
    Servicios?: ServiciosUpdateOneWithoutDetallesCitaNestedInput
  }

  export type DetallesCitaUncheckedUpdateInput = {
    detalleID?: IntFieldUpdateOperationsInput | number
    citaID?: NullableIntFieldUpdateOperationsInput | number | null
    servicioID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DetallesCitaCreateManyInput = {
    citaID?: number | null
    servicioID?: number | null
  }

  export type DetallesCitaUpdateManyMutationInput = {

  }

  export type DetallesCitaUncheckedUpdateManyInput = {
    detalleID?: IntFieldUpdateOperationsInput | number
    citaID?: NullableIntFieldUpdateOperationsInput | number | null
    servicioID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EstadoCitaCreateInput = {
    nombre?: string | null
    Citas?: CitasCreateNestedManyWithoutEstadoCitaInput
  }

  export type EstadoCitaUncheckedCreateInput = {
    estadoID?: number
    nombre?: string | null
    Citas?: CitasUncheckedCreateNestedManyWithoutEstadoCitaInput
  }

  export type EstadoCitaUpdateInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    Citas?: CitasUpdateManyWithoutEstadoCitaNestedInput
  }

  export type EstadoCitaUncheckedUpdateInput = {
    estadoID?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    Citas?: CitasUncheckedUpdateManyWithoutEstadoCitaNestedInput
  }

  export type EstadoCitaCreateManyInput = {
    nombre?: string | null
  }

  export type EstadoCitaUpdateManyMutationInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EstadoCitaUncheckedUpdateManyInput = {
    estadoID?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HistorialCitasCreateInput = {
    Citas?: CitasCreateNestedOneWithoutHistorialCitasInput
    Usuarios?: UsuariosCreateNestedOneWithoutHistorialCitasInput
  }

  export type HistorialCitasUncheckedCreateInput = {
    historialCitasID?: number
    clienteID?: number | null
    citaID?: number | null
  }

  export type HistorialCitasUpdateInput = {
    Citas?: CitasUpdateOneWithoutHistorialCitasNestedInput
    Usuarios?: UsuariosUpdateOneWithoutHistorialCitasNestedInput
  }

  export type HistorialCitasUncheckedUpdateInput = {
    historialCitasID?: IntFieldUpdateOperationsInput | number
    clienteID?: NullableIntFieldUpdateOperationsInput | number | null
    citaID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type HistorialCitasCreateManyInput = {
    clienteID?: number | null
    citaID?: number | null
  }

  export type HistorialCitasUpdateManyMutationInput = {

  }

  export type HistorialCitasUncheckedUpdateManyInput = {
    historialCitasID?: IntFieldUpdateOperationsInput | number
    clienteID?: NullableIntFieldUpdateOperationsInput | number | null
    citaID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type HistorialRecompensasCreateInput = {
    puntosCanjeados?: number | null
    fecha?: Date | string | null
    Usuarios?: UsuariosCreateNestedOneWithoutHistorialRecompensasInput
    Servicios?: ServiciosCreateNestedOneWithoutHistorialRecompensasInput
  }

  export type HistorialRecompensasUncheckedCreateInput = {
    historialID?: number
    clienteID?: number | null
    servicioID?: number | null
    puntosCanjeados?: number | null
    fecha?: Date | string | null
  }

  export type HistorialRecompensasUpdateInput = {
    puntosCanjeados?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Usuarios?: UsuariosUpdateOneWithoutHistorialRecompensasNestedInput
    Servicios?: ServiciosUpdateOneWithoutHistorialRecompensasNestedInput
  }

  export type HistorialRecompensasUncheckedUpdateInput = {
    historialID?: IntFieldUpdateOperationsInput | number
    clienteID?: NullableIntFieldUpdateOperationsInput | number | null
    servicioID?: NullableIntFieldUpdateOperationsInput | number | null
    puntosCanjeados?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type HistorialRecompensasCreateManyInput = {
    clienteID?: number | null
    servicioID?: number | null
    puntosCanjeados?: number | null
    fecha?: Date | string | null
  }

  export type HistorialRecompensasUpdateManyMutationInput = {
    puntosCanjeados?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type HistorialRecompensasUncheckedUpdateManyInput = {
    historialID?: IntFieldUpdateOperationsInput | number
    clienteID?: NullableIntFieldUpdateOperationsInput | number | null
    servicioID?: NullableIntFieldUpdateOperationsInput | number | null
    puntosCanjeados?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type HorariosCreateInput = {
    diaSemana?: string | null
    horaInicio?: Date | string | null
    horaFinal?: Date | string | null
    Usuarios?: UsuariosCreateNestedOneWithoutHorariosInput
  }

  export type HorariosUncheckedCreateInput = {
    horariosID?: number
    estilistaID?: number | null
    diaSemana?: string | null
    horaInicio?: Date | string | null
    horaFinal?: Date | string | null
  }

  export type HorariosUpdateInput = {
    diaSemana?: NullableStringFieldUpdateOperationsInput | string | null
    horaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horaFinal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Usuarios?: UsuariosUpdateOneWithoutHorariosNestedInput
  }

  export type HorariosUncheckedUpdateInput = {
    horariosID?: IntFieldUpdateOperationsInput | number
    estilistaID?: NullableIntFieldUpdateOperationsInput | number | null
    diaSemana?: NullableStringFieldUpdateOperationsInput | string | null
    horaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horaFinal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type HorariosCreateManyInput = {
    estilistaID?: number | null
    diaSemana?: string | null
    horaInicio?: Date | string | null
    horaFinal?: Date | string | null
  }

  export type HorariosUpdateManyMutationInput = {
    diaSemana?: NullableStringFieldUpdateOperationsInput | string | null
    horaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horaFinal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type HorariosUncheckedUpdateManyInput = {
    horariosID?: IntFieldUpdateOperationsInput | number
    estilistaID?: NullableIntFieldUpdateOperationsInput | number | null
    diaSemana?: NullableStringFieldUpdateOperationsInput | string | null
    horaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horaFinal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type HorariosReservadosCreateInput = {
    dia?: Date | string | null
    hora_inicio?: Date | string | null
    hora_fin?: Date | string | null
    Citas?: CitasCreateNestedOneWithoutHorariosReservadosInput
  }

  export type HorariosReservadosUncheckedCreateInput = {
    citaID?: number
    dia?: Date | string | null
    hora_inicio?: Date | string | null
    hora_fin?: Date | string | null
  }

  export type HorariosReservadosUpdateInput = {
    dia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hora_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hora_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Citas?: CitasUpdateOneRequiredWithoutHorariosReservadosNestedInput
  }

  export type HorariosReservadosUncheckedUpdateInput = {
    citaID?: IntFieldUpdateOperationsInput | number
    dia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hora_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hora_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type HorariosReservadosCreateManyInput = {
    dia?: Date | string | null
    hora_inicio?: Date | string | null
    hora_fin?: Date | string | null
  }

  export type HorariosReservadosUpdateManyMutationInput = {
    dia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hora_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hora_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type HorariosReservadosUncheckedUpdateManyInput = {
    citaID?: IntFieldUpdateOperationsInput | number
    dia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hora_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hora_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PuntosClientesCreateInput = {
    puntosAcumulados?: number | null
    puntosCanjeados?: number | null
    Usuarios?: UsuariosCreateNestedOneWithoutPuntosClientesInput
  }

  export type PuntosClientesUncheckedCreateInput = {
    puntosID?: number
    clienteID?: number | null
    puntosAcumulados?: number | null
    puntosCanjeados?: number | null
  }

  export type PuntosClientesUpdateInput = {
    puntosAcumulados?: NullableIntFieldUpdateOperationsInput | number | null
    puntosCanjeados?: NullableIntFieldUpdateOperationsInput | number | null
    Usuarios?: UsuariosUpdateOneWithoutPuntosClientesNestedInput
  }

  export type PuntosClientesUncheckedUpdateInput = {
    puntosID?: IntFieldUpdateOperationsInput | number
    clienteID?: NullableIntFieldUpdateOperationsInput | number | null
    puntosAcumulados?: NullableIntFieldUpdateOperationsInput | number | null
    puntosCanjeados?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PuntosClientesCreateManyInput = {
    clienteID?: number | null
    puntosAcumulados?: number | null
    puntosCanjeados?: number | null
  }

  export type PuntosClientesUpdateManyMutationInput = {
    puntosAcumulados?: NullableIntFieldUpdateOperationsInput | number | null
    puntosCanjeados?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PuntosClientesUncheckedUpdateManyInput = {
    puntosID?: IntFieldUpdateOperationsInput | number
    clienteID?: NullableIntFieldUpdateOperationsInput | number | null
    puntosAcumulados?: NullableIntFieldUpdateOperationsInput | number | null
    puntosCanjeados?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PuntosServicioCreateInput = {
    puntosGenerados?: number | null
    Servicios?: ServiciosCreateNestedOneWithoutPuntosServicioInput
  }

  export type PuntosServicioUncheckedCreateInput = {
    servicioID?: number
    puntosGenerados?: number | null
  }

  export type PuntosServicioUpdateInput = {
    puntosGenerados?: NullableIntFieldUpdateOperationsInput | number | null
    Servicios?: ServiciosUpdateOneRequiredWithoutPuntosServicioNestedInput
  }

  export type PuntosServicioUncheckedUpdateInput = {
    servicioID?: IntFieldUpdateOperationsInput | number
    puntosGenerados?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PuntosServicioCreateManyInput = {
    puntosGenerados?: number | null
  }

  export type PuntosServicioUpdateManyMutationInput = {
    puntosGenerados?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PuntosServicioUncheckedUpdateManyInput = {
    servicioID?: IntFieldUpdateOperationsInput | number
    puntosGenerados?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RolesCreateInput = {
    nombreRol?: string | null
    Usuarios?: UsuariosCreateNestedManyWithoutRolesInput
  }

  export type RolesUncheckedCreateInput = {
    rolID?: number
    nombreRol?: string | null
    Usuarios?: UsuariosUncheckedCreateNestedManyWithoutRolesInput
  }

  export type RolesUpdateInput = {
    nombreRol?: NullableStringFieldUpdateOperationsInput | string | null
    Usuarios?: UsuariosUpdateManyWithoutRolesNestedInput
  }

  export type RolesUncheckedUpdateInput = {
    rolID?: IntFieldUpdateOperationsInput | number
    nombreRol?: NullableStringFieldUpdateOperationsInput | string | null
    Usuarios?: UsuariosUncheckedUpdateManyWithoutRolesNestedInput
  }

  export type RolesCreateManyInput = {
    nombreRol?: string | null
  }

  export type RolesUpdateManyMutationInput = {
    nombreRol?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RolesUncheckedUpdateManyInput = {
    rolID?: IntFieldUpdateOperationsInput | number
    nombreRol?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiciosCreateInput = {
    nombreServicio?: string | null
    descripcion?: string | null
    tiempoEstimado?: Date | string | null
    precio?: number | null
    rutaImagen?: string | null
    DetallesCita?: DetallesCitaCreateNestedManyWithoutServiciosInput
    HistorialRecompensas?: HistorialRecompensasCreateNestedManyWithoutServiciosInput
    PuntosServicio?: PuntosServicioCreateNestedOneWithoutServiciosInput
  }

  export type ServiciosUncheckedCreateInput = {
    servicioID?: number
    nombreServicio?: string | null
    descripcion?: string | null
    tiempoEstimado?: Date | string | null
    precio?: number | null
    rutaImagen?: string | null
    DetallesCita?: DetallesCitaUncheckedCreateNestedManyWithoutServiciosInput
    HistorialRecompensas?: HistorialRecompensasUncheckedCreateNestedManyWithoutServiciosInput
    PuntosServicio?: PuntosServicioUncheckedCreateNestedOneWithoutServiciosInput
  }

  export type ServiciosUpdateInput = {
    nombreServicio?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    tiempoEstimado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    precio?: NullableIntFieldUpdateOperationsInput | number | null
    rutaImagen?: NullableStringFieldUpdateOperationsInput | string | null
    DetallesCita?: DetallesCitaUpdateManyWithoutServiciosNestedInput
    HistorialRecompensas?: HistorialRecompensasUpdateManyWithoutServiciosNestedInput
    PuntosServicio?: PuntosServicioUpdateOneWithoutServiciosNestedInput
  }

  export type ServiciosUncheckedUpdateInput = {
    servicioID?: IntFieldUpdateOperationsInput | number
    nombreServicio?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    tiempoEstimado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    precio?: NullableIntFieldUpdateOperationsInput | number | null
    rutaImagen?: NullableStringFieldUpdateOperationsInput | string | null
    DetallesCita?: DetallesCitaUncheckedUpdateManyWithoutServiciosNestedInput
    HistorialRecompensas?: HistorialRecompensasUncheckedUpdateManyWithoutServiciosNestedInput
    PuntosServicio?: PuntosServicioUncheckedUpdateOneWithoutServiciosNestedInput
  }

  export type ServiciosCreateManyInput = {
    nombreServicio?: string | null
    descripcion?: string | null
    tiempoEstimado?: Date | string | null
    precio?: number | null
    rutaImagen?: string | null
  }

  export type ServiciosUpdateManyMutationInput = {
    nombreServicio?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    tiempoEstimado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    precio?: NullableIntFieldUpdateOperationsInput | number | null
    rutaImagen?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiciosUncheckedUpdateManyInput = {
    servicioID?: IntFieldUpdateOperationsInput | number
    nombreServicio?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    tiempoEstimado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    precio?: NullableIntFieldUpdateOperationsInput | number | null
    rutaImagen?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UsuariosCreateInput = {
    nombre: string
    apellidos: string
    telefono?: string | null
    correo: string
    direccion?: string | null
    contra: string
    estado?: string | null
    ActividadCliente?: ActividadClienteCreateNestedManyWithoutUsuariosInput
    BitacoraCliente?: BitacoraClienteCreateNestedManyWithoutUsuariosInput
    BitacoraEstilista?: BitacoraEstilistaCreateNestedManyWithoutUsuariosInput
    BloqueoHorarios?: BloqueoHorariosCreateNestedManyWithoutUsuariosInput
    Citas_Citas_clienteIDToUsuarios?: CitasCreateNestedManyWithoutUsuarios_Citas_clienteIDToUsuariosInput
    Citas_Citas_estilistaIDToUsuarios?: CitasCreateNestedManyWithoutUsuarios_Citas_estilistaIDToUsuariosInput
    HistorialCitas?: HistorialCitasCreateNestedManyWithoutUsuariosInput
    HistorialRecompensas?: HistorialRecompensasCreateNestedManyWithoutUsuariosInput
    Horarios?: HorariosCreateNestedManyWithoutUsuariosInput
    PuntosClientes?: PuntosClientesCreateNestedManyWithoutUsuariosInput
    Roles?: RolesCreateNestedOneWithoutUsuariosInput
  }

  export type UsuariosUncheckedCreateInput = {
    usuarioID?: number
    nombre: string
    apellidos: string
    telefono?: string | null
    correo: string
    direccion?: string | null
    contra: string
    rolID?: number | null
    estado?: string | null
    ActividadCliente?: ActividadClienteUncheckedCreateNestedManyWithoutUsuariosInput
    BitacoraCliente?: BitacoraClienteUncheckedCreateNestedManyWithoutUsuariosInput
    BitacoraEstilista?: BitacoraEstilistaUncheckedCreateNestedManyWithoutUsuariosInput
    BloqueoHorarios?: BloqueoHorariosUncheckedCreateNestedManyWithoutUsuariosInput
    Citas_Citas_clienteIDToUsuarios?: CitasUncheckedCreateNestedManyWithoutUsuarios_Citas_clienteIDToUsuariosInput
    Citas_Citas_estilistaIDToUsuarios?: CitasUncheckedCreateNestedManyWithoutUsuarios_Citas_estilistaIDToUsuariosInput
    HistorialCitas?: HistorialCitasUncheckedCreateNestedManyWithoutUsuariosInput
    HistorialRecompensas?: HistorialRecompensasUncheckedCreateNestedManyWithoutUsuariosInput
    Horarios?: HorariosUncheckedCreateNestedManyWithoutUsuariosInput
    PuntosClientes?: PuntosClientesUncheckedCreateNestedManyWithoutUsuariosInput
  }

  export type UsuariosUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    contra?: StringFieldUpdateOperationsInput | string
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    ActividadCliente?: ActividadClienteUpdateManyWithoutUsuariosNestedInput
    BitacoraCliente?: BitacoraClienteUpdateManyWithoutUsuariosNestedInput
    BitacoraEstilista?: BitacoraEstilistaUpdateManyWithoutUsuariosNestedInput
    BloqueoHorarios?: BloqueoHorariosUpdateManyWithoutUsuariosNestedInput
    Citas_Citas_clienteIDToUsuarios?: CitasUpdateManyWithoutUsuarios_Citas_clienteIDToUsuariosNestedInput
    Citas_Citas_estilistaIDToUsuarios?: CitasUpdateManyWithoutUsuarios_Citas_estilistaIDToUsuariosNestedInput
    HistorialCitas?: HistorialCitasUpdateManyWithoutUsuariosNestedInput
    HistorialRecompensas?: HistorialRecompensasUpdateManyWithoutUsuariosNestedInput
    Horarios?: HorariosUpdateManyWithoutUsuariosNestedInput
    PuntosClientes?: PuntosClientesUpdateManyWithoutUsuariosNestedInput
    Roles?: RolesUpdateOneWithoutUsuariosNestedInput
  }

  export type UsuariosUncheckedUpdateInput = {
    usuarioID?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    contra?: StringFieldUpdateOperationsInput | string
    rolID?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    ActividadCliente?: ActividadClienteUncheckedUpdateManyWithoutUsuariosNestedInput
    BitacoraCliente?: BitacoraClienteUncheckedUpdateManyWithoutUsuariosNestedInput
    BitacoraEstilista?: BitacoraEstilistaUncheckedUpdateManyWithoutUsuariosNestedInput
    BloqueoHorarios?: BloqueoHorariosUncheckedUpdateManyWithoutUsuariosNestedInput
    Citas_Citas_clienteIDToUsuarios?: CitasUncheckedUpdateManyWithoutUsuarios_Citas_clienteIDToUsuariosNestedInput
    Citas_Citas_estilistaIDToUsuarios?: CitasUncheckedUpdateManyWithoutUsuarios_Citas_estilistaIDToUsuariosNestedInput
    HistorialCitas?: HistorialCitasUncheckedUpdateManyWithoutUsuariosNestedInput
    HistorialRecompensas?: HistorialRecompensasUncheckedUpdateManyWithoutUsuariosNestedInput
    Horarios?: HorariosUncheckedUpdateManyWithoutUsuariosNestedInput
    PuntosClientes?: PuntosClientesUncheckedUpdateManyWithoutUsuariosNestedInput
  }

  export type UsuariosCreateManyInput = {
    nombre: string
    apellidos: string
    telefono?: string | null
    correo: string
    direccion?: string | null
    contra: string
    rolID?: number | null
    estado?: string | null
  }

  export type UsuariosUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    contra?: StringFieldUpdateOperationsInput | string
    estado?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UsuariosUncheckedUpdateManyInput = {
    usuarioID?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    contra?: StringFieldUpdateOperationsInput | string
    rolID?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type UsuariosNullableRelationFilter = {
    is?: UsuariosWhereInput | null
    isNot?: UsuariosWhereInput | null
  }

  export type CitasNullableRelationFilter = {
    is?: CitasWhereInput | null
    isNot?: CitasWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ActividadClienteCountOrderByAggregateInput = {
    actividadID?: SortOrder
    clienteID?: SortOrder
    ultimaConexion?: SortOrder
    ultimaCitaID?: SortOrder
  }

  export type ActividadClienteAvgOrderByAggregateInput = {
    actividadID?: SortOrder
    clienteID?: SortOrder
    ultimaCitaID?: SortOrder
  }

  export type ActividadClienteMaxOrderByAggregateInput = {
    actividadID?: SortOrder
    clienteID?: SortOrder
    ultimaConexion?: SortOrder
    ultimaCitaID?: SortOrder
  }

  export type ActividadClienteMinOrderByAggregateInput = {
    actividadID?: SortOrder
    clienteID?: SortOrder
    ultimaConexion?: SortOrder
    ultimaCitaID?: SortOrder
  }

  export type ActividadClienteSumOrderByAggregateInput = {
    actividadID?: SortOrder
    clienteID?: SortOrder
    ultimaCitaID?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BitacoraClienteCountOrderByAggregateInput = {
    bitacoraID?: SortOrder
    clienteID?: SortOrder
    fechaRegistro?: SortOrder
  }

  export type BitacoraClienteAvgOrderByAggregateInput = {
    bitacoraID?: SortOrder
    clienteID?: SortOrder
  }

  export type BitacoraClienteMaxOrderByAggregateInput = {
    bitacoraID?: SortOrder
    clienteID?: SortOrder
    fechaRegistro?: SortOrder
  }

  export type BitacoraClienteMinOrderByAggregateInput = {
    bitacoraID?: SortOrder
    clienteID?: SortOrder
    fechaRegistro?: SortOrder
  }

  export type BitacoraClienteSumOrderByAggregateInput = {
    bitacoraID?: SortOrder
    clienteID?: SortOrder
  }

  export type BitacoraEstilistaCountOrderByAggregateInput = {
    bitacoraID?: SortOrder
    estilistaID?: SortOrder
    fechaIngreso?: SortOrder
    fechaSalida?: SortOrder
  }

  export type BitacoraEstilistaAvgOrderByAggregateInput = {
    bitacoraID?: SortOrder
    estilistaID?: SortOrder
  }

  export type BitacoraEstilistaMaxOrderByAggregateInput = {
    bitacoraID?: SortOrder
    estilistaID?: SortOrder
    fechaIngreso?: SortOrder
    fechaSalida?: SortOrder
  }

  export type BitacoraEstilistaMinOrderByAggregateInput = {
    bitacoraID?: SortOrder
    estilistaID?: SortOrder
    fechaIngreso?: SortOrder
    fechaSalida?: SortOrder
  }

  export type BitacoraEstilistaSumOrderByAggregateInput = {
    bitacoraID?: SortOrder
    estilistaID?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BloqueoHorariosCountOrderByAggregateInput = {
    bloqueoID?: SortOrder
    estilistaID?: SortOrder
    dia?: SortOrder
    horaInicio?: SortOrder
    horaFinal?: SortOrder
    motivo?: SortOrder
  }

  export type BloqueoHorariosAvgOrderByAggregateInput = {
    bloqueoID?: SortOrder
    estilistaID?: SortOrder
  }

  export type BloqueoHorariosMaxOrderByAggregateInput = {
    bloqueoID?: SortOrder
    estilistaID?: SortOrder
    dia?: SortOrder
    horaInicio?: SortOrder
    horaFinal?: SortOrder
    motivo?: SortOrder
  }

  export type BloqueoHorariosMinOrderByAggregateInput = {
    bloqueoID?: SortOrder
    estilistaID?: SortOrder
    dia?: SortOrder
    horaInicio?: SortOrder
    horaFinal?: SortOrder
    motivo?: SortOrder
  }

  export type BloqueoHorariosSumOrderByAggregateInput = {
    bloqueoID?: SortOrder
    estilistaID?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type ActividadClienteListRelationFilter = {
    every?: ActividadClienteWhereInput
    some?: ActividadClienteWhereInput
    none?: ActividadClienteWhereInput
  }

  export type EstadoCitaNullableRelationFilter = {
    is?: EstadoCitaWhereInput | null
    isNot?: EstadoCitaWhereInput | null
  }

  export type DetallesCitaListRelationFilter = {
    every?: DetallesCitaWhereInput
    some?: DetallesCitaWhereInput
    none?: DetallesCitaWhereInput
  }

  export type HistorialCitasListRelationFilter = {
    every?: HistorialCitasWhereInput
    some?: HistorialCitasWhereInput
    none?: HistorialCitasWhereInput
  }

  export type HorariosReservadosNullableRelationFilter = {
    is?: HorariosReservadosWhereInput | null
    isNot?: HorariosReservadosWhereInput | null
  }

  export type ActividadClienteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DetallesCitaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HistorialCitasOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CitasCountOrderByAggregateInput = {
    citaID?: SortOrder
    clienteID?: SortOrder
    estilistaID?: SortOrder
    comentarios?: SortOrder
    estadoID?: SortOrder
  }

  export type CitasAvgOrderByAggregateInput = {
    citaID?: SortOrder
    clienteID?: SortOrder
    estilistaID?: SortOrder
    estadoID?: SortOrder
  }

  export type CitasMaxOrderByAggregateInput = {
    citaID?: SortOrder
    clienteID?: SortOrder
    estilistaID?: SortOrder
    comentarios?: SortOrder
    estadoID?: SortOrder
  }

  export type CitasMinOrderByAggregateInput = {
    citaID?: SortOrder
    clienteID?: SortOrder
    estilistaID?: SortOrder
    comentarios?: SortOrder
    estadoID?: SortOrder
  }

  export type CitasSumOrderByAggregateInput = {
    citaID?: SortOrder
    clienteID?: SortOrder
    estilistaID?: SortOrder
    estadoID?: SortOrder
  }

  export type ServiciosNullableRelationFilter = {
    is?: ServiciosWhereInput | null
    isNot?: ServiciosWhereInput | null
  }

  export type DetallesCitaCountOrderByAggregateInput = {
    detalleID?: SortOrder
    citaID?: SortOrder
    servicioID?: SortOrder
  }

  export type DetallesCitaAvgOrderByAggregateInput = {
    detalleID?: SortOrder
    citaID?: SortOrder
    servicioID?: SortOrder
  }

  export type DetallesCitaMaxOrderByAggregateInput = {
    detalleID?: SortOrder
    citaID?: SortOrder
    servicioID?: SortOrder
  }

  export type DetallesCitaMinOrderByAggregateInput = {
    detalleID?: SortOrder
    citaID?: SortOrder
    servicioID?: SortOrder
  }

  export type DetallesCitaSumOrderByAggregateInput = {
    detalleID?: SortOrder
    citaID?: SortOrder
    servicioID?: SortOrder
  }

  export type CitasListRelationFilter = {
    every?: CitasWhereInput
    some?: CitasWhereInput
    none?: CitasWhereInput
  }

  export type CitasOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EstadoCitaCountOrderByAggregateInput = {
    estadoID?: SortOrder
    nombre?: SortOrder
  }

  export type EstadoCitaAvgOrderByAggregateInput = {
    estadoID?: SortOrder
  }

  export type EstadoCitaMaxOrderByAggregateInput = {
    estadoID?: SortOrder
    nombre?: SortOrder
  }

  export type EstadoCitaMinOrderByAggregateInput = {
    estadoID?: SortOrder
    nombre?: SortOrder
  }

  export type EstadoCitaSumOrderByAggregateInput = {
    estadoID?: SortOrder
  }

  export type HistorialCitasCountOrderByAggregateInput = {
    historialCitasID?: SortOrder
    clienteID?: SortOrder
    citaID?: SortOrder
  }

  export type HistorialCitasAvgOrderByAggregateInput = {
    historialCitasID?: SortOrder
    clienteID?: SortOrder
    citaID?: SortOrder
  }

  export type HistorialCitasMaxOrderByAggregateInput = {
    historialCitasID?: SortOrder
    clienteID?: SortOrder
    citaID?: SortOrder
  }

  export type HistorialCitasMinOrderByAggregateInput = {
    historialCitasID?: SortOrder
    clienteID?: SortOrder
    citaID?: SortOrder
  }

  export type HistorialCitasSumOrderByAggregateInput = {
    historialCitasID?: SortOrder
    clienteID?: SortOrder
    citaID?: SortOrder
  }

  export type HistorialRecompensasCountOrderByAggregateInput = {
    historialID?: SortOrder
    clienteID?: SortOrder
    servicioID?: SortOrder
    puntosCanjeados?: SortOrder
    fecha?: SortOrder
  }

  export type HistorialRecompensasAvgOrderByAggregateInput = {
    historialID?: SortOrder
    clienteID?: SortOrder
    servicioID?: SortOrder
    puntosCanjeados?: SortOrder
  }

  export type HistorialRecompensasMaxOrderByAggregateInput = {
    historialID?: SortOrder
    clienteID?: SortOrder
    servicioID?: SortOrder
    puntosCanjeados?: SortOrder
    fecha?: SortOrder
  }

  export type HistorialRecompensasMinOrderByAggregateInput = {
    historialID?: SortOrder
    clienteID?: SortOrder
    servicioID?: SortOrder
    puntosCanjeados?: SortOrder
    fecha?: SortOrder
  }

  export type HistorialRecompensasSumOrderByAggregateInput = {
    historialID?: SortOrder
    clienteID?: SortOrder
    servicioID?: SortOrder
    puntosCanjeados?: SortOrder
  }

  export type HorariosCountOrderByAggregateInput = {
    horariosID?: SortOrder
    estilistaID?: SortOrder
    diaSemana?: SortOrder
    horaInicio?: SortOrder
    horaFinal?: SortOrder
  }

  export type HorariosAvgOrderByAggregateInput = {
    horariosID?: SortOrder
    estilistaID?: SortOrder
  }

  export type HorariosMaxOrderByAggregateInput = {
    horariosID?: SortOrder
    estilistaID?: SortOrder
    diaSemana?: SortOrder
    horaInicio?: SortOrder
    horaFinal?: SortOrder
  }

  export type HorariosMinOrderByAggregateInput = {
    horariosID?: SortOrder
    estilistaID?: SortOrder
    diaSemana?: SortOrder
    horaInicio?: SortOrder
    horaFinal?: SortOrder
  }

  export type HorariosSumOrderByAggregateInput = {
    horariosID?: SortOrder
    estilistaID?: SortOrder
  }

  export type CitasRelationFilter = {
    is?: CitasWhereInput
    isNot?: CitasWhereInput
  }

  export type HorariosReservadosCountOrderByAggregateInput = {
    citaID?: SortOrder
    dia?: SortOrder
    hora_inicio?: SortOrder
    hora_fin?: SortOrder
  }

  export type HorariosReservadosAvgOrderByAggregateInput = {
    citaID?: SortOrder
  }

  export type HorariosReservadosMaxOrderByAggregateInput = {
    citaID?: SortOrder
    dia?: SortOrder
    hora_inicio?: SortOrder
    hora_fin?: SortOrder
  }

  export type HorariosReservadosMinOrderByAggregateInput = {
    citaID?: SortOrder
    dia?: SortOrder
    hora_inicio?: SortOrder
    hora_fin?: SortOrder
  }

  export type HorariosReservadosSumOrderByAggregateInput = {
    citaID?: SortOrder
  }

  export type PuntosClientesCountOrderByAggregateInput = {
    puntosID?: SortOrder
    clienteID?: SortOrder
    puntosAcumulados?: SortOrder
    puntosCanjeados?: SortOrder
  }

  export type PuntosClientesAvgOrderByAggregateInput = {
    puntosID?: SortOrder
    clienteID?: SortOrder
    puntosAcumulados?: SortOrder
    puntosCanjeados?: SortOrder
  }

  export type PuntosClientesMaxOrderByAggregateInput = {
    puntosID?: SortOrder
    clienteID?: SortOrder
    puntosAcumulados?: SortOrder
    puntosCanjeados?: SortOrder
  }

  export type PuntosClientesMinOrderByAggregateInput = {
    puntosID?: SortOrder
    clienteID?: SortOrder
    puntosAcumulados?: SortOrder
    puntosCanjeados?: SortOrder
  }

  export type PuntosClientesSumOrderByAggregateInput = {
    puntosID?: SortOrder
    clienteID?: SortOrder
    puntosAcumulados?: SortOrder
    puntosCanjeados?: SortOrder
  }

  export type ServiciosRelationFilter = {
    is?: ServiciosWhereInput
    isNot?: ServiciosWhereInput
  }

  export type PuntosServicioCountOrderByAggregateInput = {
    servicioID?: SortOrder
    puntosGenerados?: SortOrder
  }

  export type PuntosServicioAvgOrderByAggregateInput = {
    servicioID?: SortOrder
    puntosGenerados?: SortOrder
  }

  export type PuntosServicioMaxOrderByAggregateInput = {
    servicioID?: SortOrder
    puntosGenerados?: SortOrder
  }

  export type PuntosServicioMinOrderByAggregateInput = {
    servicioID?: SortOrder
    puntosGenerados?: SortOrder
  }

  export type PuntosServicioSumOrderByAggregateInput = {
    servicioID?: SortOrder
    puntosGenerados?: SortOrder
  }

  export type UsuariosListRelationFilter = {
    every?: UsuariosWhereInput
    some?: UsuariosWhereInput
    none?: UsuariosWhereInput
  }

  export type UsuariosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RolesCountOrderByAggregateInput = {
    rolID?: SortOrder
    nombreRol?: SortOrder
  }

  export type RolesAvgOrderByAggregateInput = {
    rolID?: SortOrder
  }

  export type RolesMaxOrderByAggregateInput = {
    rolID?: SortOrder
    nombreRol?: SortOrder
  }

  export type RolesMinOrderByAggregateInput = {
    rolID?: SortOrder
    nombreRol?: SortOrder
  }

  export type RolesSumOrderByAggregateInput = {
    rolID?: SortOrder
  }

  export type HistorialRecompensasListRelationFilter = {
    every?: HistorialRecompensasWhereInput
    some?: HistorialRecompensasWhereInput
    none?: HistorialRecompensasWhereInput
  }

  export type PuntosServicioNullableRelationFilter = {
    is?: PuntosServicioWhereInput | null
    isNot?: PuntosServicioWhereInput | null
  }

  export type HistorialRecompensasOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiciosCountOrderByAggregateInput = {
    servicioID?: SortOrder
    nombreServicio?: SortOrder
    descripcion?: SortOrder
    tiempoEstimado?: SortOrder
    precio?: SortOrder
    rutaImagen?: SortOrder
  }

  export type ServiciosAvgOrderByAggregateInput = {
    servicioID?: SortOrder
    precio?: SortOrder
  }

  export type ServiciosMaxOrderByAggregateInput = {
    servicioID?: SortOrder
    nombreServicio?: SortOrder
    descripcion?: SortOrder
    tiempoEstimado?: SortOrder
    precio?: SortOrder
    rutaImagen?: SortOrder
  }

  export type ServiciosMinOrderByAggregateInput = {
    servicioID?: SortOrder
    nombreServicio?: SortOrder
    descripcion?: SortOrder
    tiempoEstimado?: SortOrder
    precio?: SortOrder
    rutaImagen?: SortOrder
  }

  export type ServiciosSumOrderByAggregateInput = {
    servicioID?: SortOrder
    precio?: SortOrder
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BitacoraClienteListRelationFilter = {
    every?: BitacoraClienteWhereInput
    some?: BitacoraClienteWhereInput
    none?: BitacoraClienteWhereInput
  }

  export type BitacoraEstilistaListRelationFilter = {
    every?: BitacoraEstilistaWhereInput
    some?: BitacoraEstilistaWhereInput
    none?: BitacoraEstilistaWhereInput
  }

  export type BloqueoHorariosListRelationFilter = {
    every?: BloqueoHorariosWhereInput
    some?: BloqueoHorariosWhereInput
    none?: BloqueoHorariosWhereInput
  }

  export type HorariosListRelationFilter = {
    every?: HorariosWhereInput
    some?: HorariosWhereInput
    none?: HorariosWhereInput
  }

  export type PuntosClientesListRelationFilter = {
    every?: PuntosClientesWhereInput
    some?: PuntosClientesWhereInput
    none?: PuntosClientesWhereInput
  }

  export type RolesNullableRelationFilter = {
    is?: RolesWhereInput | null
    isNot?: RolesWhereInput | null
  }

  export type BitacoraClienteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BitacoraEstilistaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BloqueoHorariosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HorariosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PuntosClientesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsuariosCountOrderByAggregateInput = {
    usuarioID?: SortOrder
    nombre?: SortOrder
    apellidos?: SortOrder
    telefono?: SortOrder
    correo?: SortOrder
    direccion?: SortOrder
    contra?: SortOrder
    rolID?: SortOrder
    estado?: SortOrder
  }

  export type UsuariosAvgOrderByAggregateInput = {
    usuarioID?: SortOrder
    rolID?: SortOrder
  }

  export type UsuariosMaxOrderByAggregateInput = {
    usuarioID?: SortOrder
    nombre?: SortOrder
    apellidos?: SortOrder
    telefono?: SortOrder
    correo?: SortOrder
    direccion?: SortOrder
    contra?: SortOrder
    rolID?: SortOrder
    estado?: SortOrder
  }

  export type UsuariosMinOrderByAggregateInput = {
    usuarioID?: SortOrder
    nombre?: SortOrder
    apellidos?: SortOrder
    telefono?: SortOrder
    correo?: SortOrder
    direccion?: SortOrder
    contra?: SortOrder
    rolID?: SortOrder
    estado?: SortOrder
  }

  export type UsuariosSumOrderByAggregateInput = {
    usuarioID?: SortOrder
    rolID?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type UsuariosCreateNestedOneWithoutActividadClienteInput = {
    create?: XOR<UsuariosCreateWithoutActividadClienteInput, UsuariosUncheckedCreateWithoutActividadClienteInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutActividadClienteInput
    connect?: UsuariosWhereUniqueInput
  }

  export type CitasCreateNestedOneWithoutActividadClienteInput = {
    create?: XOR<CitasCreateWithoutActividadClienteInput, CitasUncheckedCreateWithoutActividadClienteInput>
    connectOrCreate?: CitasCreateOrConnectWithoutActividadClienteInput
    connect?: CitasWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UsuariosUpdateOneWithoutActividadClienteNestedInput = {
    create?: XOR<UsuariosCreateWithoutActividadClienteInput, UsuariosUncheckedCreateWithoutActividadClienteInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutActividadClienteInput
    upsert?: UsuariosUpsertWithoutActividadClienteInput
    disconnect?: UsuariosWhereInput | boolean
    delete?: UsuariosWhereInput | boolean
    connect?: UsuariosWhereUniqueInput
    update?: XOR<XOR<UsuariosUpdateToOneWithWhereWithoutActividadClienteInput, UsuariosUpdateWithoutActividadClienteInput>, UsuariosUncheckedUpdateWithoutActividadClienteInput>
  }

  export type CitasUpdateOneWithoutActividadClienteNestedInput = {
    create?: XOR<CitasCreateWithoutActividadClienteInput, CitasUncheckedCreateWithoutActividadClienteInput>
    connectOrCreate?: CitasCreateOrConnectWithoutActividadClienteInput
    upsert?: CitasUpsertWithoutActividadClienteInput
    disconnect?: CitasWhereInput | boolean
    delete?: CitasWhereInput | boolean
    connect?: CitasWhereUniqueInput
    update?: XOR<XOR<CitasUpdateToOneWithWhereWithoutActividadClienteInput, CitasUpdateWithoutActividadClienteInput>, CitasUncheckedUpdateWithoutActividadClienteInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UsuariosCreateNestedOneWithoutBitacoraClienteInput = {
    create?: XOR<UsuariosCreateWithoutBitacoraClienteInput, UsuariosUncheckedCreateWithoutBitacoraClienteInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutBitacoraClienteInput
    connect?: UsuariosWhereUniqueInput
  }

  export type UsuariosUpdateOneWithoutBitacoraClienteNestedInput = {
    create?: XOR<UsuariosCreateWithoutBitacoraClienteInput, UsuariosUncheckedCreateWithoutBitacoraClienteInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutBitacoraClienteInput
    upsert?: UsuariosUpsertWithoutBitacoraClienteInput
    disconnect?: UsuariosWhereInput | boolean
    delete?: UsuariosWhereInput | boolean
    connect?: UsuariosWhereUniqueInput
    update?: XOR<XOR<UsuariosUpdateToOneWithWhereWithoutBitacoraClienteInput, UsuariosUpdateWithoutBitacoraClienteInput>, UsuariosUncheckedUpdateWithoutBitacoraClienteInput>
  }

  export type UsuariosCreateNestedOneWithoutBitacoraEstilistaInput = {
    create?: XOR<UsuariosCreateWithoutBitacoraEstilistaInput, UsuariosUncheckedCreateWithoutBitacoraEstilistaInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutBitacoraEstilistaInput
    connect?: UsuariosWhereUniqueInput
  }

  export type UsuariosUpdateOneWithoutBitacoraEstilistaNestedInput = {
    create?: XOR<UsuariosCreateWithoutBitacoraEstilistaInput, UsuariosUncheckedCreateWithoutBitacoraEstilistaInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutBitacoraEstilistaInput
    upsert?: UsuariosUpsertWithoutBitacoraEstilistaInput
    disconnect?: UsuariosWhereInput | boolean
    delete?: UsuariosWhereInput | boolean
    connect?: UsuariosWhereUniqueInput
    update?: XOR<XOR<UsuariosUpdateToOneWithWhereWithoutBitacoraEstilistaInput, UsuariosUpdateWithoutBitacoraEstilistaInput>, UsuariosUncheckedUpdateWithoutBitacoraEstilistaInput>
  }

  export type UsuariosCreateNestedOneWithoutBloqueoHorariosInput = {
    create?: XOR<UsuariosCreateWithoutBloqueoHorariosInput, UsuariosUncheckedCreateWithoutBloqueoHorariosInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutBloqueoHorariosInput
    connect?: UsuariosWhereUniqueInput
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type UsuariosUpdateOneWithoutBloqueoHorariosNestedInput = {
    create?: XOR<UsuariosCreateWithoutBloqueoHorariosInput, UsuariosUncheckedCreateWithoutBloqueoHorariosInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutBloqueoHorariosInput
    upsert?: UsuariosUpsertWithoutBloqueoHorariosInput
    disconnect?: UsuariosWhereInput | boolean
    delete?: UsuariosWhereInput | boolean
    connect?: UsuariosWhereUniqueInput
    update?: XOR<XOR<UsuariosUpdateToOneWithWhereWithoutBloqueoHorariosInput, UsuariosUpdateWithoutBloqueoHorariosInput>, UsuariosUncheckedUpdateWithoutBloqueoHorariosInput>
  }

  export type ActividadClienteCreateNestedManyWithoutCitasInput = {
    create?: XOR<ActividadClienteCreateWithoutCitasInput, ActividadClienteUncheckedCreateWithoutCitasInput> | ActividadClienteCreateWithoutCitasInput[] | ActividadClienteUncheckedCreateWithoutCitasInput[]
    connectOrCreate?: ActividadClienteCreateOrConnectWithoutCitasInput | ActividadClienteCreateOrConnectWithoutCitasInput[]
    createMany?: ActividadClienteCreateManyCitasInputEnvelope
    connect?: ActividadClienteWhereUniqueInput | ActividadClienteWhereUniqueInput[]
  }

  export type UsuariosCreateNestedOneWithoutCitas_Citas_clienteIDToUsuariosInput = {
    create?: XOR<UsuariosCreateWithoutCitas_Citas_clienteIDToUsuariosInput, UsuariosUncheckedCreateWithoutCitas_Citas_clienteIDToUsuariosInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutCitas_Citas_clienteIDToUsuariosInput
    connect?: UsuariosWhereUniqueInput
  }

  export type EstadoCitaCreateNestedOneWithoutCitasInput = {
    create?: XOR<EstadoCitaCreateWithoutCitasInput, EstadoCitaUncheckedCreateWithoutCitasInput>
    connectOrCreate?: EstadoCitaCreateOrConnectWithoutCitasInput
    connect?: EstadoCitaWhereUniqueInput
  }

  export type UsuariosCreateNestedOneWithoutCitas_Citas_estilistaIDToUsuariosInput = {
    create?: XOR<UsuariosCreateWithoutCitas_Citas_estilistaIDToUsuariosInput, UsuariosUncheckedCreateWithoutCitas_Citas_estilistaIDToUsuariosInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutCitas_Citas_estilistaIDToUsuariosInput
    connect?: UsuariosWhereUniqueInput
  }

  export type DetallesCitaCreateNestedManyWithoutCitasInput = {
    create?: XOR<DetallesCitaCreateWithoutCitasInput, DetallesCitaUncheckedCreateWithoutCitasInput> | DetallesCitaCreateWithoutCitasInput[] | DetallesCitaUncheckedCreateWithoutCitasInput[]
    connectOrCreate?: DetallesCitaCreateOrConnectWithoutCitasInput | DetallesCitaCreateOrConnectWithoutCitasInput[]
    createMany?: DetallesCitaCreateManyCitasInputEnvelope
    connect?: DetallesCitaWhereUniqueInput | DetallesCitaWhereUniqueInput[]
  }

  export type HistorialCitasCreateNestedManyWithoutCitasInput = {
    create?: XOR<HistorialCitasCreateWithoutCitasInput, HistorialCitasUncheckedCreateWithoutCitasInput> | HistorialCitasCreateWithoutCitasInput[] | HistorialCitasUncheckedCreateWithoutCitasInput[]
    connectOrCreate?: HistorialCitasCreateOrConnectWithoutCitasInput | HistorialCitasCreateOrConnectWithoutCitasInput[]
    createMany?: HistorialCitasCreateManyCitasInputEnvelope
    connect?: HistorialCitasWhereUniqueInput | HistorialCitasWhereUniqueInput[]
  }

  export type HorariosReservadosCreateNestedOneWithoutCitasInput = {
    create?: XOR<HorariosReservadosCreateWithoutCitasInput, HorariosReservadosUncheckedCreateWithoutCitasInput>
    connectOrCreate?: HorariosReservadosCreateOrConnectWithoutCitasInput
    connect?: HorariosReservadosWhereUniqueInput
  }

  export type ActividadClienteUncheckedCreateNestedManyWithoutCitasInput = {
    create?: XOR<ActividadClienteCreateWithoutCitasInput, ActividadClienteUncheckedCreateWithoutCitasInput> | ActividadClienteCreateWithoutCitasInput[] | ActividadClienteUncheckedCreateWithoutCitasInput[]
    connectOrCreate?: ActividadClienteCreateOrConnectWithoutCitasInput | ActividadClienteCreateOrConnectWithoutCitasInput[]
    createMany?: ActividadClienteCreateManyCitasInputEnvelope
    connect?: ActividadClienteWhereUniqueInput | ActividadClienteWhereUniqueInput[]
  }

  export type DetallesCitaUncheckedCreateNestedManyWithoutCitasInput = {
    create?: XOR<DetallesCitaCreateWithoutCitasInput, DetallesCitaUncheckedCreateWithoutCitasInput> | DetallesCitaCreateWithoutCitasInput[] | DetallesCitaUncheckedCreateWithoutCitasInput[]
    connectOrCreate?: DetallesCitaCreateOrConnectWithoutCitasInput | DetallesCitaCreateOrConnectWithoutCitasInput[]
    createMany?: DetallesCitaCreateManyCitasInputEnvelope
    connect?: DetallesCitaWhereUniqueInput | DetallesCitaWhereUniqueInput[]
  }

  export type HistorialCitasUncheckedCreateNestedManyWithoutCitasInput = {
    create?: XOR<HistorialCitasCreateWithoutCitasInput, HistorialCitasUncheckedCreateWithoutCitasInput> | HistorialCitasCreateWithoutCitasInput[] | HistorialCitasUncheckedCreateWithoutCitasInput[]
    connectOrCreate?: HistorialCitasCreateOrConnectWithoutCitasInput | HistorialCitasCreateOrConnectWithoutCitasInput[]
    createMany?: HistorialCitasCreateManyCitasInputEnvelope
    connect?: HistorialCitasWhereUniqueInput | HistorialCitasWhereUniqueInput[]
  }

  export type HorariosReservadosUncheckedCreateNestedOneWithoutCitasInput = {
    create?: XOR<HorariosReservadosCreateWithoutCitasInput, HorariosReservadosUncheckedCreateWithoutCitasInput>
    connectOrCreate?: HorariosReservadosCreateOrConnectWithoutCitasInput
    connect?: HorariosReservadosWhereUniqueInput
  }

  export type ActividadClienteUpdateManyWithoutCitasNestedInput = {
    create?: XOR<ActividadClienteCreateWithoutCitasInput, ActividadClienteUncheckedCreateWithoutCitasInput> | ActividadClienteCreateWithoutCitasInput[] | ActividadClienteUncheckedCreateWithoutCitasInput[]
    connectOrCreate?: ActividadClienteCreateOrConnectWithoutCitasInput | ActividadClienteCreateOrConnectWithoutCitasInput[]
    upsert?: ActividadClienteUpsertWithWhereUniqueWithoutCitasInput | ActividadClienteUpsertWithWhereUniqueWithoutCitasInput[]
    createMany?: ActividadClienteCreateManyCitasInputEnvelope
    set?: ActividadClienteWhereUniqueInput | ActividadClienteWhereUniqueInput[]
    disconnect?: ActividadClienteWhereUniqueInput | ActividadClienteWhereUniqueInput[]
    delete?: ActividadClienteWhereUniqueInput | ActividadClienteWhereUniqueInput[]
    connect?: ActividadClienteWhereUniqueInput | ActividadClienteWhereUniqueInput[]
    update?: ActividadClienteUpdateWithWhereUniqueWithoutCitasInput | ActividadClienteUpdateWithWhereUniqueWithoutCitasInput[]
    updateMany?: ActividadClienteUpdateManyWithWhereWithoutCitasInput | ActividadClienteUpdateManyWithWhereWithoutCitasInput[]
    deleteMany?: ActividadClienteScalarWhereInput | ActividadClienteScalarWhereInput[]
  }

  export type UsuariosUpdateOneWithoutCitas_Citas_clienteIDToUsuariosNestedInput = {
    create?: XOR<UsuariosCreateWithoutCitas_Citas_clienteIDToUsuariosInput, UsuariosUncheckedCreateWithoutCitas_Citas_clienteIDToUsuariosInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutCitas_Citas_clienteIDToUsuariosInput
    upsert?: UsuariosUpsertWithoutCitas_Citas_clienteIDToUsuariosInput
    disconnect?: UsuariosWhereInput | boolean
    delete?: UsuariosWhereInput | boolean
    connect?: UsuariosWhereUniqueInput
    update?: XOR<XOR<UsuariosUpdateToOneWithWhereWithoutCitas_Citas_clienteIDToUsuariosInput, UsuariosUpdateWithoutCitas_Citas_clienteIDToUsuariosInput>, UsuariosUncheckedUpdateWithoutCitas_Citas_clienteIDToUsuariosInput>
  }

  export type EstadoCitaUpdateOneWithoutCitasNestedInput = {
    create?: XOR<EstadoCitaCreateWithoutCitasInput, EstadoCitaUncheckedCreateWithoutCitasInput>
    connectOrCreate?: EstadoCitaCreateOrConnectWithoutCitasInput
    upsert?: EstadoCitaUpsertWithoutCitasInput
    disconnect?: EstadoCitaWhereInput | boolean
    delete?: EstadoCitaWhereInput | boolean
    connect?: EstadoCitaWhereUniqueInput
    update?: XOR<XOR<EstadoCitaUpdateToOneWithWhereWithoutCitasInput, EstadoCitaUpdateWithoutCitasInput>, EstadoCitaUncheckedUpdateWithoutCitasInput>
  }

  export type UsuariosUpdateOneWithoutCitas_Citas_estilistaIDToUsuariosNestedInput = {
    create?: XOR<UsuariosCreateWithoutCitas_Citas_estilistaIDToUsuariosInput, UsuariosUncheckedCreateWithoutCitas_Citas_estilistaIDToUsuariosInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutCitas_Citas_estilistaIDToUsuariosInput
    upsert?: UsuariosUpsertWithoutCitas_Citas_estilistaIDToUsuariosInput
    disconnect?: UsuariosWhereInput | boolean
    delete?: UsuariosWhereInput | boolean
    connect?: UsuariosWhereUniqueInput
    update?: XOR<XOR<UsuariosUpdateToOneWithWhereWithoutCitas_Citas_estilistaIDToUsuariosInput, UsuariosUpdateWithoutCitas_Citas_estilistaIDToUsuariosInput>, UsuariosUncheckedUpdateWithoutCitas_Citas_estilistaIDToUsuariosInput>
  }

  export type DetallesCitaUpdateManyWithoutCitasNestedInput = {
    create?: XOR<DetallesCitaCreateWithoutCitasInput, DetallesCitaUncheckedCreateWithoutCitasInput> | DetallesCitaCreateWithoutCitasInput[] | DetallesCitaUncheckedCreateWithoutCitasInput[]
    connectOrCreate?: DetallesCitaCreateOrConnectWithoutCitasInput | DetallesCitaCreateOrConnectWithoutCitasInput[]
    upsert?: DetallesCitaUpsertWithWhereUniqueWithoutCitasInput | DetallesCitaUpsertWithWhereUniqueWithoutCitasInput[]
    createMany?: DetallesCitaCreateManyCitasInputEnvelope
    set?: DetallesCitaWhereUniqueInput | DetallesCitaWhereUniqueInput[]
    disconnect?: DetallesCitaWhereUniqueInput | DetallesCitaWhereUniqueInput[]
    delete?: DetallesCitaWhereUniqueInput | DetallesCitaWhereUniqueInput[]
    connect?: DetallesCitaWhereUniqueInput | DetallesCitaWhereUniqueInput[]
    update?: DetallesCitaUpdateWithWhereUniqueWithoutCitasInput | DetallesCitaUpdateWithWhereUniqueWithoutCitasInput[]
    updateMany?: DetallesCitaUpdateManyWithWhereWithoutCitasInput | DetallesCitaUpdateManyWithWhereWithoutCitasInput[]
    deleteMany?: DetallesCitaScalarWhereInput | DetallesCitaScalarWhereInput[]
  }

  export type HistorialCitasUpdateManyWithoutCitasNestedInput = {
    create?: XOR<HistorialCitasCreateWithoutCitasInput, HistorialCitasUncheckedCreateWithoutCitasInput> | HistorialCitasCreateWithoutCitasInput[] | HistorialCitasUncheckedCreateWithoutCitasInput[]
    connectOrCreate?: HistorialCitasCreateOrConnectWithoutCitasInput | HistorialCitasCreateOrConnectWithoutCitasInput[]
    upsert?: HistorialCitasUpsertWithWhereUniqueWithoutCitasInput | HistorialCitasUpsertWithWhereUniqueWithoutCitasInput[]
    createMany?: HistorialCitasCreateManyCitasInputEnvelope
    set?: HistorialCitasWhereUniqueInput | HistorialCitasWhereUniqueInput[]
    disconnect?: HistorialCitasWhereUniqueInput | HistorialCitasWhereUniqueInput[]
    delete?: HistorialCitasWhereUniqueInput | HistorialCitasWhereUniqueInput[]
    connect?: HistorialCitasWhereUniqueInput | HistorialCitasWhereUniqueInput[]
    update?: HistorialCitasUpdateWithWhereUniqueWithoutCitasInput | HistorialCitasUpdateWithWhereUniqueWithoutCitasInput[]
    updateMany?: HistorialCitasUpdateManyWithWhereWithoutCitasInput | HistorialCitasUpdateManyWithWhereWithoutCitasInput[]
    deleteMany?: HistorialCitasScalarWhereInput | HistorialCitasScalarWhereInput[]
  }

  export type HorariosReservadosUpdateOneWithoutCitasNestedInput = {
    create?: XOR<HorariosReservadosCreateWithoutCitasInput, HorariosReservadosUncheckedCreateWithoutCitasInput>
    connectOrCreate?: HorariosReservadosCreateOrConnectWithoutCitasInput
    upsert?: HorariosReservadosUpsertWithoutCitasInput
    disconnect?: HorariosReservadosWhereInput | boolean
    delete?: HorariosReservadosWhereInput | boolean
    connect?: HorariosReservadosWhereUniqueInput
    update?: XOR<XOR<HorariosReservadosUpdateToOneWithWhereWithoutCitasInput, HorariosReservadosUpdateWithoutCitasInput>, HorariosReservadosUncheckedUpdateWithoutCitasInput>
  }

  export type ActividadClienteUncheckedUpdateManyWithoutCitasNestedInput = {
    create?: XOR<ActividadClienteCreateWithoutCitasInput, ActividadClienteUncheckedCreateWithoutCitasInput> | ActividadClienteCreateWithoutCitasInput[] | ActividadClienteUncheckedCreateWithoutCitasInput[]
    connectOrCreate?: ActividadClienteCreateOrConnectWithoutCitasInput | ActividadClienteCreateOrConnectWithoutCitasInput[]
    upsert?: ActividadClienteUpsertWithWhereUniqueWithoutCitasInput | ActividadClienteUpsertWithWhereUniqueWithoutCitasInput[]
    createMany?: ActividadClienteCreateManyCitasInputEnvelope
    set?: ActividadClienteWhereUniqueInput | ActividadClienteWhereUniqueInput[]
    disconnect?: ActividadClienteWhereUniqueInput | ActividadClienteWhereUniqueInput[]
    delete?: ActividadClienteWhereUniqueInput | ActividadClienteWhereUniqueInput[]
    connect?: ActividadClienteWhereUniqueInput | ActividadClienteWhereUniqueInput[]
    update?: ActividadClienteUpdateWithWhereUniqueWithoutCitasInput | ActividadClienteUpdateWithWhereUniqueWithoutCitasInput[]
    updateMany?: ActividadClienteUpdateManyWithWhereWithoutCitasInput | ActividadClienteUpdateManyWithWhereWithoutCitasInput[]
    deleteMany?: ActividadClienteScalarWhereInput | ActividadClienteScalarWhereInput[]
  }

  export type DetallesCitaUncheckedUpdateManyWithoutCitasNestedInput = {
    create?: XOR<DetallesCitaCreateWithoutCitasInput, DetallesCitaUncheckedCreateWithoutCitasInput> | DetallesCitaCreateWithoutCitasInput[] | DetallesCitaUncheckedCreateWithoutCitasInput[]
    connectOrCreate?: DetallesCitaCreateOrConnectWithoutCitasInput | DetallesCitaCreateOrConnectWithoutCitasInput[]
    upsert?: DetallesCitaUpsertWithWhereUniqueWithoutCitasInput | DetallesCitaUpsertWithWhereUniqueWithoutCitasInput[]
    createMany?: DetallesCitaCreateManyCitasInputEnvelope
    set?: DetallesCitaWhereUniqueInput | DetallesCitaWhereUniqueInput[]
    disconnect?: DetallesCitaWhereUniqueInput | DetallesCitaWhereUniqueInput[]
    delete?: DetallesCitaWhereUniqueInput | DetallesCitaWhereUniqueInput[]
    connect?: DetallesCitaWhereUniqueInput | DetallesCitaWhereUniqueInput[]
    update?: DetallesCitaUpdateWithWhereUniqueWithoutCitasInput | DetallesCitaUpdateWithWhereUniqueWithoutCitasInput[]
    updateMany?: DetallesCitaUpdateManyWithWhereWithoutCitasInput | DetallesCitaUpdateManyWithWhereWithoutCitasInput[]
    deleteMany?: DetallesCitaScalarWhereInput | DetallesCitaScalarWhereInput[]
  }

  export type HistorialCitasUncheckedUpdateManyWithoutCitasNestedInput = {
    create?: XOR<HistorialCitasCreateWithoutCitasInput, HistorialCitasUncheckedCreateWithoutCitasInput> | HistorialCitasCreateWithoutCitasInput[] | HistorialCitasUncheckedCreateWithoutCitasInput[]
    connectOrCreate?: HistorialCitasCreateOrConnectWithoutCitasInput | HistorialCitasCreateOrConnectWithoutCitasInput[]
    upsert?: HistorialCitasUpsertWithWhereUniqueWithoutCitasInput | HistorialCitasUpsertWithWhereUniqueWithoutCitasInput[]
    createMany?: HistorialCitasCreateManyCitasInputEnvelope
    set?: HistorialCitasWhereUniqueInput | HistorialCitasWhereUniqueInput[]
    disconnect?: HistorialCitasWhereUniqueInput | HistorialCitasWhereUniqueInput[]
    delete?: HistorialCitasWhereUniqueInput | HistorialCitasWhereUniqueInput[]
    connect?: HistorialCitasWhereUniqueInput | HistorialCitasWhereUniqueInput[]
    update?: HistorialCitasUpdateWithWhereUniqueWithoutCitasInput | HistorialCitasUpdateWithWhereUniqueWithoutCitasInput[]
    updateMany?: HistorialCitasUpdateManyWithWhereWithoutCitasInput | HistorialCitasUpdateManyWithWhereWithoutCitasInput[]
    deleteMany?: HistorialCitasScalarWhereInput | HistorialCitasScalarWhereInput[]
  }

  export type HorariosReservadosUncheckedUpdateOneWithoutCitasNestedInput = {
    create?: XOR<HorariosReservadosCreateWithoutCitasInput, HorariosReservadosUncheckedCreateWithoutCitasInput>
    connectOrCreate?: HorariosReservadosCreateOrConnectWithoutCitasInput
    upsert?: HorariosReservadosUpsertWithoutCitasInput
    disconnect?: HorariosReservadosWhereInput | boolean
    delete?: HorariosReservadosWhereInput | boolean
    connect?: HorariosReservadosWhereUniqueInput
    update?: XOR<XOR<HorariosReservadosUpdateToOneWithWhereWithoutCitasInput, HorariosReservadosUpdateWithoutCitasInput>, HorariosReservadosUncheckedUpdateWithoutCitasInput>
  }

  export type CitasCreateNestedOneWithoutDetallesCitaInput = {
    create?: XOR<CitasCreateWithoutDetallesCitaInput, CitasUncheckedCreateWithoutDetallesCitaInput>
    connectOrCreate?: CitasCreateOrConnectWithoutDetallesCitaInput
    connect?: CitasWhereUniqueInput
  }

  export type ServiciosCreateNestedOneWithoutDetallesCitaInput = {
    create?: XOR<ServiciosCreateWithoutDetallesCitaInput, ServiciosUncheckedCreateWithoutDetallesCitaInput>
    connectOrCreate?: ServiciosCreateOrConnectWithoutDetallesCitaInput
    connect?: ServiciosWhereUniqueInput
  }

  export type CitasUpdateOneWithoutDetallesCitaNestedInput = {
    create?: XOR<CitasCreateWithoutDetallesCitaInput, CitasUncheckedCreateWithoutDetallesCitaInput>
    connectOrCreate?: CitasCreateOrConnectWithoutDetallesCitaInput
    upsert?: CitasUpsertWithoutDetallesCitaInput
    disconnect?: CitasWhereInput | boolean
    delete?: CitasWhereInput | boolean
    connect?: CitasWhereUniqueInput
    update?: XOR<XOR<CitasUpdateToOneWithWhereWithoutDetallesCitaInput, CitasUpdateWithoutDetallesCitaInput>, CitasUncheckedUpdateWithoutDetallesCitaInput>
  }

  export type ServiciosUpdateOneWithoutDetallesCitaNestedInput = {
    create?: XOR<ServiciosCreateWithoutDetallesCitaInput, ServiciosUncheckedCreateWithoutDetallesCitaInput>
    connectOrCreate?: ServiciosCreateOrConnectWithoutDetallesCitaInput
    upsert?: ServiciosUpsertWithoutDetallesCitaInput
    disconnect?: ServiciosWhereInput | boolean
    delete?: ServiciosWhereInput | boolean
    connect?: ServiciosWhereUniqueInput
    update?: XOR<XOR<ServiciosUpdateToOneWithWhereWithoutDetallesCitaInput, ServiciosUpdateWithoutDetallesCitaInput>, ServiciosUncheckedUpdateWithoutDetallesCitaInput>
  }

  export type CitasCreateNestedManyWithoutEstadoCitaInput = {
    create?: XOR<CitasCreateWithoutEstadoCitaInput, CitasUncheckedCreateWithoutEstadoCitaInput> | CitasCreateWithoutEstadoCitaInput[] | CitasUncheckedCreateWithoutEstadoCitaInput[]
    connectOrCreate?: CitasCreateOrConnectWithoutEstadoCitaInput | CitasCreateOrConnectWithoutEstadoCitaInput[]
    createMany?: CitasCreateManyEstadoCitaInputEnvelope
    connect?: CitasWhereUniqueInput | CitasWhereUniqueInput[]
  }

  export type CitasUncheckedCreateNestedManyWithoutEstadoCitaInput = {
    create?: XOR<CitasCreateWithoutEstadoCitaInput, CitasUncheckedCreateWithoutEstadoCitaInput> | CitasCreateWithoutEstadoCitaInput[] | CitasUncheckedCreateWithoutEstadoCitaInput[]
    connectOrCreate?: CitasCreateOrConnectWithoutEstadoCitaInput | CitasCreateOrConnectWithoutEstadoCitaInput[]
    createMany?: CitasCreateManyEstadoCitaInputEnvelope
    connect?: CitasWhereUniqueInput | CitasWhereUniqueInput[]
  }

  export type CitasUpdateManyWithoutEstadoCitaNestedInput = {
    create?: XOR<CitasCreateWithoutEstadoCitaInput, CitasUncheckedCreateWithoutEstadoCitaInput> | CitasCreateWithoutEstadoCitaInput[] | CitasUncheckedCreateWithoutEstadoCitaInput[]
    connectOrCreate?: CitasCreateOrConnectWithoutEstadoCitaInput | CitasCreateOrConnectWithoutEstadoCitaInput[]
    upsert?: CitasUpsertWithWhereUniqueWithoutEstadoCitaInput | CitasUpsertWithWhereUniqueWithoutEstadoCitaInput[]
    createMany?: CitasCreateManyEstadoCitaInputEnvelope
    set?: CitasWhereUniqueInput | CitasWhereUniqueInput[]
    disconnect?: CitasWhereUniqueInput | CitasWhereUniqueInput[]
    delete?: CitasWhereUniqueInput | CitasWhereUniqueInput[]
    connect?: CitasWhereUniqueInput | CitasWhereUniqueInput[]
    update?: CitasUpdateWithWhereUniqueWithoutEstadoCitaInput | CitasUpdateWithWhereUniqueWithoutEstadoCitaInput[]
    updateMany?: CitasUpdateManyWithWhereWithoutEstadoCitaInput | CitasUpdateManyWithWhereWithoutEstadoCitaInput[]
    deleteMany?: CitasScalarWhereInput | CitasScalarWhereInput[]
  }

  export type CitasUncheckedUpdateManyWithoutEstadoCitaNestedInput = {
    create?: XOR<CitasCreateWithoutEstadoCitaInput, CitasUncheckedCreateWithoutEstadoCitaInput> | CitasCreateWithoutEstadoCitaInput[] | CitasUncheckedCreateWithoutEstadoCitaInput[]
    connectOrCreate?: CitasCreateOrConnectWithoutEstadoCitaInput | CitasCreateOrConnectWithoutEstadoCitaInput[]
    upsert?: CitasUpsertWithWhereUniqueWithoutEstadoCitaInput | CitasUpsertWithWhereUniqueWithoutEstadoCitaInput[]
    createMany?: CitasCreateManyEstadoCitaInputEnvelope
    set?: CitasWhereUniqueInput | CitasWhereUniqueInput[]
    disconnect?: CitasWhereUniqueInput | CitasWhereUniqueInput[]
    delete?: CitasWhereUniqueInput | CitasWhereUniqueInput[]
    connect?: CitasWhereUniqueInput | CitasWhereUniqueInput[]
    update?: CitasUpdateWithWhereUniqueWithoutEstadoCitaInput | CitasUpdateWithWhereUniqueWithoutEstadoCitaInput[]
    updateMany?: CitasUpdateManyWithWhereWithoutEstadoCitaInput | CitasUpdateManyWithWhereWithoutEstadoCitaInput[]
    deleteMany?: CitasScalarWhereInput | CitasScalarWhereInput[]
  }

  export type CitasCreateNestedOneWithoutHistorialCitasInput = {
    create?: XOR<CitasCreateWithoutHistorialCitasInput, CitasUncheckedCreateWithoutHistorialCitasInput>
    connectOrCreate?: CitasCreateOrConnectWithoutHistorialCitasInput
    connect?: CitasWhereUniqueInput
  }

  export type UsuariosCreateNestedOneWithoutHistorialCitasInput = {
    create?: XOR<UsuariosCreateWithoutHistorialCitasInput, UsuariosUncheckedCreateWithoutHistorialCitasInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutHistorialCitasInput
    connect?: UsuariosWhereUniqueInput
  }

  export type CitasUpdateOneWithoutHistorialCitasNestedInput = {
    create?: XOR<CitasCreateWithoutHistorialCitasInput, CitasUncheckedCreateWithoutHistorialCitasInput>
    connectOrCreate?: CitasCreateOrConnectWithoutHistorialCitasInput
    upsert?: CitasUpsertWithoutHistorialCitasInput
    disconnect?: CitasWhereInput | boolean
    delete?: CitasWhereInput | boolean
    connect?: CitasWhereUniqueInput
    update?: XOR<XOR<CitasUpdateToOneWithWhereWithoutHistorialCitasInput, CitasUpdateWithoutHistorialCitasInput>, CitasUncheckedUpdateWithoutHistorialCitasInput>
  }

  export type UsuariosUpdateOneWithoutHistorialCitasNestedInput = {
    create?: XOR<UsuariosCreateWithoutHistorialCitasInput, UsuariosUncheckedCreateWithoutHistorialCitasInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutHistorialCitasInput
    upsert?: UsuariosUpsertWithoutHistorialCitasInput
    disconnect?: UsuariosWhereInput | boolean
    delete?: UsuariosWhereInput | boolean
    connect?: UsuariosWhereUniqueInput
    update?: XOR<XOR<UsuariosUpdateToOneWithWhereWithoutHistorialCitasInput, UsuariosUpdateWithoutHistorialCitasInput>, UsuariosUncheckedUpdateWithoutHistorialCitasInput>
  }

  export type UsuariosCreateNestedOneWithoutHistorialRecompensasInput = {
    create?: XOR<UsuariosCreateWithoutHistorialRecompensasInput, UsuariosUncheckedCreateWithoutHistorialRecompensasInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutHistorialRecompensasInput
    connect?: UsuariosWhereUniqueInput
  }

  export type ServiciosCreateNestedOneWithoutHistorialRecompensasInput = {
    create?: XOR<ServiciosCreateWithoutHistorialRecompensasInput, ServiciosUncheckedCreateWithoutHistorialRecompensasInput>
    connectOrCreate?: ServiciosCreateOrConnectWithoutHistorialRecompensasInput
    connect?: ServiciosWhereUniqueInput
  }

  export type UsuariosUpdateOneWithoutHistorialRecompensasNestedInput = {
    create?: XOR<UsuariosCreateWithoutHistorialRecompensasInput, UsuariosUncheckedCreateWithoutHistorialRecompensasInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutHistorialRecompensasInput
    upsert?: UsuariosUpsertWithoutHistorialRecompensasInput
    disconnect?: UsuariosWhereInput | boolean
    delete?: UsuariosWhereInput | boolean
    connect?: UsuariosWhereUniqueInput
    update?: XOR<XOR<UsuariosUpdateToOneWithWhereWithoutHistorialRecompensasInput, UsuariosUpdateWithoutHistorialRecompensasInput>, UsuariosUncheckedUpdateWithoutHistorialRecompensasInput>
  }

  export type ServiciosUpdateOneWithoutHistorialRecompensasNestedInput = {
    create?: XOR<ServiciosCreateWithoutHistorialRecompensasInput, ServiciosUncheckedCreateWithoutHistorialRecompensasInput>
    connectOrCreate?: ServiciosCreateOrConnectWithoutHistorialRecompensasInput
    upsert?: ServiciosUpsertWithoutHistorialRecompensasInput
    disconnect?: ServiciosWhereInput | boolean
    delete?: ServiciosWhereInput | boolean
    connect?: ServiciosWhereUniqueInput
    update?: XOR<XOR<ServiciosUpdateToOneWithWhereWithoutHistorialRecompensasInput, ServiciosUpdateWithoutHistorialRecompensasInput>, ServiciosUncheckedUpdateWithoutHistorialRecompensasInput>
  }

  export type UsuariosCreateNestedOneWithoutHorariosInput = {
    create?: XOR<UsuariosCreateWithoutHorariosInput, UsuariosUncheckedCreateWithoutHorariosInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutHorariosInput
    connect?: UsuariosWhereUniqueInput
  }

  export type UsuariosUpdateOneWithoutHorariosNestedInput = {
    create?: XOR<UsuariosCreateWithoutHorariosInput, UsuariosUncheckedCreateWithoutHorariosInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutHorariosInput
    upsert?: UsuariosUpsertWithoutHorariosInput
    disconnect?: UsuariosWhereInput | boolean
    delete?: UsuariosWhereInput | boolean
    connect?: UsuariosWhereUniqueInput
    update?: XOR<XOR<UsuariosUpdateToOneWithWhereWithoutHorariosInput, UsuariosUpdateWithoutHorariosInput>, UsuariosUncheckedUpdateWithoutHorariosInput>
  }

  export type CitasCreateNestedOneWithoutHorariosReservadosInput = {
    create?: XOR<CitasCreateWithoutHorariosReservadosInput, CitasUncheckedCreateWithoutHorariosReservadosInput>
    connectOrCreate?: CitasCreateOrConnectWithoutHorariosReservadosInput
    connect?: CitasWhereUniqueInput
  }

  export type CitasUpdateOneRequiredWithoutHorariosReservadosNestedInput = {
    create?: XOR<CitasCreateWithoutHorariosReservadosInput, CitasUncheckedCreateWithoutHorariosReservadosInput>
    connectOrCreate?: CitasCreateOrConnectWithoutHorariosReservadosInput
    upsert?: CitasUpsertWithoutHorariosReservadosInput
    connect?: CitasWhereUniqueInput
    update?: XOR<XOR<CitasUpdateToOneWithWhereWithoutHorariosReservadosInput, CitasUpdateWithoutHorariosReservadosInput>, CitasUncheckedUpdateWithoutHorariosReservadosInput>
  }

  export type UsuariosCreateNestedOneWithoutPuntosClientesInput = {
    create?: XOR<UsuariosCreateWithoutPuntosClientesInput, UsuariosUncheckedCreateWithoutPuntosClientesInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutPuntosClientesInput
    connect?: UsuariosWhereUniqueInput
  }

  export type UsuariosUpdateOneWithoutPuntosClientesNestedInput = {
    create?: XOR<UsuariosCreateWithoutPuntosClientesInput, UsuariosUncheckedCreateWithoutPuntosClientesInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutPuntosClientesInput
    upsert?: UsuariosUpsertWithoutPuntosClientesInput
    disconnect?: UsuariosWhereInput | boolean
    delete?: UsuariosWhereInput | boolean
    connect?: UsuariosWhereUniqueInput
    update?: XOR<XOR<UsuariosUpdateToOneWithWhereWithoutPuntosClientesInput, UsuariosUpdateWithoutPuntosClientesInput>, UsuariosUncheckedUpdateWithoutPuntosClientesInput>
  }

  export type ServiciosCreateNestedOneWithoutPuntosServicioInput = {
    create?: XOR<ServiciosCreateWithoutPuntosServicioInput, ServiciosUncheckedCreateWithoutPuntosServicioInput>
    connectOrCreate?: ServiciosCreateOrConnectWithoutPuntosServicioInput
    connect?: ServiciosWhereUniqueInput
  }

  export type ServiciosUpdateOneRequiredWithoutPuntosServicioNestedInput = {
    create?: XOR<ServiciosCreateWithoutPuntosServicioInput, ServiciosUncheckedCreateWithoutPuntosServicioInput>
    connectOrCreate?: ServiciosCreateOrConnectWithoutPuntosServicioInput
    upsert?: ServiciosUpsertWithoutPuntosServicioInput
    connect?: ServiciosWhereUniqueInput
    update?: XOR<XOR<ServiciosUpdateToOneWithWhereWithoutPuntosServicioInput, ServiciosUpdateWithoutPuntosServicioInput>, ServiciosUncheckedUpdateWithoutPuntosServicioInput>
  }

  export type UsuariosCreateNestedManyWithoutRolesInput = {
    create?: XOR<UsuariosCreateWithoutRolesInput, UsuariosUncheckedCreateWithoutRolesInput> | UsuariosCreateWithoutRolesInput[] | UsuariosUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: UsuariosCreateOrConnectWithoutRolesInput | UsuariosCreateOrConnectWithoutRolesInput[]
    createMany?: UsuariosCreateManyRolesInputEnvelope
    connect?: UsuariosWhereUniqueInput | UsuariosWhereUniqueInput[]
  }

  export type UsuariosUncheckedCreateNestedManyWithoutRolesInput = {
    create?: XOR<UsuariosCreateWithoutRolesInput, UsuariosUncheckedCreateWithoutRolesInput> | UsuariosCreateWithoutRolesInput[] | UsuariosUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: UsuariosCreateOrConnectWithoutRolesInput | UsuariosCreateOrConnectWithoutRolesInput[]
    createMany?: UsuariosCreateManyRolesInputEnvelope
    connect?: UsuariosWhereUniqueInput | UsuariosWhereUniqueInput[]
  }

  export type UsuariosUpdateManyWithoutRolesNestedInput = {
    create?: XOR<UsuariosCreateWithoutRolesInput, UsuariosUncheckedCreateWithoutRolesInput> | UsuariosCreateWithoutRolesInput[] | UsuariosUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: UsuariosCreateOrConnectWithoutRolesInput | UsuariosCreateOrConnectWithoutRolesInput[]
    upsert?: UsuariosUpsertWithWhereUniqueWithoutRolesInput | UsuariosUpsertWithWhereUniqueWithoutRolesInput[]
    createMany?: UsuariosCreateManyRolesInputEnvelope
    set?: UsuariosWhereUniqueInput | UsuariosWhereUniqueInput[]
    disconnect?: UsuariosWhereUniqueInput | UsuariosWhereUniqueInput[]
    delete?: UsuariosWhereUniqueInput | UsuariosWhereUniqueInput[]
    connect?: UsuariosWhereUniqueInput | UsuariosWhereUniqueInput[]
    update?: UsuariosUpdateWithWhereUniqueWithoutRolesInput | UsuariosUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: UsuariosUpdateManyWithWhereWithoutRolesInput | UsuariosUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: UsuariosScalarWhereInput | UsuariosScalarWhereInput[]
  }

  export type UsuariosUncheckedUpdateManyWithoutRolesNestedInput = {
    create?: XOR<UsuariosCreateWithoutRolesInput, UsuariosUncheckedCreateWithoutRolesInput> | UsuariosCreateWithoutRolesInput[] | UsuariosUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: UsuariosCreateOrConnectWithoutRolesInput | UsuariosCreateOrConnectWithoutRolesInput[]
    upsert?: UsuariosUpsertWithWhereUniqueWithoutRolesInput | UsuariosUpsertWithWhereUniqueWithoutRolesInput[]
    createMany?: UsuariosCreateManyRolesInputEnvelope
    set?: UsuariosWhereUniqueInput | UsuariosWhereUniqueInput[]
    disconnect?: UsuariosWhereUniqueInput | UsuariosWhereUniqueInput[]
    delete?: UsuariosWhereUniqueInput | UsuariosWhereUniqueInput[]
    connect?: UsuariosWhereUniqueInput | UsuariosWhereUniqueInput[]
    update?: UsuariosUpdateWithWhereUniqueWithoutRolesInput | UsuariosUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: UsuariosUpdateManyWithWhereWithoutRolesInput | UsuariosUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: UsuariosScalarWhereInput | UsuariosScalarWhereInput[]
  }

  export type DetallesCitaCreateNestedManyWithoutServiciosInput = {
    create?: XOR<DetallesCitaCreateWithoutServiciosInput, DetallesCitaUncheckedCreateWithoutServiciosInput> | DetallesCitaCreateWithoutServiciosInput[] | DetallesCitaUncheckedCreateWithoutServiciosInput[]
    connectOrCreate?: DetallesCitaCreateOrConnectWithoutServiciosInput | DetallesCitaCreateOrConnectWithoutServiciosInput[]
    createMany?: DetallesCitaCreateManyServiciosInputEnvelope
    connect?: DetallesCitaWhereUniqueInput | DetallesCitaWhereUniqueInput[]
  }

  export type HistorialRecompensasCreateNestedManyWithoutServiciosInput = {
    create?: XOR<HistorialRecompensasCreateWithoutServiciosInput, HistorialRecompensasUncheckedCreateWithoutServiciosInput> | HistorialRecompensasCreateWithoutServiciosInput[] | HistorialRecompensasUncheckedCreateWithoutServiciosInput[]
    connectOrCreate?: HistorialRecompensasCreateOrConnectWithoutServiciosInput | HistorialRecompensasCreateOrConnectWithoutServiciosInput[]
    createMany?: HistorialRecompensasCreateManyServiciosInputEnvelope
    connect?: HistorialRecompensasWhereUniqueInput | HistorialRecompensasWhereUniqueInput[]
  }

  export type PuntosServicioCreateNestedOneWithoutServiciosInput = {
    create?: XOR<PuntosServicioCreateWithoutServiciosInput, PuntosServicioUncheckedCreateWithoutServiciosInput>
    connectOrCreate?: PuntosServicioCreateOrConnectWithoutServiciosInput
    connect?: PuntosServicioWhereUniqueInput
  }

  export type DetallesCitaUncheckedCreateNestedManyWithoutServiciosInput = {
    create?: XOR<DetallesCitaCreateWithoutServiciosInput, DetallesCitaUncheckedCreateWithoutServiciosInput> | DetallesCitaCreateWithoutServiciosInput[] | DetallesCitaUncheckedCreateWithoutServiciosInput[]
    connectOrCreate?: DetallesCitaCreateOrConnectWithoutServiciosInput | DetallesCitaCreateOrConnectWithoutServiciosInput[]
    createMany?: DetallesCitaCreateManyServiciosInputEnvelope
    connect?: DetallesCitaWhereUniqueInput | DetallesCitaWhereUniqueInput[]
  }

  export type HistorialRecompensasUncheckedCreateNestedManyWithoutServiciosInput = {
    create?: XOR<HistorialRecompensasCreateWithoutServiciosInput, HistorialRecompensasUncheckedCreateWithoutServiciosInput> | HistorialRecompensasCreateWithoutServiciosInput[] | HistorialRecompensasUncheckedCreateWithoutServiciosInput[]
    connectOrCreate?: HistorialRecompensasCreateOrConnectWithoutServiciosInput | HistorialRecompensasCreateOrConnectWithoutServiciosInput[]
    createMany?: HistorialRecompensasCreateManyServiciosInputEnvelope
    connect?: HistorialRecompensasWhereUniqueInput | HistorialRecompensasWhereUniqueInput[]
  }

  export type PuntosServicioUncheckedCreateNestedOneWithoutServiciosInput = {
    create?: XOR<PuntosServicioCreateWithoutServiciosInput, PuntosServicioUncheckedCreateWithoutServiciosInput>
    connectOrCreate?: PuntosServicioCreateOrConnectWithoutServiciosInput
    connect?: PuntosServicioWhereUniqueInput
  }

  export type DetallesCitaUpdateManyWithoutServiciosNestedInput = {
    create?: XOR<DetallesCitaCreateWithoutServiciosInput, DetallesCitaUncheckedCreateWithoutServiciosInput> | DetallesCitaCreateWithoutServiciosInput[] | DetallesCitaUncheckedCreateWithoutServiciosInput[]
    connectOrCreate?: DetallesCitaCreateOrConnectWithoutServiciosInput | DetallesCitaCreateOrConnectWithoutServiciosInput[]
    upsert?: DetallesCitaUpsertWithWhereUniqueWithoutServiciosInput | DetallesCitaUpsertWithWhereUniqueWithoutServiciosInput[]
    createMany?: DetallesCitaCreateManyServiciosInputEnvelope
    set?: DetallesCitaWhereUniqueInput | DetallesCitaWhereUniqueInput[]
    disconnect?: DetallesCitaWhereUniqueInput | DetallesCitaWhereUniqueInput[]
    delete?: DetallesCitaWhereUniqueInput | DetallesCitaWhereUniqueInput[]
    connect?: DetallesCitaWhereUniqueInput | DetallesCitaWhereUniqueInput[]
    update?: DetallesCitaUpdateWithWhereUniqueWithoutServiciosInput | DetallesCitaUpdateWithWhereUniqueWithoutServiciosInput[]
    updateMany?: DetallesCitaUpdateManyWithWhereWithoutServiciosInput | DetallesCitaUpdateManyWithWhereWithoutServiciosInput[]
    deleteMany?: DetallesCitaScalarWhereInput | DetallesCitaScalarWhereInput[]
  }

  export type HistorialRecompensasUpdateManyWithoutServiciosNestedInput = {
    create?: XOR<HistorialRecompensasCreateWithoutServiciosInput, HistorialRecompensasUncheckedCreateWithoutServiciosInput> | HistorialRecompensasCreateWithoutServiciosInput[] | HistorialRecompensasUncheckedCreateWithoutServiciosInput[]
    connectOrCreate?: HistorialRecompensasCreateOrConnectWithoutServiciosInput | HistorialRecompensasCreateOrConnectWithoutServiciosInput[]
    upsert?: HistorialRecompensasUpsertWithWhereUniqueWithoutServiciosInput | HistorialRecompensasUpsertWithWhereUniqueWithoutServiciosInput[]
    createMany?: HistorialRecompensasCreateManyServiciosInputEnvelope
    set?: HistorialRecompensasWhereUniqueInput | HistorialRecompensasWhereUniqueInput[]
    disconnect?: HistorialRecompensasWhereUniqueInput | HistorialRecompensasWhereUniqueInput[]
    delete?: HistorialRecompensasWhereUniqueInput | HistorialRecompensasWhereUniqueInput[]
    connect?: HistorialRecompensasWhereUniqueInput | HistorialRecompensasWhereUniqueInput[]
    update?: HistorialRecompensasUpdateWithWhereUniqueWithoutServiciosInput | HistorialRecompensasUpdateWithWhereUniqueWithoutServiciosInput[]
    updateMany?: HistorialRecompensasUpdateManyWithWhereWithoutServiciosInput | HistorialRecompensasUpdateManyWithWhereWithoutServiciosInput[]
    deleteMany?: HistorialRecompensasScalarWhereInput | HistorialRecompensasScalarWhereInput[]
  }

  export type PuntosServicioUpdateOneWithoutServiciosNestedInput = {
    create?: XOR<PuntosServicioCreateWithoutServiciosInput, PuntosServicioUncheckedCreateWithoutServiciosInput>
    connectOrCreate?: PuntosServicioCreateOrConnectWithoutServiciosInput
    upsert?: PuntosServicioUpsertWithoutServiciosInput
    disconnect?: PuntosServicioWhereInput | boolean
    delete?: PuntosServicioWhereInput | boolean
    connect?: PuntosServicioWhereUniqueInput
    update?: XOR<XOR<PuntosServicioUpdateToOneWithWhereWithoutServiciosInput, PuntosServicioUpdateWithoutServiciosInput>, PuntosServicioUncheckedUpdateWithoutServiciosInput>
  }

  export type DetallesCitaUncheckedUpdateManyWithoutServiciosNestedInput = {
    create?: XOR<DetallesCitaCreateWithoutServiciosInput, DetallesCitaUncheckedCreateWithoutServiciosInput> | DetallesCitaCreateWithoutServiciosInput[] | DetallesCitaUncheckedCreateWithoutServiciosInput[]
    connectOrCreate?: DetallesCitaCreateOrConnectWithoutServiciosInput | DetallesCitaCreateOrConnectWithoutServiciosInput[]
    upsert?: DetallesCitaUpsertWithWhereUniqueWithoutServiciosInput | DetallesCitaUpsertWithWhereUniqueWithoutServiciosInput[]
    createMany?: DetallesCitaCreateManyServiciosInputEnvelope
    set?: DetallesCitaWhereUniqueInput | DetallesCitaWhereUniqueInput[]
    disconnect?: DetallesCitaWhereUniqueInput | DetallesCitaWhereUniqueInput[]
    delete?: DetallesCitaWhereUniqueInput | DetallesCitaWhereUniqueInput[]
    connect?: DetallesCitaWhereUniqueInput | DetallesCitaWhereUniqueInput[]
    update?: DetallesCitaUpdateWithWhereUniqueWithoutServiciosInput | DetallesCitaUpdateWithWhereUniqueWithoutServiciosInput[]
    updateMany?: DetallesCitaUpdateManyWithWhereWithoutServiciosInput | DetallesCitaUpdateManyWithWhereWithoutServiciosInput[]
    deleteMany?: DetallesCitaScalarWhereInput | DetallesCitaScalarWhereInput[]
  }

  export type HistorialRecompensasUncheckedUpdateManyWithoutServiciosNestedInput = {
    create?: XOR<HistorialRecompensasCreateWithoutServiciosInput, HistorialRecompensasUncheckedCreateWithoutServiciosInput> | HistorialRecompensasCreateWithoutServiciosInput[] | HistorialRecompensasUncheckedCreateWithoutServiciosInput[]
    connectOrCreate?: HistorialRecompensasCreateOrConnectWithoutServiciosInput | HistorialRecompensasCreateOrConnectWithoutServiciosInput[]
    upsert?: HistorialRecompensasUpsertWithWhereUniqueWithoutServiciosInput | HistorialRecompensasUpsertWithWhereUniqueWithoutServiciosInput[]
    createMany?: HistorialRecompensasCreateManyServiciosInputEnvelope
    set?: HistorialRecompensasWhereUniqueInput | HistorialRecompensasWhereUniqueInput[]
    disconnect?: HistorialRecompensasWhereUniqueInput | HistorialRecompensasWhereUniqueInput[]
    delete?: HistorialRecompensasWhereUniqueInput | HistorialRecompensasWhereUniqueInput[]
    connect?: HistorialRecompensasWhereUniqueInput | HistorialRecompensasWhereUniqueInput[]
    update?: HistorialRecompensasUpdateWithWhereUniqueWithoutServiciosInput | HistorialRecompensasUpdateWithWhereUniqueWithoutServiciosInput[]
    updateMany?: HistorialRecompensasUpdateManyWithWhereWithoutServiciosInput | HistorialRecompensasUpdateManyWithWhereWithoutServiciosInput[]
    deleteMany?: HistorialRecompensasScalarWhereInput | HistorialRecompensasScalarWhereInput[]
  }

  export type PuntosServicioUncheckedUpdateOneWithoutServiciosNestedInput = {
    create?: XOR<PuntosServicioCreateWithoutServiciosInput, PuntosServicioUncheckedCreateWithoutServiciosInput>
    connectOrCreate?: PuntosServicioCreateOrConnectWithoutServiciosInput
    upsert?: PuntosServicioUpsertWithoutServiciosInput
    disconnect?: PuntosServicioWhereInput | boolean
    delete?: PuntosServicioWhereInput | boolean
    connect?: PuntosServicioWhereUniqueInput
    update?: XOR<XOR<PuntosServicioUpdateToOneWithWhereWithoutServiciosInput, PuntosServicioUpdateWithoutServiciosInput>, PuntosServicioUncheckedUpdateWithoutServiciosInput>
  }

  export type ActividadClienteCreateNestedManyWithoutUsuariosInput = {
    create?: XOR<ActividadClienteCreateWithoutUsuariosInput, ActividadClienteUncheckedCreateWithoutUsuariosInput> | ActividadClienteCreateWithoutUsuariosInput[] | ActividadClienteUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: ActividadClienteCreateOrConnectWithoutUsuariosInput | ActividadClienteCreateOrConnectWithoutUsuariosInput[]
    createMany?: ActividadClienteCreateManyUsuariosInputEnvelope
    connect?: ActividadClienteWhereUniqueInput | ActividadClienteWhereUniqueInput[]
  }

  export type BitacoraClienteCreateNestedManyWithoutUsuariosInput = {
    create?: XOR<BitacoraClienteCreateWithoutUsuariosInput, BitacoraClienteUncheckedCreateWithoutUsuariosInput> | BitacoraClienteCreateWithoutUsuariosInput[] | BitacoraClienteUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: BitacoraClienteCreateOrConnectWithoutUsuariosInput | BitacoraClienteCreateOrConnectWithoutUsuariosInput[]
    createMany?: BitacoraClienteCreateManyUsuariosInputEnvelope
    connect?: BitacoraClienteWhereUniqueInput | BitacoraClienteWhereUniqueInput[]
  }

  export type BitacoraEstilistaCreateNestedManyWithoutUsuariosInput = {
    create?: XOR<BitacoraEstilistaCreateWithoutUsuariosInput, BitacoraEstilistaUncheckedCreateWithoutUsuariosInput> | BitacoraEstilistaCreateWithoutUsuariosInput[] | BitacoraEstilistaUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: BitacoraEstilistaCreateOrConnectWithoutUsuariosInput | BitacoraEstilistaCreateOrConnectWithoutUsuariosInput[]
    createMany?: BitacoraEstilistaCreateManyUsuariosInputEnvelope
    connect?: BitacoraEstilistaWhereUniqueInput | BitacoraEstilistaWhereUniqueInput[]
  }

  export type BloqueoHorariosCreateNestedManyWithoutUsuariosInput = {
    create?: XOR<BloqueoHorariosCreateWithoutUsuariosInput, BloqueoHorariosUncheckedCreateWithoutUsuariosInput> | BloqueoHorariosCreateWithoutUsuariosInput[] | BloqueoHorariosUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: BloqueoHorariosCreateOrConnectWithoutUsuariosInput | BloqueoHorariosCreateOrConnectWithoutUsuariosInput[]
    createMany?: BloqueoHorariosCreateManyUsuariosInputEnvelope
    connect?: BloqueoHorariosWhereUniqueInput | BloqueoHorariosWhereUniqueInput[]
  }

  export type CitasCreateNestedManyWithoutUsuarios_Citas_clienteIDToUsuariosInput = {
    create?: XOR<CitasCreateWithoutUsuarios_Citas_clienteIDToUsuariosInput, CitasUncheckedCreateWithoutUsuarios_Citas_clienteIDToUsuariosInput> | CitasCreateWithoutUsuarios_Citas_clienteIDToUsuariosInput[] | CitasUncheckedCreateWithoutUsuarios_Citas_clienteIDToUsuariosInput[]
    connectOrCreate?: CitasCreateOrConnectWithoutUsuarios_Citas_clienteIDToUsuariosInput | CitasCreateOrConnectWithoutUsuarios_Citas_clienteIDToUsuariosInput[]
    createMany?: CitasCreateManyUsuarios_Citas_clienteIDToUsuariosInputEnvelope
    connect?: CitasWhereUniqueInput | CitasWhereUniqueInput[]
  }

  export type CitasCreateNestedManyWithoutUsuarios_Citas_estilistaIDToUsuariosInput = {
    create?: XOR<CitasCreateWithoutUsuarios_Citas_estilistaIDToUsuariosInput, CitasUncheckedCreateWithoutUsuarios_Citas_estilistaIDToUsuariosInput> | CitasCreateWithoutUsuarios_Citas_estilistaIDToUsuariosInput[] | CitasUncheckedCreateWithoutUsuarios_Citas_estilistaIDToUsuariosInput[]
    connectOrCreate?: CitasCreateOrConnectWithoutUsuarios_Citas_estilistaIDToUsuariosInput | CitasCreateOrConnectWithoutUsuarios_Citas_estilistaIDToUsuariosInput[]
    createMany?: CitasCreateManyUsuarios_Citas_estilistaIDToUsuariosInputEnvelope
    connect?: CitasWhereUniqueInput | CitasWhereUniqueInput[]
  }

  export type HistorialCitasCreateNestedManyWithoutUsuariosInput = {
    create?: XOR<HistorialCitasCreateWithoutUsuariosInput, HistorialCitasUncheckedCreateWithoutUsuariosInput> | HistorialCitasCreateWithoutUsuariosInput[] | HistorialCitasUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: HistorialCitasCreateOrConnectWithoutUsuariosInput | HistorialCitasCreateOrConnectWithoutUsuariosInput[]
    createMany?: HistorialCitasCreateManyUsuariosInputEnvelope
    connect?: HistorialCitasWhereUniqueInput | HistorialCitasWhereUniqueInput[]
  }

  export type HistorialRecompensasCreateNestedManyWithoutUsuariosInput = {
    create?: XOR<HistorialRecompensasCreateWithoutUsuariosInput, HistorialRecompensasUncheckedCreateWithoutUsuariosInput> | HistorialRecompensasCreateWithoutUsuariosInput[] | HistorialRecompensasUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: HistorialRecompensasCreateOrConnectWithoutUsuariosInput | HistorialRecompensasCreateOrConnectWithoutUsuariosInput[]
    createMany?: HistorialRecompensasCreateManyUsuariosInputEnvelope
    connect?: HistorialRecompensasWhereUniqueInput | HistorialRecompensasWhereUniqueInput[]
  }

  export type HorariosCreateNestedManyWithoutUsuariosInput = {
    create?: XOR<HorariosCreateWithoutUsuariosInput, HorariosUncheckedCreateWithoutUsuariosInput> | HorariosCreateWithoutUsuariosInput[] | HorariosUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: HorariosCreateOrConnectWithoutUsuariosInput | HorariosCreateOrConnectWithoutUsuariosInput[]
    createMany?: HorariosCreateManyUsuariosInputEnvelope
    connect?: HorariosWhereUniqueInput | HorariosWhereUniqueInput[]
  }

  export type PuntosClientesCreateNestedManyWithoutUsuariosInput = {
    create?: XOR<PuntosClientesCreateWithoutUsuariosInput, PuntosClientesUncheckedCreateWithoutUsuariosInput> | PuntosClientesCreateWithoutUsuariosInput[] | PuntosClientesUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: PuntosClientesCreateOrConnectWithoutUsuariosInput | PuntosClientesCreateOrConnectWithoutUsuariosInput[]
    createMany?: PuntosClientesCreateManyUsuariosInputEnvelope
    connect?: PuntosClientesWhereUniqueInput | PuntosClientesWhereUniqueInput[]
  }

  export type RolesCreateNestedOneWithoutUsuariosInput = {
    create?: XOR<RolesCreateWithoutUsuariosInput, RolesUncheckedCreateWithoutUsuariosInput>
    connectOrCreate?: RolesCreateOrConnectWithoutUsuariosInput
    connect?: RolesWhereUniqueInput
  }

  export type ActividadClienteUncheckedCreateNestedManyWithoutUsuariosInput = {
    create?: XOR<ActividadClienteCreateWithoutUsuariosInput, ActividadClienteUncheckedCreateWithoutUsuariosInput> | ActividadClienteCreateWithoutUsuariosInput[] | ActividadClienteUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: ActividadClienteCreateOrConnectWithoutUsuariosInput | ActividadClienteCreateOrConnectWithoutUsuariosInput[]
    createMany?: ActividadClienteCreateManyUsuariosInputEnvelope
    connect?: ActividadClienteWhereUniqueInput | ActividadClienteWhereUniqueInput[]
  }

  export type BitacoraClienteUncheckedCreateNestedManyWithoutUsuariosInput = {
    create?: XOR<BitacoraClienteCreateWithoutUsuariosInput, BitacoraClienteUncheckedCreateWithoutUsuariosInput> | BitacoraClienteCreateWithoutUsuariosInput[] | BitacoraClienteUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: BitacoraClienteCreateOrConnectWithoutUsuariosInput | BitacoraClienteCreateOrConnectWithoutUsuariosInput[]
    createMany?: BitacoraClienteCreateManyUsuariosInputEnvelope
    connect?: BitacoraClienteWhereUniqueInput | BitacoraClienteWhereUniqueInput[]
  }

  export type BitacoraEstilistaUncheckedCreateNestedManyWithoutUsuariosInput = {
    create?: XOR<BitacoraEstilistaCreateWithoutUsuariosInput, BitacoraEstilistaUncheckedCreateWithoutUsuariosInput> | BitacoraEstilistaCreateWithoutUsuariosInput[] | BitacoraEstilistaUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: BitacoraEstilistaCreateOrConnectWithoutUsuariosInput | BitacoraEstilistaCreateOrConnectWithoutUsuariosInput[]
    createMany?: BitacoraEstilistaCreateManyUsuariosInputEnvelope
    connect?: BitacoraEstilistaWhereUniqueInput | BitacoraEstilistaWhereUniqueInput[]
  }

  export type BloqueoHorariosUncheckedCreateNestedManyWithoutUsuariosInput = {
    create?: XOR<BloqueoHorariosCreateWithoutUsuariosInput, BloqueoHorariosUncheckedCreateWithoutUsuariosInput> | BloqueoHorariosCreateWithoutUsuariosInput[] | BloqueoHorariosUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: BloqueoHorariosCreateOrConnectWithoutUsuariosInput | BloqueoHorariosCreateOrConnectWithoutUsuariosInput[]
    createMany?: BloqueoHorariosCreateManyUsuariosInputEnvelope
    connect?: BloqueoHorariosWhereUniqueInput | BloqueoHorariosWhereUniqueInput[]
  }

  export type CitasUncheckedCreateNestedManyWithoutUsuarios_Citas_clienteIDToUsuariosInput = {
    create?: XOR<CitasCreateWithoutUsuarios_Citas_clienteIDToUsuariosInput, CitasUncheckedCreateWithoutUsuarios_Citas_clienteIDToUsuariosInput> | CitasCreateWithoutUsuarios_Citas_clienteIDToUsuariosInput[] | CitasUncheckedCreateWithoutUsuarios_Citas_clienteIDToUsuariosInput[]
    connectOrCreate?: CitasCreateOrConnectWithoutUsuarios_Citas_clienteIDToUsuariosInput | CitasCreateOrConnectWithoutUsuarios_Citas_clienteIDToUsuariosInput[]
    createMany?: CitasCreateManyUsuarios_Citas_clienteIDToUsuariosInputEnvelope
    connect?: CitasWhereUniqueInput | CitasWhereUniqueInput[]
  }

  export type CitasUncheckedCreateNestedManyWithoutUsuarios_Citas_estilistaIDToUsuariosInput = {
    create?: XOR<CitasCreateWithoutUsuarios_Citas_estilistaIDToUsuariosInput, CitasUncheckedCreateWithoutUsuarios_Citas_estilistaIDToUsuariosInput> | CitasCreateWithoutUsuarios_Citas_estilistaIDToUsuariosInput[] | CitasUncheckedCreateWithoutUsuarios_Citas_estilistaIDToUsuariosInput[]
    connectOrCreate?: CitasCreateOrConnectWithoutUsuarios_Citas_estilistaIDToUsuariosInput | CitasCreateOrConnectWithoutUsuarios_Citas_estilistaIDToUsuariosInput[]
    createMany?: CitasCreateManyUsuarios_Citas_estilistaIDToUsuariosInputEnvelope
    connect?: CitasWhereUniqueInput | CitasWhereUniqueInput[]
  }

  export type HistorialCitasUncheckedCreateNestedManyWithoutUsuariosInput = {
    create?: XOR<HistorialCitasCreateWithoutUsuariosInput, HistorialCitasUncheckedCreateWithoutUsuariosInput> | HistorialCitasCreateWithoutUsuariosInput[] | HistorialCitasUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: HistorialCitasCreateOrConnectWithoutUsuariosInput | HistorialCitasCreateOrConnectWithoutUsuariosInput[]
    createMany?: HistorialCitasCreateManyUsuariosInputEnvelope
    connect?: HistorialCitasWhereUniqueInput | HistorialCitasWhereUniqueInput[]
  }

  export type HistorialRecompensasUncheckedCreateNestedManyWithoutUsuariosInput = {
    create?: XOR<HistorialRecompensasCreateWithoutUsuariosInput, HistorialRecompensasUncheckedCreateWithoutUsuariosInput> | HistorialRecompensasCreateWithoutUsuariosInput[] | HistorialRecompensasUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: HistorialRecompensasCreateOrConnectWithoutUsuariosInput | HistorialRecompensasCreateOrConnectWithoutUsuariosInput[]
    createMany?: HistorialRecompensasCreateManyUsuariosInputEnvelope
    connect?: HistorialRecompensasWhereUniqueInput | HistorialRecompensasWhereUniqueInput[]
  }

  export type HorariosUncheckedCreateNestedManyWithoutUsuariosInput = {
    create?: XOR<HorariosCreateWithoutUsuariosInput, HorariosUncheckedCreateWithoutUsuariosInput> | HorariosCreateWithoutUsuariosInput[] | HorariosUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: HorariosCreateOrConnectWithoutUsuariosInput | HorariosCreateOrConnectWithoutUsuariosInput[]
    createMany?: HorariosCreateManyUsuariosInputEnvelope
    connect?: HorariosWhereUniqueInput | HorariosWhereUniqueInput[]
  }

  export type PuntosClientesUncheckedCreateNestedManyWithoutUsuariosInput = {
    create?: XOR<PuntosClientesCreateWithoutUsuariosInput, PuntosClientesUncheckedCreateWithoutUsuariosInput> | PuntosClientesCreateWithoutUsuariosInput[] | PuntosClientesUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: PuntosClientesCreateOrConnectWithoutUsuariosInput | PuntosClientesCreateOrConnectWithoutUsuariosInput[]
    createMany?: PuntosClientesCreateManyUsuariosInputEnvelope
    connect?: PuntosClientesWhereUniqueInput | PuntosClientesWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type ActividadClienteUpdateManyWithoutUsuariosNestedInput = {
    create?: XOR<ActividadClienteCreateWithoutUsuariosInput, ActividadClienteUncheckedCreateWithoutUsuariosInput> | ActividadClienteCreateWithoutUsuariosInput[] | ActividadClienteUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: ActividadClienteCreateOrConnectWithoutUsuariosInput | ActividadClienteCreateOrConnectWithoutUsuariosInput[]
    upsert?: ActividadClienteUpsertWithWhereUniqueWithoutUsuariosInput | ActividadClienteUpsertWithWhereUniqueWithoutUsuariosInput[]
    createMany?: ActividadClienteCreateManyUsuariosInputEnvelope
    set?: ActividadClienteWhereUniqueInput | ActividadClienteWhereUniqueInput[]
    disconnect?: ActividadClienteWhereUniqueInput | ActividadClienteWhereUniqueInput[]
    delete?: ActividadClienteWhereUniqueInput | ActividadClienteWhereUniqueInput[]
    connect?: ActividadClienteWhereUniqueInput | ActividadClienteWhereUniqueInput[]
    update?: ActividadClienteUpdateWithWhereUniqueWithoutUsuariosInput | ActividadClienteUpdateWithWhereUniqueWithoutUsuariosInput[]
    updateMany?: ActividadClienteUpdateManyWithWhereWithoutUsuariosInput | ActividadClienteUpdateManyWithWhereWithoutUsuariosInput[]
    deleteMany?: ActividadClienteScalarWhereInput | ActividadClienteScalarWhereInput[]
  }

  export type BitacoraClienteUpdateManyWithoutUsuariosNestedInput = {
    create?: XOR<BitacoraClienteCreateWithoutUsuariosInput, BitacoraClienteUncheckedCreateWithoutUsuariosInput> | BitacoraClienteCreateWithoutUsuariosInput[] | BitacoraClienteUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: BitacoraClienteCreateOrConnectWithoutUsuariosInput | BitacoraClienteCreateOrConnectWithoutUsuariosInput[]
    upsert?: BitacoraClienteUpsertWithWhereUniqueWithoutUsuariosInput | BitacoraClienteUpsertWithWhereUniqueWithoutUsuariosInput[]
    createMany?: BitacoraClienteCreateManyUsuariosInputEnvelope
    set?: BitacoraClienteWhereUniqueInput | BitacoraClienteWhereUniqueInput[]
    disconnect?: BitacoraClienteWhereUniqueInput | BitacoraClienteWhereUniqueInput[]
    delete?: BitacoraClienteWhereUniqueInput | BitacoraClienteWhereUniqueInput[]
    connect?: BitacoraClienteWhereUniqueInput | BitacoraClienteWhereUniqueInput[]
    update?: BitacoraClienteUpdateWithWhereUniqueWithoutUsuariosInput | BitacoraClienteUpdateWithWhereUniqueWithoutUsuariosInput[]
    updateMany?: BitacoraClienteUpdateManyWithWhereWithoutUsuariosInput | BitacoraClienteUpdateManyWithWhereWithoutUsuariosInput[]
    deleteMany?: BitacoraClienteScalarWhereInput | BitacoraClienteScalarWhereInput[]
  }

  export type BitacoraEstilistaUpdateManyWithoutUsuariosNestedInput = {
    create?: XOR<BitacoraEstilistaCreateWithoutUsuariosInput, BitacoraEstilistaUncheckedCreateWithoutUsuariosInput> | BitacoraEstilistaCreateWithoutUsuariosInput[] | BitacoraEstilistaUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: BitacoraEstilistaCreateOrConnectWithoutUsuariosInput | BitacoraEstilistaCreateOrConnectWithoutUsuariosInput[]
    upsert?: BitacoraEstilistaUpsertWithWhereUniqueWithoutUsuariosInput | BitacoraEstilistaUpsertWithWhereUniqueWithoutUsuariosInput[]
    createMany?: BitacoraEstilistaCreateManyUsuariosInputEnvelope
    set?: BitacoraEstilistaWhereUniqueInput | BitacoraEstilistaWhereUniqueInput[]
    disconnect?: BitacoraEstilistaWhereUniqueInput | BitacoraEstilistaWhereUniqueInput[]
    delete?: BitacoraEstilistaWhereUniqueInput | BitacoraEstilistaWhereUniqueInput[]
    connect?: BitacoraEstilistaWhereUniqueInput | BitacoraEstilistaWhereUniqueInput[]
    update?: BitacoraEstilistaUpdateWithWhereUniqueWithoutUsuariosInput | BitacoraEstilistaUpdateWithWhereUniqueWithoutUsuariosInput[]
    updateMany?: BitacoraEstilistaUpdateManyWithWhereWithoutUsuariosInput | BitacoraEstilistaUpdateManyWithWhereWithoutUsuariosInput[]
    deleteMany?: BitacoraEstilistaScalarWhereInput | BitacoraEstilistaScalarWhereInput[]
  }

  export type BloqueoHorariosUpdateManyWithoutUsuariosNestedInput = {
    create?: XOR<BloqueoHorariosCreateWithoutUsuariosInput, BloqueoHorariosUncheckedCreateWithoutUsuariosInput> | BloqueoHorariosCreateWithoutUsuariosInput[] | BloqueoHorariosUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: BloqueoHorariosCreateOrConnectWithoutUsuariosInput | BloqueoHorariosCreateOrConnectWithoutUsuariosInput[]
    upsert?: BloqueoHorariosUpsertWithWhereUniqueWithoutUsuariosInput | BloqueoHorariosUpsertWithWhereUniqueWithoutUsuariosInput[]
    createMany?: BloqueoHorariosCreateManyUsuariosInputEnvelope
    set?: BloqueoHorariosWhereUniqueInput | BloqueoHorariosWhereUniqueInput[]
    disconnect?: BloqueoHorariosWhereUniqueInput | BloqueoHorariosWhereUniqueInput[]
    delete?: BloqueoHorariosWhereUniqueInput | BloqueoHorariosWhereUniqueInput[]
    connect?: BloqueoHorariosWhereUniqueInput | BloqueoHorariosWhereUniqueInput[]
    update?: BloqueoHorariosUpdateWithWhereUniqueWithoutUsuariosInput | BloqueoHorariosUpdateWithWhereUniqueWithoutUsuariosInput[]
    updateMany?: BloqueoHorariosUpdateManyWithWhereWithoutUsuariosInput | BloqueoHorariosUpdateManyWithWhereWithoutUsuariosInput[]
    deleteMany?: BloqueoHorariosScalarWhereInput | BloqueoHorariosScalarWhereInput[]
  }

  export type CitasUpdateManyWithoutUsuarios_Citas_clienteIDToUsuariosNestedInput = {
    create?: XOR<CitasCreateWithoutUsuarios_Citas_clienteIDToUsuariosInput, CitasUncheckedCreateWithoutUsuarios_Citas_clienteIDToUsuariosInput> | CitasCreateWithoutUsuarios_Citas_clienteIDToUsuariosInput[] | CitasUncheckedCreateWithoutUsuarios_Citas_clienteIDToUsuariosInput[]
    connectOrCreate?: CitasCreateOrConnectWithoutUsuarios_Citas_clienteIDToUsuariosInput | CitasCreateOrConnectWithoutUsuarios_Citas_clienteIDToUsuariosInput[]
    upsert?: CitasUpsertWithWhereUniqueWithoutUsuarios_Citas_clienteIDToUsuariosInput | CitasUpsertWithWhereUniqueWithoutUsuarios_Citas_clienteIDToUsuariosInput[]
    createMany?: CitasCreateManyUsuarios_Citas_clienteIDToUsuariosInputEnvelope
    set?: CitasWhereUniqueInput | CitasWhereUniqueInput[]
    disconnect?: CitasWhereUniqueInput | CitasWhereUniqueInput[]
    delete?: CitasWhereUniqueInput | CitasWhereUniqueInput[]
    connect?: CitasWhereUniqueInput | CitasWhereUniqueInput[]
    update?: CitasUpdateWithWhereUniqueWithoutUsuarios_Citas_clienteIDToUsuariosInput | CitasUpdateWithWhereUniqueWithoutUsuarios_Citas_clienteIDToUsuariosInput[]
    updateMany?: CitasUpdateManyWithWhereWithoutUsuarios_Citas_clienteIDToUsuariosInput | CitasUpdateManyWithWhereWithoutUsuarios_Citas_clienteIDToUsuariosInput[]
    deleteMany?: CitasScalarWhereInput | CitasScalarWhereInput[]
  }

  export type CitasUpdateManyWithoutUsuarios_Citas_estilistaIDToUsuariosNestedInput = {
    create?: XOR<CitasCreateWithoutUsuarios_Citas_estilistaIDToUsuariosInput, CitasUncheckedCreateWithoutUsuarios_Citas_estilistaIDToUsuariosInput> | CitasCreateWithoutUsuarios_Citas_estilistaIDToUsuariosInput[] | CitasUncheckedCreateWithoutUsuarios_Citas_estilistaIDToUsuariosInput[]
    connectOrCreate?: CitasCreateOrConnectWithoutUsuarios_Citas_estilistaIDToUsuariosInput | CitasCreateOrConnectWithoutUsuarios_Citas_estilistaIDToUsuariosInput[]
    upsert?: CitasUpsertWithWhereUniqueWithoutUsuarios_Citas_estilistaIDToUsuariosInput | CitasUpsertWithWhereUniqueWithoutUsuarios_Citas_estilistaIDToUsuariosInput[]
    createMany?: CitasCreateManyUsuarios_Citas_estilistaIDToUsuariosInputEnvelope
    set?: CitasWhereUniqueInput | CitasWhereUniqueInput[]
    disconnect?: CitasWhereUniqueInput | CitasWhereUniqueInput[]
    delete?: CitasWhereUniqueInput | CitasWhereUniqueInput[]
    connect?: CitasWhereUniqueInput | CitasWhereUniqueInput[]
    update?: CitasUpdateWithWhereUniqueWithoutUsuarios_Citas_estilistaIDToUsuariosInput | CitasUpdateWithWhereUniqueWithoutUsuarios_Citas_estilistaIDToUsuariosInput[]
    updateMany?: CitasUpdateManyWithWhereWithoutUsuarios_Citas_estilistaIDToUsuariosInput | CitasUpdateManyWithWhereWithoutUsuarios_Citas_estilistaIDToUsuariosInput[]
    deleteMany?: CitasScalarWhereInput | CitasScalarWhereInput[]
  }

  export type HistorialCitasUpdateManyWithoutUsuariosNestedInput = {
    create?: XOR<HistorialCitasCreateWithoutUsuariosInput, HistorialCitasUncheckedCreateWithoutUsuariosInput> | HistorialCitasCreateWithoutUsuariosInput[] | HistorialCitasUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: HistorialCitasCreateOrConnectWithoutUsuariosInput | HistorialCitasCreateOrConnectWithoutUsuariosInput[]
    upsert?: HistorialCitasUpsertWithWhereUniqueWithoutUsuariosInput | HistorialCitasUpsertWithWhereUniqueWithoutUsuariosInput[]
    createMany?: HistorialCitasCreateManyUsuariosInputEnvelope
    set?: HistorialCitasWhereUniqueInput | HistorialCitasWhereUniqueInput[]
    disconnect?: HistorialCitasWhereUniqueInput | HistorialCitasWhereUniqueInput[]
    delete?: HistorialCitasWhereUniqueInput | HistorialCitasWhereUniqueInput[]
    connect?: HistorialCitasWhereUniqueInput | HistorialCitasWhereUniqueInput[]
    update?: HistorialCitasUpdateWithWhereUniqueWithoutUsuariosInput | HistorialCitasUpdateWithWhereUniqueWithoutUsuariosInput[]
    updateMany?: HistorialCitasUpdateManyWithWhereWithoutUsuariosInput | HistorialCitasUpdateManyWithWhereWithoutUsuariosInput[]
    deleteMany?: HistorialCitasScalarWhereInput | HistorialCitasScalarWhereInput[]
  }

  export type HistorialRecompensasUpdateManyWithoutUsuariosNestedInput = {
    create?: XOR<HistorialRecompensasCreateWithoutUsuariosInput, HistorialRecompensasUncheckedCreateWithoutUsuariosInput> | HistorialRecompensasCreateWithoutUsuariosInput[] | HistorialRecompensasUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: HistorialRecompensasCreateOrConnectWithoutUsuariosInput | HistorialRecompensasCreateOrConnectWithoutUsuariosInput[]
    upsert?: HistorialRecompensasUpsertWithWhereUniqueWithoutUsuariosInput | HistorialRecompensasUpsertWithWhereUniqueWithoutUsuariosInput[]
    createMany?: HistorialRecompensasCreateManyUsuariosInputEnvelope
    set?: HistorialRecompensasWhereUniqueInput | HistorialRecompensasWhereUniqueInput[]
    disconnect?: HistorialRecompensasWhereUniqueInput | HistorialRecompensasWhereUniqueInput[]
    delete?: HistorialRecompensasWhereUniqueInput | HistorialRecompensasWhereUniqueInput[]
    connect?: HistorialRecompensasWhereUniqueInput | HistorialRecompensasWhereUniqueInput[]
    update?: HistorialRecompensasUpdateWithWhereUniqueWithoutUsuariosInput | HistorialRecompensasUpdateWithWhereUniqueWithoutUsuariosInput[]
    updateMany?: HistorialRecompensasUpdateManyWithWhereWithoutUsuariosInput | HistorialRecompensasUpdateManyWithWhereWithoutUsuariosInput[]
    deleteMany?: HistorialRecompensasScalarWhereInput | HistorialRecompensasScalarWhereInput[]
  }

  export type HorariosUpdateManyWithoutUsuariosNestedInput = {
    create?: XOR<HorariosCreateWithoutUsuariosInput, HorariosUncheckedCreateWithoutUsuariosInput> | HorariosCreateWithoutUsuariosInput[] | HorariosUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: HorariosCreateOrConnectWithoutUsuariosInput | HorariosCreateOrConnectWithoutUsuariosInput[]
    upsert?: HorariosUpsertWithWhereUniqueWithoutUsuariosInput | HorariosUpsertWithWhereUniqueWithoutUsuariosInput[]
    createMany?: HorariosCreateManyUsuariosInputEnvelope
    set?: HorariosWhereUniqueInput | HorariosWhereUniqueInput[]
    disconnect?: HorariosWhereUniqueInput | HorariosWhereUniqueInput[]
    delete?: HorariosWhereUniqueInput | HorariosWhereUniqueInput[]
    connect?: HorariosWhereUniqueInput | HorariosWhereUniqueInput[]
    update?: HorariosUpdateWithWhereUniqueWithoutUsuariosInput | HorariosUpdateWithWhereUniqueWithoutUsuariosInput[]
    updateMany?: HorariosUpdateManyWithWhereWithoutUsuariosInput | HorariosUpdateManyWithWhereWithoutUsuariosInput[]
    deleteMany?: HorariosScalarWhereInput | HorariosScalarWhereInput[]
  }

  export type PuntosClientesUpdateManyWithoutUsuariosNestedInput = {
    create?: XOR<PuntosClientesCreateWithoutUsuariosInput, PuntosClientesUncheckedCreateWithoutUsuariosInput> | PuntosClientesCreateWithoutUsuariosInput[] | PuntosClientesUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: PuntosClientesCreateOrConnectWithoutUsuariosInput | PuntosClientesCreateOrConnectWithoutUsuariosInput[]
    upsert?: PuntosClientesUpsertWithWhereUniqueWithoutUsuariosInput | PuntosClientesUpsertWithWhereUniqueWithoutUsuariosInput[]
    createMany?: PuntosClientesCreateManyUsuariosInputEnvelope
    set?: PuntosClientesWhereUniqueInput | PuntosClientesWhereUniqueInput[]
    disconnect?: PuntosClientesWhereUniqueInput | PuntosClientesWhereUniqueInput[]
    delete?: PuntosClientesWhereUniqueInput | PuntosClientesWhereUniqueInput[]
    connect?: PuntosClientesWhereUniqueInput | PuntosClientesWhereUniqueInput[]
    update?: PuntosClientesUpdateWithWhereUniqueWithoutUsuariosInput | PuntosClientesUpdateWithWhereUniqueWithoutUsuariosInput[]
    updateMany?: PuntosClientesUpdateManyWithWhereWithoutUsuariosInput | PuntosClientesUpdateManyWithWhereWithoutUsuariosInput[]
    deleteMany?: PuntosClientesScalarWhereInput | PuntosClientesScalarWhereInput[]
  }

  export type RolesUpdateOneWithoutUsuariosNestedInput = {
    create?: XOR<RolesCreateWithoutUsuariosInput, RolesUncheckedCreateWithoutUsuariosInput>
    connectOrCreate?: RolesCreateOrConnectWithoutUsuariosInput
    upsert?: RolesUpsertWithoutUsuariosInput
    disconnect?: RolesWhereInput | boolean
    delete?: RolesWhereInput | boolean
    connect?: RolesWhereUniqueInput
    update?: XOR<XOR<RolesUpdateToOneWithWhereWithoutUsuariosInput, RolesUpdateWithoutUsuariosInput>, RolesUncheckedUpdateWithoutUsuariosInput>
  }

  export type ActividadClienteUncheckedUpdateManyWithoutUsuariosNestedInput = {
    create?: XOR<ActividadClienteCreateWithoutUsuariosInput, ActividadClienteUncheckedCreateWithoutUsuariosInput> | ActividadClienteCreateWithoutUsuariosInput[] | ActividadClienteUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: ActividadClienteCreateOrConnectWithoutUsuariosInput | ActividadClienteCreateOrConnectWithoutUsuariosInput[]
    upsert?: ActividadClienteUpsertWithWhereUniqueWithoutUsuariosInput | ActividadClienteUpsertWithWhereUniqueWithoutUsuariosInput[]
    createMany?: ActividadClienteCreateManyUsuariosInputEnvelope
    set?: ActividadClienteWhereUniqueInput | ActividadClienteWhereUniqueInput[]
    disconnect?: ActividadClienteWhereUniqueInput | ActividadClienteWhereUniqueInput[]
    delete?: ActividadClienteWhereUniqueInput | ActividadClienteWhereUniqueInput[]
    connect?: ActividadClienteWhereUniqueInput | ActividadClienteWhereUniqueInput[]
    update?: ActividadClienteUpdateWithWhereUniqueWithoutUsuariosInput | ActividadClienteUpdateWithWhereUniqueWithoutUsuariosInput[]
    updateMany?: ActividadClienteUpdateManyWithWhereWithoutUsuariosInput | ActividadClienteUpdateManyWithWhereWithoutUsuariosInput[]
    deleteMany?: ActividadClienteScalarWhereInput | ActividadClienteScalarWhereInput[]
  }

  export type BitacoraClienteUncheckedUpdateManyWithoutUsuariosNestedInput = {
    create?: XOR<BitacoraClienteCreateWithoutUsuariosInput, BitacoraClienteUncheckedCreateWithoutUsuariosInput> | BitacoraClienteCreateWithoutUsuariosInput[] | BitacoraClienteUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: BitacoraClienteCreateOrConnectWithoutUsuariosInput | BitacoraClienteCreateOrConnectWithoutUsuariosInput[]
    upsert?: BitacoraClienteUpsertWithWhereUniqueWithoutUsuariosInput | BitacoraClienteUpsertWithWhereUniqueWithoutUsuariosInput[]
    createMany?: BitacoraClienteCreateManyUsuariosInputEnvelope
    set?: BitacoraClienteWhereUniqueInput | BitacoraClienteWhereUniqueInput[]
    disconnect?: BitacoraClienteWhereUniqueInput | BitacoraClienteWhereUniqueInput[]
    delete?: BitacoraClienteWhereUniqueInput | BitacoraClienteWhereUniqueInput[]
    connect?: BitacoraClienteWhereUniqueInput | BitacoraClienteWhereUniqueInput[]
    update?: BitacoraClienteUpdateWithWhereUniqueWithoutUsuariosInput | BitacoraClienteUpdateWithWhereUniqueWithoutUsuariosInput[]
    updateMany?: BitacoraClienteUpdateManyWithWhereWithoutUsuariosInput | BitacoraClienteUpdateManyWithWhereWithoutUsuariosInput[]
    deleteMany?: BitacoraClienteScalarWhereInput | BitacoraClienteScalarWhereInput[]
  }

  export type BitacoraEstilistaUncheckedUpdateManyWithoutUsuariosNestedInput = {
    create?: XOR<BitacoraEstilistaCreateWithoutUsuariosInput, BitacoraEstilistaUncheckedCreateWithoutUsuariosInput> | BitacoraEstilistaCreateWithoutUsuariosInput[] | BitacoraEstilistaUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: BitacoraEstilistaCreateOrConnectWithoutUsuariosInput | BitacoraEstilistaCreateOrConnectWithoutUsuariosInput[]
    upsert?: BitacoraEstilistaUpsertWithWhereUniqueWithoutUsuariosInput | BitacoraEstilistaUpsertWithWhereUniqueWithoutUsuariosInput[]
    createMany?: BitacoraEstilistaCreateManyUsuariosInputEnvelope
    set?: BitacoraEstilistaWhereUniqueInput | BitacoraEstilistaWhereUniqueInput[]
    disconnect?: BitacoraEstilistaWhereUniqueInput | BitacoraEstilistaWhereUniqueInput[]
    delete?: BitacoraEstilistaWhereUniqueInput | BitacoraEstilistaWhereUniqueInput[]
    connect?: BitacoraEstilistaWhereUniqueInput | BitacoraEstilistaWhereUniqueInput[]
    update?: BitacoraEstilistaUpdateWithWhereUniqueWithoutUsuariosInput | BitacoraEstilistaUpdateWithWhereUniqueWithoutUsuariosInput[]
    updateMany?: BitacoraEstilistaUpdateManyWithWhereWithoutUsuariosInput | BitacoraEstilistaUpdateManyWithWhereWithoutUsuariosInput[]
    deleteMany?: BitacoraEstilistaScalarWhereInput | BitacoraEstilistaScalarWhereInput[]
  }

  export type BloqueoHorariosUncheckedUpdateManyWithoutUsuariosNestedInput = {
    create?: XOR<BloqueoHorariosCreateWithoutUsuariosInput, BloqueoHorariosUncheckedCreateWithoutUsuariosInput> | BloqueoHorariosCreateWithoutUsuariosInput[] | BloqueoHorariosUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: BloqueoHorariosCreateOrConnectWithoutUsuariosInput | BloqueoHorariosCreateOrConnectWithoutUsuariosInput[]
    upsert?: BloqueoHorariosUpsertWithWhereUniqueWithoutUsuariosInput | BloqueoHorariosUpsertWithWhereUniqueWithoutUsuariosInput[]
    createMany?: BloqueoHorariosCreateManyUsuariosInputEnvelope
    set?: BloqueoHorariosWhereUniqueInput | BloqueoHorariosWhereUniqueInput[]
    disconnect?: BloqueoHorariosWhereUniqueInput | BloqueoHorariosWhereUniqueInput[]
    delete?: BloqueoHorariosWhereUniqueInput | BloqueoHorariosWhereUniqueInput[]
    connect?: BloqueoHorariosWhereUniqueInput | BloqueoHorariosWhereUniqueInput[]
    update?: BloqueoHorariosUpdateWithWhereUniqueWithoutUsuariosInput | BloqueoHorariosUpdateWithWhereUniqueWithoutUsuariosInput[]
    updateMany?: BloqueoHorariosUpdateManyWithWhereWithoutUsuariosInput | BloqueoHorariosUpdateManyWithWhereWithoutUsuariosInput[]
    deleteMany?: BloqueoHorariosScalarWhereInput | BloqueoHorariosScalarWhereInput[]
  }

  export type CitasUncheckedUpdateManyWithoutUsuarios_Citas_clienteIDToUsuariosNestedInput = {
    create?: XOR<CitasCreateWithoutUsuarios_Citas_clienteIDToUsuariosInput, CitasUncheckedCreateWithoutUsuarios_Citas_clienteIDToUsuariosInput> | CitasCreateWithoutUsuarios_Citas_clienteIDToUsuariosInput[] | CitasUncheckedCreateWithoutUsuarios_Citas_clienteIDToUsuariosInput[]
    connectOrCreate?: CitasCreateOrConnectWithoutUsuarios_Citas_clienteIDToUsuariosInput | CitasCreateOrConnectWithoutUsuarios_Citas_clienteIDToUsuariosInput[]
    upsert?: CitasUpsertWithWhereUniqueWithoutUsuarios_Citas_clienteIDToUsuariosInput | CitasUpsertWithWhereUniqueWithoutUsuarios_Citas_clienteIDToUsuariosInput[]
    createMany?: CitasCreateManyUsuarios_Citas_clienteIDToUsuariosInputEnvelope
    set?: CitasWhereUniqueInput | CitasWhereUniqueInput[]
    disconnect?: CitasWhereUniqueInput | CitasWhereUniqueInput[]
    delete?: CitasWhereUniqueInput | CitasWhereUniqueInput[]
    connect?: CitasWhereUniqueInput | CitasWhereUniqueInput[]
    update?: CitasUpdateWithWhereUniqueWithoutUsuarios_Citas_clienteIDToUsuariosInput | CitasUpdateWithWhereUniqueWithoutUsuarios_Citas_clienteIDToUsuariosInput[]
    updateMany?: CitasUpdateManyWithWhereWithoutUsuarios_Citas_clienteIDToUsuariosInput | CitasUpdateManyWithWhereWithoutUsuarios_Citas_clienteIDToUsuariosInput[]
    deleteMany?: CitasScalarWhereInput | CitasScalarWhereInput[]
  }

  export type CitasUncheckedUpdateManyWithoutUsuarios_Citas_estilistaIDToUsuariosNestedInput = {
    create?: XOR<CitasCreateWithoutUsuarios_Citas_estilistaIDToUsuariosInput, CitasUncheckedCreateWithoutUsuarios_Citas_estilistaIDToUsuariosInput> | CitasCreateWithoutUsuarios_Citas_estilistaIDToUsuariosInput[] | CitasUncheckedCreateWithoutUsuarios_Citas_estilistaIDToUsuariosInput[]
    connectOrCreate?: CitasCreateOrConnectWithoutUsuarios_Citas_estilistaIDToUsuariosInput | CitasCreateOrConnectWithoutUsuarios_Citas_estilistaIDToUsuariosInput[]
    upsert?: CitasUpsertWithWhereUniqueWithoutUsuarios_Citas_estilistaIDToUsuariosInput | CitasUpsertWithWhereUniqueWithoutUsuarios_Citas_estilistaIDToUsuariosInput[]
    createMany?: CitasCreateManyUsuarios_Citas_estilistaIDToUsuariosInputEnvelope
    set?: CitasWhereUniqueInput | CitasWhereUniqueInput[]
    disconnect?: CitasWhereUniqueInput | CitasWhereUniqueInput[]
    delete?: CitasWhereUniqueInput | CitasWhereUniqueInput[]
    connect?: CitasWhereUniqueInput | CitasWhereUniqueInput[]
    update?: CitasUpdateWithWhereUniqueWithoutUsuarios_Citas_estilistaIDToUsuariosInput | CitasUpdateWithWhereUniqueWithoutUsuarios_Citas_estilistaIDToUsuariosInput[]
    updateMany?: CitasUpdateManyWithWhereWithoutUsuarios_Citas_estilistaIDToUsuariosInput | CitasUpdateManyWithWhereWithoutUsuarios_Citas_estilistaIDToUsuariosInput[]
    deleteMany?: CitasScalarWhereInput | CitasScalarWhereInput[]
  }

  export type HistorialCitasUncheckedUpdateManyWithoutUsuariosNestedInput = {
    create?: XOR<HistorialCitasCreateWithoutUsuariosInput, HistorialCitasUncheckedCreateWithoutUsuariosInput> | HistorialCitasCreateWithoutUsuariosInput[] | HistorialCitasUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: HistorialCitasCreateOrConnectWithoutUsuariosInput | HistorialCitasCreateOrConnectWithoutUsuariosInput[]
    upsert?: HistorialCitasUpsertWithWhereUniqueWithoutUsuariosInput | HistorialCitasUpsertWithWhereUniqueWithoutUsuariosInput[]
    createMany?: HistorialCitasCreateManyUsuariosInputEnvelope
    set?: HistorialCitasWhereUniqueInput | HistorialCitasWhereUniqueInput[]
    disconnect?: HistorialCitasWhereUniqueInput | HistorialCitasWhereUniqueInput[]
    delete?: HistorialCitasWhereUniqueInput | HistorialCitasWhereUniqueInput[]
    connect?: HistorialCitasWhereUniqueInput | HistorialCitasWhereUniqueInput[]
    update?: HistorialCitasUpdateWithWhereUniqueWithoutUsuariosInput | HistorialCitasUpdateWithWhereUniqueWithoutUsuariosInput[]
    updateMany?: HistorialCitasUpdateManyWithWhereWithoutUsuariosInput | HistorialCitasUpdateManyWithWhereWithoutUsuariosInput[]
    deleteMany?: HistorialCitasScalarWhereInput | HistorialCitasScalarWhereInput[]
  }

  export type HistorialRecompensasUncheckedUpdateManyWithoutUsuariosNestedInput = {
    create?: XOR<HistorialRecompensasCreateWithoutUsuariosInput, HistorialRecompensasUncheckedCreateWithoutUsuariosInput> | HistorialRecompensasCreateWithoutUsuariosInput[] | HistorialRecompensasUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: HistorialRecompensasCreateOrConnectWithoutUsuariosInput | HistorialRecompensasCreateOrConnectWithoutUsuariosInput[]
    upsert?: HistorialRecompensasUpsertWithWhereUniqueWithoutUsuariosInput | HistorialRecompensasUpsertWithWhereUniqueWithoutUsuariosInput[]
    createMany?: HistorialRecompensasCreateManyUsuariosInputEnvelope
    set?: HistorialRecompensasWhereUniqueInput | HistorialRecompensasWhereUniqueInput[]
    disconnect?: HistorialRecompensasWhereUniqueInput | HistorialRecompensasWhereUniqueInput[]
    delete?: HistorialRecompensasWhereUniqueInput | HistorialRecompensasWhereUniqueInput[]
    connect?: HistorialRecompensasWhereUniqueInput | HistorialRecompensasWhereUniqueInput[]
    update?: HistorialRecompensasUpdateWithWhereUniqueWithoutUsuariosInput | HistorialRecompensasUpdateWithWhereUniqueWithoutUsuariosInput[]
    updateMany?: HistorialRecompensasUpdateManyWithWhereWithoutUsuariosInput | HistorialRecompensasUpdateManyWithWhereWithoutUsuariosInput[]
    deleteMany?: HistorialRecompensasScalarWhereInput | HistorialRecompensasScalarWhereInput[]
  }

  export type HorariosUncheckedUpdateManyWithoutUsuariosNestedInput = {
    create?: XOR<HorariosCreateWithoutUsuariosInput, HorariosUncheckedCreateWithoutUsuariosInput> | HorariosCreateWithoutUsuariosInput[] | HorariosUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: HorariosCreateOrConnectWithoutUsuariosInput | HorariosCreateOrConnectWithoutUsuariosInput[]
    upsert?: HorariosUpsertWithWhereUniqueWithoutUsuariosInput | HorariosUpsertWithWhereUniqueWithoutUsuariosInput[]
    createMany?: HorariosCreateManyUsuariosInputEnvelope
    set?: HorariosWhereUniqueInput | HorariosWhereUniqueInput[]
    disconnect?: HorariosWhereUniqueInput | HorariosWhereUniqueInput[]
    delete?: HorariosWhereUniqueInput | HorariosWhereUniqueInput[]
    connect?: HorariosWhereUniqueInput | HorariosWhereUniqueInput[]
    update?: HorariosUpdateWithWhereUniqueWithoutUsuariosInput | HorariosUpdateWithWhereUniqueWithoutUsuariosInput[]
    updateMany?: HorariosUpdateManyWithWhereWithoutUsuariosInput | HorariosUpdateManyWithWhereWithoutUsuariosInput[]
    deleteMany?: HorariosScalarWhereInput | HorariosScalarWhereInput[]
  }

  export type PuntosClientesUncheckedUpdateManyWithoutUsuariosNestedInput = {
    create?: XOR<PuntosClientesCreateWithoutUsuariosInput, PuntosClientesUncheckedCreateWithoutUsuariosInput> | PuntosClientesCreateWithoutUsuariosInput[] | PuntosClientesUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: PuntosClientesCreateOrConnectWithoutUsuariosInput | PuntosClientesCreateOrConnectWithoutUsuariosInput[]
    upsert?: PuntosClientesUpsertWithWhereUniqueWithoutUsuariosInput | PuntosClientesUpsertWithWhereUniqueWithoutUsuariosInput[]
    createMany?: PuntosClientesCreateManyUsuariosInputEnvelope
    set?: PuntosClientesWhereUniqueInput | PuntosClientesWhereUniqueInput[]
    disconnect?: PuntosClientesWhereUniqueInput | PuntosClientesWhereUniqueInput[]
    delete?: PuntosClientesWhereUniqueInput | PuntosClientesWhereUniqueInput[]
    connect?: PuntosClientesWhereUniqueInput | PuntosClientesWhereUniqueInput[]
    update?: PuntosClientesUpdateWithWhereUniqueWithoutUsuariosInput | PuntosClientesUpdateWithWhereUniqueWithoutUsuariosInput[]
    updateMany?: PuntosClientesUpdateManyWithWhereWithoutUsuariosInput | PuntosClientesUpdateManyWithWhereWithoutUsuariosInput[]
    deleteMany?: PuntosClientesScalarWhereInput | PuntosClientesScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type UsuariosCreateWithoutActividadClienteInput = {
    nombre: string
    apellidos: string
    telefono?: string | null
    correo: string
    direccion?: string | null
    contra: string
    estado?: string | null
    BitacoraCliente?: BitacoraClienteCreateNestedManyWithoutUsuariosInput
    BitacoraEstilista?: BitacoraEstilistaCreateNestedManyWithoutUsuariosInput
    BloqueoHorarios?: BloqueoHorariosCreateNestedManyWithoutUsuariosInput
    Citas_Citas_clienteIDToUsuarios?: CitasCreateNestedManyWithoutUsuarios_Citas_clienteIDToUsuariosInput
    Citas_Citas_estilistaIDToUsuarios?: CitasCreateNestedManyWithoutUsuarios_Citas_estilistaIDToUsuariosInput
    HistorialCitas?: HistorialCitasCreateNestedManyWithoutUsuariosInput
    HistorialRecompensas?: HistorialRecompensasCreateNestedManyWithoutUsuariosInput
    Horarios?: HorariosCreateNestedManyWithoutUsuariosInput
    PuntosClientes?: PuntosClientesCreateNestedManyWithoutUsuariosInput
    Roles?: RolesCreateNestedOneWithoutUsuariosInput
  }

  export type UsuariosUncheckedCreateWithoutActividadClienteInput = {
    usuarioID?: number
    nombre: string
    apellidos: string
    telefono?: string | null
    correo: string
    direccion?: string | null
    contra: string
    rolID?: number | null
    estado?: string | null
    BitacoraCliente?: BitacoraClienteUncheckedCreateNestedManyWithoutUsuariosInput
    BitacoraEstilista?: BitacoraEstilistaUncheckedCreateNestedManyWithoutUsuariosInput
    BloqueoHorarios?: BloqueoHorariosUncheckedCreateNestedManyWithoutUsuariosInput
    Citas_Citas_clienteIDToUsuarios?: CitasUncheckedCreateNestedManyWithoutUsuarios_Citas_clienteIDToUsuariosInput
    Citas_Citas_estilistaIDToUsuarios?: CitasUncheckedCreateNestedManyWithoutUsuarios_Citas_estilistaIDToUsuariosInput
    HistorialCitas?: HistorialCitasUncheckedCreateNestedManyWithoutUsuariosInput
    HistorialRecompensas?: HistorialRecompensasUncheckedCreateNestedManyWithoutUsuariosInput
    Horarios?: HorariosUncheckedCreateNestedManyWithoutUsuariosInput
    PuntosClientes?: PuntosClientesUncheckedCreateNestedManyWithoutUsuariosInput
  }

  export type UsuariosCreateOrConnectWithoutActividadClienteInput = {
    where: UsuariosWhereUniqueInput
    create: XOR<UsuariosCreateWithoutActividadClienteInput, UsuariosUncheckedCreateWithoutActividadClienteInput>
  }

  export type CitasCreateWithoutActividadClienteInput = {
    comentarios?: string | null
    Usuarios_Citas_clienteIDToUsuarios?: UsuariosCreateNestedOneWithoutCitas_Citas_clienteIDToUsuariosInput
    EstadoCita?: EstadoCitaCreateNestedOneWithoutCitasInput
    Usuarios_Citas_estilistaIDToUsuarios?: UsuariosCreateNestedOneWithoutCitas_Citas_estilistaIDToUsuariosInput
    DetallesCita?: DetallesCitaCreateNestedManyWithoutCitasInput
    HistorialCitas?: HistorialCitasCreateNestedManyWithoutCitasInput
    HorariosReservados?: HorariosReservadosCreateNestedOneWithoutCitasInput
  }

  export type CitasUncheckedCreateWithoutActividadClienteInput = {
    citaID?: number
    clienteID?: number | null
    estilistaID?: number | null
    comentarios?: string | null
    estadoID?: number | null
    DetallesCita?: DetallesCitaUncheckedCreateNestedManyWithoutCitasInput
    HistorialCitas?: HistorialCitasUncheckedCreateNestedManyWithoutCitasInput
    HorariosReservados?: HorariosReservadosUncheckedCreateNestedOneWithoutCitasInput
  }

  export type CitasCreateOrConnectWithoutActividadClienteInput = {
    where: CitasWhereUniqueInput
    create: XOR<CitasCreateWithoutActividadClienteInput, CitasUncheckedCreateWithoutActividadClienteInput>
  }

  export type UsuariosUpsertWithoutActividadClienteInput = {
    update: XOR<UsuariosUpdateWithoutActividadClienteInput, UsuariosUncheckedUpdateWithoutActividadClienteInput>
    create: XOR<UsuariosCreateWithoutActividadClienteInput, UsuariosUncheckedCreateWithoutActividadClienteInput>
    where?: UsuariosWhereInput
  }

  export type UsuariosUpdateToOneWithWhereWithoutActividadClienteInput = {
    where?: UsuariosWhereInput
    data: XOR<UsuariosUpdateWithoutActividadClienteInput, UsuariosUncheckedUpdateWithoutActividadClienteInput>
  }

  export type UsuariosUpdateWithoutActividadClienteInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    contra?: StringFieldUpdateOperationsInput | string
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    BitacoraCliente?: BitacoraClienteUpdateManyWithoutUsuariosNestedInput
    BitacoraEstilista?: BitacoraEstilistaUpdateManyWithoutUsuariosNestedInput
    BloqueoHorarios?: BloqueoHorariosUpdateManyWithoutUsuariosNestedInput
    Citas_Citas_clienteIDToUsuarios?: CitasUpdateManyWithoutUsuarios_Citas_clienteIDToUsuariosNestedInput
    Citas_Citas_estilistaIDToUsuarios?: CitasUpdateManyWithoutUsuarios_Citas_estilistaIDToUsuariosNestedInput
    HistorialCitas?: HistorialCitasUpdateManyWithoutUsuariosNestedInput
    HistorialRecompensas?: HistorialRecompensasUpdateManyWithoutUsuariosNestedInput
    Horarios?: HorariosUpdateManyWithoutUsuariosNestedInput
    PuntosClientes?: PuntosClientesUpdateManyWithoutUsuariosNestedInput
    Roles?: RolesUpdateOneWithoutUsuariosNestedInput
  }

  export type UsuariosUncheckedUpdateWithoutActividadClienteInput = {
    usuarioID?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    contra?: StringFieldUpdateOperationsInput | string
    rolID?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    BitacoraCliente?: BitacoraClienteUncheckedUpdateManyWithoutUsuariosNestedInput
    BitacoraEstilista?: BitacoraEstilistaUncheckedUpdateManyWithoutUsuariosNestedInput
    BloqueoHorarios?: BloqueoHorariosUncheckedUpdateManyWithoutUsuariosNestedInput
    Citas_Citas_clienteIDToUsuarios?: CitasUncheckedUpdateManyWithoutUsuarios_Citas_clienteIDToUsuariosNestedInput
    Citas_Citas_estilistaIDToUsuarios?: CitasUncheckedUpdateManyWithoutUsuarios_Citas_estilistaIDToUsuariosNestedInput
    HistorialCitas?: HistorialCitasUncheckedUpdateManyWithoutUsuariosNestedInput
    HistorialRecompensas?: HistorialRecompensasUncheckedUpdateManyWithoutUsuariosNestedInput
    Horarios?: HorariosUncheckedUpdateManyWithoutUsuariosNestedInput
    PuntosClientes?: PuntosClientesUncheckedUpdateManyWithoutUsuariosNestedInput
  }

  export type CitasUpsertWithoutActividadClienteInput = {
    update: XOR<CitasUpdateWithoutActividadClienteInput, CitasUncheckedUpdateWithoutActividadClienteInput>
    create: XOR<CitasCreateWithoutActividadClienteInput, CitasUncheckedCreateWithoutActividadClienteInput>
    where?: CitasWhereInput
  }

  export type CitasUpdateToOneWithWhereWithoutActividadClienteInput = {
    where?: CitasWhereInput
    data: XOR<CitasUpdateWithoutActividadClienteInput, CitasUncheckedUpdateWithoutActividadClienteInput>
  }

  export type CitasUpdateWithoutActividadClienteInput = {
    comentarios?: NullableStringFieldUpdateOperationsInput | string | null
    Usuarios_Citas_clienteIDToUsuarios?: UsuariosUpdateOneWithoutCitas_Citas_clienteIDToUsuariosNestedInput
    EstadoCita?: EstadoCitaUpdateOneWithoutCitasNestedInput
    Usuarios_Citas_estilistaIDToUsuarios?: UsuariosUpdateOneWithoutCitas_Citas_estilistaIDToUsuariosNestedInput
    DetallesCita?: DetallesCitaUpdateManyWithoutCitasNestedInput
    HistorialCitas?: HistorialCitasUpdateManyWithoutCitasNestedInput
    HorariosReservados?: HorariosReservadosUpdateOneWithoutCitasNestedInput
  }

  export type CitasUncheckedUpdateWithoutActividadClienteInput = {
    citaID?: IntFieldUpdateOperationsInput | number
    clienteID?: NullableIntFieldUpdateOperationsInput | number | null
    estilistaID?: NullableIntFieldUpdateOperationsInput | number | null
    comentarios?: NullableStringFieldUpdateOperationsInput | string | null
    estadoID?: NullableIntFieldUpdateOperationsInput | number | null
    DetallesCita?: DetallesCitaUncheckedUpdateManyWithoutCitasNestedInput
    HistorialCitas?: HistorialCitasUncheckedUpdateManyWithoutCitasNestedInput
    HorariosReservados?: HorariosReservadosUncheckedUpdateOneWithoutCitasNestedInput
  }

  export type UsuariosCreateWithoutBitacoraClienteInput = {
    nombre: string
    apellidos: string
    telefono?: string | null
    correo: string
    direccion?: string | null
    contra: string
    estado?: string | null
    ActividadCliente?: ActividadClienteCreateNestedManyWithoutUsuariosInput
    BitacoraEstilista?: BitacoraEstilistaCreateNestedManyWithoutUsuariosInput
    BloqueoHorarios?: BloqueoHorariosCreateNestedManyWithoutUsuariosInput
    Citas_Citas_clienteIDToUsuarios?: CitasCreateNestedManyWithoutUsuarios_Citas_clienteIDToUsuariosInput
    Citas_Citas_estilistaIDToUsuarios?: CitasCreateNestedManyWithoutUsuarios_Citas_estilistaIDToUsuariosInput
    HistorialCitas?: HistorialCitasCreateNestedManyWithoutUsuariosInput
    HistorialRecompensas?: HistorialRecompensasCreateNestedManyWithoutUsuariosInput
    Horarios?: HorariosCreateNestedManyWithoutUsuariosInput
    PuntosClientes?: PuntosClientesCreateNestedManyWithoutUsuariosInput
    Roles?: RolesCreateNestedOneWithoutUsuariosInput
  }

  export type UsuariosUncheckedCreateWithoutBitacoraClienteInput = {
    usuarioID?: number
    nombre: string
    apellidos: string
    telefono?: string | null
    correo: string
    direccion?: string | null
    contra: string
    rolID?: number | null
    estado?: string | null
    ActividadCliente?: ActividadClienteUncheckedCreateNestedManyWithoutUsuariosInput
    BitacoraEstilista?: BitacoraEstilistaUncheckedCreateNestedManyWithoutUsuariosInput
    BloqueoHorarios?: BloqueoHorariosUncheckedCreateNestedManyWithoutUsuariosInput
    Citas_Citas_clienteIDToUsuarios?: CitasUncheckedCreateNestedManyWithoutUsuarios_Citas_clienteIDToUsuariosInput
    Citas_Citas_estilistaIDToUsuarios?: CitasUncheckedCreateNestedManyWithoutUsuarios_Citas_estilistaIDToUsuariosInput
    HistorialCitas?: HistorialCitasUncheckedCreateNestedManyWithoutUsuariosInput
    HistorialRecompensas?: HistorialRecompensasUncheckedCreateNestedManyWithoutUsuariosInput
    Horarios?: HorariosUncheckedCreateNestedManyWithoutUsuariosInput
    PuntosClientes?: PuntosClientesUncheckedCreateNestedManyWithoutUsuariosInput
  }

  export type UsuariosCreateOrConnectWithoutBitacoraClienteInput = {
    where: UsuariosWhereUniqueInput
    create: XOR<UsuariosCreateWithoutBitacoraClienteInput, UsuariosUncheckedCreateWithoutBitacoraClienteInput>
  }

  export type UsuariosUpsertWithoutBitacoraClienteInput = {
    update: XOR<UsuariosUpdateWithoutBitacoraClienteInput, UsuariosUncheckedUpdateWithoutBitacoraClienteInput>
    create: XOR<UsuariosCreateWithoutBitacoraClienteInput, UsuariosUncheckedCreateWithoutBitacoraClienteInput>
    where?: UsuariosWhereInput
  }

  export type UsuariosUpdateToOneWithWhereWithoutBitacoraClienteInput = {
    where?: UsuariosWhereInput
    data: XOR<UsuariosUpdateWithoutBitacoraClienteInput, UsuariosUncheckedUpdateWithoutBitacoraClienteInput>
  }

  export type UsuariosUpdateWithoutBitacoraClienteInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    contra?: StringFieldUpdateOperationsInput | string
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    ActividadCliente?: ActividadClienteUpdateManyWithoutUsuariosNestedInput
    BitacoraEstilista?: BitacoraEstilistaUpdateManyWithoutUsuariosNestedInput
    BloqueoHorarios?: BloqueoHorariosUpdateManyWithoutUsuariosNestedInput
    Citas_Citas_clienteIDToUsuarios?: CitasUpdateManyWithoutUsuarios_Citas_clienteIDToUsuariosNestedInput
    Citas_Citas_estilistaIDToUsuarios?: CitasUpdateManyWithoutUsuarios_Citas_estilistaIDToUsuariosNestedInput
    HistorialCitas?: HistorialCitasUpdateManyWithoutUsuariosNestedInput
    HistorialRecompensas?: HistorialRecompensasUpdateManyWithoutUsuariosNestedInput
    Horarios?: HorariosUpdateManyWithoutUsuariosNestedInput
    PuntosClientes?: PuntosClientesUpdateManyWithoutUsuariosNestedInput
    Roles?: RolesUpdateOneWithoutUsuariosNestedInput
  }

  export type UsuariosUncheckedUpdateWithoutBitacoraClienteInput = {
    usuarioID?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    contra?: StringFieldUpdateOperationsInput | string
    rolID?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    ActividadCliente?: ActividadClienteUncheckedUpdateManyWithoutUsuariosNestedInput
    BitacoraEstilista?: BitacoraEstilistaUncheckedUpdateManyWithoutUsuariosNestedInput
    BloqueoHorarios?: BloqueoHorariosUncheckedUpdateManyWithoutUsuariosNestedInput
    Citas_Citas_clienteIDToUsuarios?: CitasUncheckedUpdateManyWithoutUsuarios_Citas_clienteIDToUsuariosNestedInput
    Citas_Citas_estilistaIDToUsuarios?: CitasUncheckedUpdateManyWithoutUsuarios_Citas_estilistaIDToUsuariosNestedInput
    HistorialCitas?: HistorialCitasUncheckedUpdateManyWithoutUsuariosNestedInput
    HistorialRecompensas?: HistorialRecompensasUncheckedUpdateManyWithoutUsuariosNestedInput
    Horarios?: HorariosUncheckedUpdateManyWithoutUsuariosNestedInput
    PuntosClientes?: PuntosClientesUncheckedUpdateManyWithoutUsuariosNestedInput
  }

  export type UsuariosCreateWithoutBitacoraEstilistaInput = {
    nombre: string
    apellidos: string
    telefono?: string | null
    correo: string
    direccion?: string | null
    contra: string
    estado?: string | null
    ActividadCliente?: ActividadClienteCreateNestedManyWithoutUsuariosInput
    BitacoraCliente?: BitacoraClienteCreateNestedManyWithoutUsuariosInput
    BloqueoHorarios?: BloqueoHorariosCreateNestedManyWithoutUsuariosInput
    Citas_Citas_clienteIDToUsuarios?: CitasCreateNestedManyWithoutUsuarios_Citas_clienteIDToUsuariosInput
    Citas_Citas_estilistaIDToUsuarios?: CitasCreateNestedManyWithoutUsuarios_Citas_estilistaIDToUsuariosInput
    HistorialCitas?: HistorialCitasCreateNestedManyWithoutUsuariosInput
    HistorialRecompensas?: HistorialRecompensasCreateNestedManyWithoutUsuariosInput
    Horarios?: HorariosCreateNestedManyWithoutUsuariosInput
    PuntosClientes?: PuntosClientesCreateNestedManyWithoutUsuariosInput
    Roles?: RolesCreateNestedOneWithoutUsuariosInput
  }

  export type UsuariosUncheckedCreateWithoutBitacoraEstilistaInput = {
    usuarioID?: number
    nombre: string
    apellidos: string
    telefono?: string | null
    correo: string
    direccion?: string | null
    contra: string
    rolID?: number | null
    estado?: string | null
    ActividadCliente?: ActividadClienteUncheckedCreateNestedManyWithoutUsuariosInput
    BitacoraCliente?: BitacoraClienteUncheckedCreateNestedManyWithoutUsuariosInput
    BloqueoHorarios?: BloqueoHorariosUncheckedCreateNestedManyWithoutUsuariosInput
    Citas_Citas_clienteIDToUsuarios?: CitasUncheckedCreateNestedManyWithoutUsuarios_Citas_clienteIDToUsuariosInput
    Citas_Citas_estilistaIDToUsuarios?: CitasUncheckedCreateNestedManyWithoutUsuarios_Citas_estilistaIDToUsuariosInput
    HistorialCitas?: HistorialCitasUncheckedCreateNestedManyWithoutUsuariosInput
    HistorialRecompensas?: HistorialRecompensasUncheckedCreateNestedManyWithoutUsuariosInput
    Horarios?: HorariosUncheckedCreateNestedManyWithoutUsuariosInput
    PuntosClientes?: PuntosClientesUncheckedCreateNestedManyWithoutUsuariosInput
  }

  export type UsuariosCreateOrConnectWithoutBitacoraEstilistaInput = {
    where: UsuariosWhereUniqueInput
    create: XOR<UsuariosCreateWithoutBitacoraEstilistaInput, UsuariosUncheckedCreateWithoutBitacoraEstilistaInput>
  }

  export type UsuariosUpsertWithoutBitacoraEstilistaInput = {
    update: XOR<UsuariosUpdateWithoutBitacoraEstilistaInput, UsuariosUncheckedUpdateWithoutBitacoraEstilistaInput>
    create: XOR<UsuariosCreateWithoutBitacoraEstilistaInput, UsuariosUncheckedCreateWithoutBitacoraEstilistaInput>
    where?: UsuariosWhereInput
  }

  export type UsuariosUpdateToOneWithWhereWithoutBitacoraEstilistaInput = {
    where?: UsuariosWhereInput
    data: XOR<UsuariosUpdateWithoutBitacoraEstilistaInput, UsuariosUncheckedUpdateWithoutBitacoraEstilistaInput>
  }

  export type UsuariosUpdateWithoutBitacoraEstilistaInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    contra?: StringFieldUpdateOperationsInput | string
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    ActividadCliente?: ActividadClienteUpdateManyWithoutUsuariosNestedInput
    BitacoraCliente?: BitacoraClienteUpdateManyWithoutUsuariosNestedInput
    BloqueoHorarios?: BloqueoHorariosUpdateManyWithoutUsuariosNestedInput
    Citas_Citas_clienteIDToUsuarios?: CitasUpdateManyWithoutUsuarios_Citas_clienteIDToUsuariosNestedInput
    Citas_Citas_estilistaIDToUsuarios?: CitasUpdateManyWithoutUsuarios_Citas_estilistaIDToUsuariosNestedInput
    HistorialCitas?: HistorialCitasUpdateManyWithoutUsuariosNestedInput
    HistorialRecompensas?: HistorialRecompensasUpdateManyWithoutUsuariosNestedInput
    Horarios?: HorariosUpdateManyWithoutUsuariosNestedInput
    PuntosClientes?: PuntosClientesUpdateManyWithoutUsuariosNestedInput
    Roles?: RolesUpdateOneWithoutUsuariosNestedInput
  }

  export type UsuariosUncheckedUpdateWithoutBitacoraEstilistaInput = {
    usuarioID?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    contra?: StringFieldUpdateOperationsInput | string
    rolID?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    ActividadCliente?: ActividadClienteUncheckedUpdateManyWithoutUsuariosNestedInput
    BitacoraCliente?: BitacoraClienteUncheckedUpdateManyWithoutUsuariosNestedInput
    BloqueoHorarios?: BloqueoHorariosUncheckedUpdateManyWithoutUsuariosNestedInput
    Citas_Citas_clienteIDToUsuarios?: CitasUncheckedUpdateManyWithoutUsuarios_Citas_clienteIDToUsuariosNestedInput
    Citas_Citas_estilistaIDToUsuarios?: CitasUncheckedUpdateManyWithoutUsuarios_Citas_estilistaIDToUsuariosNestedInput
    HistorialCitas?: HistorialCitasUncheckedUpdateManyWithoutUsuariosNestedInput
    HistorialRecompensas?: HistorialRecompensasUncheckedUpdateManyWithoutUsuariosNestedInput
    Horarios?: HorariosUncheckedUpdateManyWithoutUsuariosNestedInput
    PuntosClientes?: PuntosClientesUncheckedUpdateManyWithoutUsuariosNestedInput
  }

  export type UsuariosCreateWithoutBloqueoHorariosInput = {
    nombre: string
    apellidos: string
    telefono?: string | null
    correo: string
    direccion?: string | null
    contra: string
    estado?: string | null
    ActividadCliente?: ActividadClienteCreateNestedManyWithoutUsuariosInput
    BitacoraCliente?: BitacoraClienteCreateNestedManyWithoutUsuariosInput
    BitacoraEstilista?: BitacoraEstilistaCreateNestedManyWithoutUsuariosInput
    Citas_Citas_clienteIDToUsuarios?: CitasCreateNestedManyWithoutUsuarios_Citas_clienteIDToUsuariosInput
    Citas_Citas_estilistaIDToUsuarios?: CitasCreateNestedManyWithoutUsuarios_Citas_estilistaIDToUsuariosInput
    HistorialCitas?: HistorialCitasCreateNestedManyWithoutUsuariosInput
    HistorialRecompensas?: HistorialRecompensasCreateNestedManyWithoutUsuariosInput
    Horarios?: HorariosCreateNestedManyWithoutUsuariosInput
    PuntosClientes?: PuntosClientesCreateNestedManyWithoutUsuariosInput
    Roles?: RolesCreateNestedOneWithoutUsuariosInput
  }

  export type UsuariosUncheckedCreateWithoutBloqueoHorariosInput = {
    usuarioID?: number
    nombre: string
    apellidos: string
    telefono?: string | null
    correo: string
    direccion?: string | null
    contra: string
    rolID?: number | null
    estado?: string | null
    ActividadCliente?: ActividadClienteUncheckedCreateNestedManyWithoutUsuariosInput
    BitacoraCliente?: BitacoraClienteUncheckedCreateNestedManyWithoutUsuariosInput
    BitacoraEstilista?: BitacoraEstilistaUncheckedCreateNestedManyWithoutUsuariosInput
    Citas_Citas_clienteIDToUsuarios?: CitasUncheckedCreateNestedManyWithoutUsuarios_Citas_clienteIDToUsuariosInput
    Citas_Citas_estilistaIDToUsuarios?: CitasUncheckedCreateNestedManyWithoutUsuarios_Citas_estilistaIDToUsuariosInput
    HistorialCitas?: HistorialCitasUncheckedCreateNestedManyWithoutUsuariosInput
    HistorialRecompensas?: HistorialRecompensasUncheckedCreateNestedManyWithoutUsuariosInput
    Horarios?: HorariosUncheckedCreateNestedManyWithoutUsuariosInput
    PuntosClientes?: PuntosClientesUncheckedCreateNestedManyWithoutUsuariosInput
  }

  export type UsuariosCreateOrConnectWithoutBloqueoHorariosInput = {
    where: UsuariosWhereUniqueInput
    create: XOR<UsuariosCreateWithoutBloqueoHorariosInput, UsuariosUncheckedCreateWithoutBloqueoHorariosInput>
  }

  export type UsuariosUpsertWithoutBloqueoHorariosInput = {
    update: XOR<UsuariosUpdateWithoutBloqueoHorariosInput, UsuariosUncheckedUpdateWithoutBloqueoHorariosInput>
    create: XOR<UsuariosCreateWithoutBloqueoHorariosInput, UsuariosUncheckedCreateWithoutBloqueoHorariosInput>
    where?: UsuariosWhereInput
  }

  export type UsuariosUpdateToOneWithWhereWithoutBloqueoHorariosInput = {
    where?: UsuariosWhereInput
    data: XOR<UsuariosUpdateWithoutBloqueoHorariosInput, UsuariosUncheckedUpdateWithoutBloqueoHorariosInput>
  }

  export type UsuariosUpdateWithoutBloqueoHorariosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    contra?: StringFieldUpdateOperationsInput | string
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    ActividadCliente?: ActividadClienteUpdateManyWithoutUsuariosNestedInput
    BitacoraCliente?: BitacoraClienteUpdateManyWithoutUsuariosNestedInput
    BitacoraEstilista?: BitacoraEstilistaUpdateManyWithoutUsuariosNestedInput
    Citas_Citas_clienteIDToUsuarios?: CitasUpdateManyWithoutUsuarios_Citas_clienteIDToUsuariosNestedInput
    Citas_Citas_estilistaIDToUsuarios?: CitasUpdateManyWithoutUsuarios_Citas_estilistaIDToUsuariosNestedInput
    HistorialCitas?: HistorialCitasUpdateManyWithoutUsuariosNestedInput
    HistorialRecompensas?: HistorialRecompensasUpdateManyWithoutUsuariosNestedInput
    Horarios?: HorariosUpdateManyWithoutUsuariosNestedInput
    PuntosClientes?: PuntosClientesUpdateManyWithoutUsuariosNestedInput
    Roles?: RolesUpdateOneWithoutUsuariosNestedInput
  }

  export type UsuariosUncheckedUpdateWithoutBloqueoHorariosInput = {
    usuarioID?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    contra?: StringFieldUpdateOperationsInput | string
    rolID?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    ActividadCliente?: ActividadClienteUncheckedUpdateManyWithoutUsuariosNestedInput
    BitacoraCliente?: BitacoraClienteUncheckedUpdateManyWithoutUsuariosNestedInput
    BitacoraEstilista?: BitacoraEstilistaUncheckedUpdateManyWithoutUsuariosNestedInput
    Citas_Citas_clienteIDToUsuarios?: CitasUncheckedUpdateManyWithoutUsuarios_Citas_clienteIDToUsuariosNestedInput
    Citas_Citas_estilistaIDToUsuarios?: CitasUncheckedUpdateManyWithoutUsuarios_Citas_estilistaIDToUsuariosNestedInput
    HistorialCitas?: HistorialCitasUncheckedUpdateManyWithoutUsuariosNestedInput
    HistorialRecompensas?: HistorialRecompensasUncheckedUpdateManyWithoutUsuariosNestedInput
    Horarios?: HorariosUncheckedUpdateManyWithoutUsuariosNestedInput
    PuntosClientes?: PuntosClientesUncheckedUpdateManyWithoutUsuariosNestedInput
  }

  export type ActividadClienteCreateWithoutCitasInput = {
    ultimaConexion?: Date | string | null
    Usuarios?: UsuariosCreateNestedOneWithoutActividadClienteInput
  }

  export type ActividadClienteUncheckedCreateWithoutCitasInput = {
    actividadID?: number
    clienteID?: number | null
    ultimaConexion?: Date | string | null
  }

  export type ActividadClienteCreateOrConnectWithoutCitasInput = {
    where: ActividadClienteWhereUniqueInput
    create: XOR<ActividadClienteCreateWithoutCitasInput, ActividadClienteUncheckedCreateWithoutCitasInput>
  }

  export type ActividadClienteCreateManyCitasInputEnvelope = {
    data: ActividadClienteCreateManyCitasInput | ActividadClienteCreateManyCitasInput[]
  }

  export type UsuariosCreateWithoutCitas_Citas_clienteIDToUsuariosInput = {
    nombre: string
    apellidos: string
    telefono?: string | null
    correo: string
    direccion?: string | null
    contra: string
    estado?: string | null
    ActividadCliente?: ActividadClienteCreateNestedManyWithoutUsuariosInput
    BitacoraCliente?: BitacoraClienteCreateNestedManyWithoutUsuariosInput
    BitacoraEstilista?: BitacoraEstilistaCreateNestedManyWithoutUsuariosInput
    BloqueoHorarios?: BloqueoHorariosCreateNestedManyWithoutUsuariosInput
    Citas_Citas_estilistaIDToUsuarios?: CitasCreateNestedManyWithoutUsuarios_Citas_estilistaIDToUsuariosInput
    HistorialCitas?: HistorialCitasCreateNestedManyWithoutUsuariosInput
    HistorialRecompensas?: HistorialRecompensasCreateNestedManyWithoutUsuariosInput
    Horarios?: HorariosCreateNestedManyWithoutUsuariosInput
    PuntosClientes?: PuntosClientesCreateNestedManyWithoutUsuariosInput
    Roles?: RolesCreateNestedOneWithoutUsuariosInput
  }

  export type UsuariosUncheckedCreateWithoutCitas_Citas_clienteIDToUsuariosInput = {
    usuarioID?: number
    nombre: string
    apellidos: string
    telefono?: string | null
    correo: string
    direccion?: string | null
    contra: string
    rolID?: number | null
    estado?: string | null
    ActividadCliente?: ActividadClienteUncheckedCreateNestedManyWithoutUsuariosInput
    BitacoraCliente?: BitacoraClienteUncheckedCreateNestedManyWithoutUsuariosInput
    BitacoraEstilista?: BitacoraEstilistaUncheckedCreateNestedManyWithoutUsuariosInput
    BloqueoHorarios?: BloqueoHorariosUncheckedCreateNestedManyWithoutUsuariosInput
    Citas_Citas_estilistaIDToUsuarios?: CitasUncheckedCreateNestedManyWithoutUsuarios_Citas_estilistaIDToUsuariosInput
    HistorialCitas?: HistorialCitasUncheckedCreateNestedManyWithoutUsuariosInput
    HistorialRecompensas?: HistorialRecompensasUncheckedCreateNestedManyWithoutUsuariosInput
    Horarios?: HorariosUncheckedCreateNestedManyWithoutUsuariosInput
    PuntosClientes?: PuntosClientesUncheckedCreateNestedManyWithoutUsuariosInput
  }

  export type UsuariosCreateOrConnectWithoutCitas_Citas_clienteIDToUsuariosInput = {
    where: UsuariosWhereUniqueInput
    create: XOR<UsuariosCreateWithoutCitas_Citas_clienteIDToUsuariosInput, UsuariosUncheckedCreateWithoutCitas_Citas_clienteIDToUsuariosInput>
  }

  export type EstadoCitaCreateWithoutCitasInput = {
    nombre?: string | null
  }

  export type EstadoCitaUncheckedCreateWithoutCitasInput = {
    estadoID?: number
    nombre?: string | null
  }

  export type EstadoCitaCreateOrConnectWithoutCitasInput = {
    where: EstadoCitaWhereUniqueInput
    create: XOR<EstadoCitaCreateWithoutCitasInput, EstadoCitaUncheckedCreateWithoutCitasInput>
  }

  export type UsuariosCreateWithoutCitas_Citas_estilistaIDToUsuariosInput = {
    nombre: string
    apellidos: string
    telefono?: string | null
    correo: string
    direccion?: string | null
    contra: string
    estado?: string | null
    ActividadCliente?: ActividadClienteCreateNestedManyWithoutUsuariosInput
    BitacoraCliente?: BitacoraClienteCreateNestedManyWithoutUsuariosInput
    BitacoraEstilista?: BitacoraEstilistaCreateNestedManyWithoutUsuariosInput
    BloqueoHorarios?: BloqueoHorariosCreateNestedManyWithoutUsuariosInput
    Citas_Citas_clienteIDToUsuarios?: CitasCreateNestedManyWithoutUsuarios_Citas_clienteIDToUsuariosInput
    HistorialCitas?: HistorialCitasCreateNestedManyWithoutUsuariosInput
    HistorialRecompensas?: HistorialRecompensasCreateNestedManyWithoutUsuariosInput
    Horarios?: HorariosCreateNestedManyWithoutUsuariosInput
    PuntosClientes?: PuntosClientesCreateNestedManyWithoutUsuariosInput
    Roles?: RolesCreateNestedOneWithoutUsuariosInput
  }

  export type UsuariosUncheckedCreateWithoutCitas_Citas_estilistaIDToUsuariosInput = {
    usuarioID?: number
    nombre: string
    apellidos: string
    telefono?: string | null
    correo: string
    direccion?: string | null
    contra: string
    rolID?: number | null
    estado?: string | null
    ActividadCliente?: ActividadClienteUncheckedCreateNestedManyWithoutUsuariosInput
    BitacoraCliente?: BitacoraClienteUncheckedCreateNestedManyWithoutUsuariosInput
    BitacoraEstilista?: BitacoraEstilistaUncheckedCreateNestedManyWithoutUsuariosInput
    BloqueoHorarios?: BloqueoHorariosUncheckedCreateNestedManyWithoutUsuariosInput
    Citas_Citas_clienteIDToUsuarios?: CitasUncheckedCreateNestedManyWithoutUsuarios_Citas_clienteIDToUsuariosInput
    HistorialCitas?: HistorialCitasUncheckedCreateNestedManyWithoutUsuariosInput
    HistorialRecompensas?: HistorialRecompensasUncheckedCreateNestedManyWithoutUsuariosInput
    Horarios?: HorariosUncheckedCreateNestedManyWithoutUsuariosInput
    PuntosClientes?: PuntosClientesUncheckedCreateNestedManyWithoutUsuariosInput
  }

  export type UsuariosCreateOrConnectWithoutCitas_Citas_estilistaIDToUsuariosInput = {
    where: UsuariosWhereUniqueInput
    create: XOR<UsuariosCreateWithoutCitas_Citas_estilistaIDToUsuariosInput, UsuariosUncheckedCreateWithoutCitas_Citas_estilistaIDToUsuariosInput>
  }

  export type DetallesCitaCreateWithoutCitasInput = {
    Servicios?: ServiciosCreateNestedOneWithoutDetallesCitaInput
  }

  export type DetallesCitaUncheckedCreateWithoutCitasInput = {
    detalleID?: number
    servicioID?: number | null
  }

  export type DetallesCitaCreateOrConnectWithoutCitasInput = {
    where: DetallesCitaWhereUniqueInput
    create: XOR<DetallesCitaCreateWithoutCitasInput, DetallesCitaUncheckedCreateWithoutCitasInput>
  }

  export type DetallesCitaCreateManyCitasInputEnvelope = {
    data: DetallesCitaCreateManyCitasInput | DetallesCitaCreateManyCitasInput[]
  }

  export type HistorialCitasCreateWithoutCitasInput = {
    Usuarios?: UsuariosCreateNestedOneWithoutHistorialCitasInput
  }

  export type HistorialCitasUncheckedCreateWithoutCitasInput = {
    historialCitasID?: number
    clienteID?: number | null
  }

  export type HistorialCitasCreateOrConnectWithoutCitasInput = {
    where: HistorialCitasWhereUniqueInput
    create: XOR<HistorialCitasCreateWithoutCitasInput, HistorialCitasUncheckedCreateWithoutCitasInput>
  }

  export type HistorialCitasCreateManyCitasInputEnvelope = {
    data: HistorialCitasCreateManyCitasInput | HistorialCitasCreateManyCitasInput[]
  }

  export type HorariosReservadosCreateWithoutCitasInput = {
    dia?: Date | string | null
    hora_inicio?: Date | string | null
    hora_fin?: Date | string | null
  }

  export type HorariosReservadosUncheckedCreateWithoutCitasInput = {
    dia?: Date | string | null
    hora_inicio?: Date | string | null
    hora_fin?: Date | string | null
  }

  export type HorariosReservadosCreateOrConnectWithoutCitasInput = {
    where: HorariosReservadosWhereUniqueInput
    create: XOR<HorariosReservadosCreateWithoutCitasInput, HorariosReservadosUncheckedCreateWithoutCitasInput>
  }

  export type ActividadClienteUpsertWithWhereUniqueWithoutCitasInput = {
    where: ActividadClienteWhereUniqueInput
    update: XOR<ActividadClienteUpdateWithoutCitasInput, ActividadClienteUncheckedUpdateWithoutCitasInput>
    create: XOR<ActividadClienteCreateWithoutCitasInput, ActividadClienteUncheckedCreateWithoutCitasInput>
  }

  export type ActividadClienteUpdateWithWhereUniqueWithoutCitasInput = {
    where: ActividadClienteWhereUniqueInput
    data: XOR<ActividadClienteUpdateWithoutCitasInput, ActividadClienteUncheckedUpdateWithoutCitasInput>
  }

  export type ActividadClienteUpdateManyWithWhereWithoutCitasInput = {
    where: ActividadClienteScalarWhereInput
    data: XOR<ActividadClienteUpdateManyMutationInput, ActividadClienteUncheckedUpdateManyWithoutCitasInput>
  }

  export type ActividadClienteScalarWhereInput = {
    AND?: ActividadClienteScalarWhereInput | ActividadClienteScalarWhereInput[]
    OR?: ActividadClienteScalarWhereInput[]
    NOT?: ActividadClienteScalarWhereInput | ActividadClienteScalarWhereInput[]
    actividadID?: IntFilter<"ActividadCliente"> | number
    clienteID?: IntNullableFilter<"ActividadCliente"> | number | null
    ultimaConexion?: DateTimeNullableFilter<"ActividadCliente"> | Date | string | null
    ultimaCitaID?: IntNullableFilter<"ActividadCliente"> | number | null
  }

  export type UsuariosUpsertWithoutCitas_Citas_clienteIDToUsuariosInput = {
    update: XOR<UsuariosUpdateWithoutCitas_Citas_clienteIDToUsuariosInput, UsuariosUncheckedUpdateWithoutCitas_Citas_clienteIDToUsuariosInput>
    create: XOR<UsuariosCreateWithoutCitas_Citas_clienteIDToUsuariosInput, UsuariosUncheckedCreateWithoutCitas_Citas_clienteIDToUsuariosInput>
    where?: UsuariosWhereInput
  }

  export type UsuariosUpdateToOneWithWhereWithoutCitas_Citas_clienteIDToUsuariosInput = {
    where?: UsuariosWhereInput
    data: XOR<UsuariosUpdateWithoutCitas_Citas_clienteIDToUsuariosInput, UsuariosUncheckedUpdateWithoutCitas_Citas_clienteIDToUsuariosInput>
  }

  export type UsuariosUpdateWithoutCitas_Citas_clienteIDToUsuariosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    contra?: StringFieldUpdateOperationsInput | string
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    ActividadCliente?: ActividadClienteUpdateManyWithoutUsuariosNestedInput
    BitacoraCliente?: BitacoraClienteUpdateManyWithoutUsuariosNestedInput
    BitacoraEstilista?: BitacoraEstilistaUpdateManyWithoutUsuariosNestedInput
    BloqueoHorarios?: BloqueoHorariosUpdateManyWithoutUsuariosNestedInput
    Citas_Citas_estilistaIDToUsuarios?: CitasUpdateManyWithoutUsuarios_Citas_estilistaIDToUsuariosNestedInput
    HistorialCitas?: HistorialCitasUpdateManyWithoutUsuariosNestedInput
    HistorialRecompensas?: HistorialRecompensasUpdateManyWithoutUsuariosNestedInput
    Horarios?: HorariosUpdateManyWithoutUsuariosNestedInput
    PuntosClientes?: PuntosClientesUpdateManyWithoutUsuariosNestedInput
    Roles?: RolesUpdateOneWithoutUsuariosNestedInput
  }

  export type UsuariosUncheckedUpdateWithoutCitas_Citas_clienteIDToUsuariosInput = {
    usuarioID?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    contra?: StringFieldUpdateOperationsInput | string
    rolID?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    ActividadCliente?: ActividadClienteUncheckedUpdateManyWithoutUsuariosNestedInput
    BitacoraCliente?: BitacoraClienteUncheckedUpdateManyWithoutUsuariosNestedInput
    BitacoraEstilista?: BitacoraEstilistaUncheckedUpdateManyWithoutUsuariosNestedInput
    BloqueoHorarios?: BloqueoHorariosUncheckedUpdateManyWithoutUsuariosNestedInput
    Citas_Citas_estilistaIDToUsuarios?: CitasUncheckedUpdateManyWithoutUsuarios_Citas_estilistaIDToUsuariosNestedInput
    HistorialCitas?: HistorialCitasUncheckedUpdateManyWithoutUsuariosNestedInput
    HistorialRecompensas?: HistorialRecompensasUncheckedUpdateManyWithoutUsuariosNestedInput
    Horarios?: HorariosUncheckedUpdateManyWithoutUsuariosNestedInput
    PuntosClientes?: PuntosClientesUncheckedUpdateManyWithoutUsuariosNestedInput
  }

  export type EstadoCitaUpsertWithoutCitasInput = {
    update: XOR<EstadoCitaUpdateWithoutCitasInput, EstadoCitaUncheckedUpdateWithoutCitasInput>
    create: XOR<EstadoCitaCreateWithoutCitasInput, EstadoCitaUncheckedCreateWithoutCitasInput>
    where?: EstadoCitaWhereInput
  }

  export type EstadoCitaUpdateToOneWithWhereWithoutCitasInput = {
    where?: EstadoCitaWhereInput
    data: XOR<EstadoCitaUpdateWithoutCitasInput, EstadoCitaUncheckedUpdateWithoutCitasInput>
  }

  export type EstadoCitaUpdateWithoutCitasInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EstadoCitaUncheckedUpdateWithoutCitasInput = {
    estadoID?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UsuariosUpsertWithoutCitas_Citas_estilistaIDToUsuariosInput = {
    update: XOR<UsuariosUpdateWithoutCitas_Citas_estilistaIDToUsuariosInput, UsuariosUncheckedUpdateWithoutCitas_Citas_estilistaIDToUsuariosInput>
    create: XOR<UsuariosCreateWithoutCitas_Citas_estilistaIDToUsuariosInput, UsuariosUncheckedCreateWithoutCitas_Citas_estilistaIDToUsuariosInput>
    where?: UsuariosWhereInput
  }

  export type UsuariosUpdateToOneWithWhereWithoutCitas_Citas_estilistaIDToUsuariosInput = {
    where?: UsuariosWhereInput
    data: XOR<UsuariosUpdateWithoutCitas_Citas_estilistaIDToUsuariosInput, UsuariosUncheckedUpdateWithoutCitas_Citas_estilistaIDToUsuariosInput>
  }

  export type UsuariosUpdateWithoutCitas_Citas_estilistaIDToUsuariosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    contra?: StringFieldUpdateOperationsInput | string
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    ActividadCliente?: ActividadClienteUpdateManyWithoutUsuariosNestedInput
    BitacoraCliente?: BitacoraClienteUpdateManyWithoutUsuariosNestedInput
    BitacoraEstilista?: BitacoraEstilistaUpdateManyWithoutUsuariosNestedInput
    BloqueoHorarios?: BloqueoHorariosUpdateManyWithoutUsuariosNestedInput
    Citas_Citas_clienteIDToUsuarios?: CitasUpdateManyWithoutUsuarios_Citas_clienteIDToUsuariosNestedInput
    HistorialCitas?: HistorialCitasUpdateManyWithoutUsuariosNestedInput
    HistorialRecompensas?: HistorialRecompensasUpdateManyWithoutUsuariosNestedInput
    Horarios?: HorariosUpdateManyWithoutUsuariosNestedInput
    PuntosClientes?: PuntosClientesUpdateManyWithoutUsuariosNestedInput
    Roles?: RolesUpdateOneWithoutUsuariosNestedInput
  }

  export type UsuariosUncheckedUpdateWithoutCitas_Citas_estilistaIDToUsuariosInput = {
    usuarioID?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    contra?: StringFieldUpdateOperationsInput | string
    rolID?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    ActividadCliente?: ActividadClienteUncheckedUpdateManyWithoutUsuariosNestedInput
    BitacoraCliente?: BitacoraClienteUncheckedUpdateManyWithoutUsuariosNestedInput
    BitacoraEstilista?: BitacoraEstilistaUncheckedUpdateManyWithoutUsuariosNestedInput
    BloqueoHorarios?: BloqueoHorariosUncheckedUpdateManyWithoutUsuariosNestedInput
    Citas_Citas_clienteIDToUsuarios?: CitasUncheckedUpdateManyWithoutUsuarios_Citas_clienteIDToUsuariosNestedInput
    HistorialCitas?: HistorialCitasUncheckedUpdateManyWithoutUsuariosNestedInput
    HistorialRecompensas?: HistorialRecompensasUncheckedUpdateManyWithoutUsuariosNestedInput
    Horarios?: HorariosUncheckedUpdateManyWithoutUsuariosNestedInput
    PuntosClientes?: PuntosClientesUncheckedUpdateManyWithoutUsuariosNestedInput
  }

  export type DetallesCitaUpsertWithWhereUniqueWithoutCitasInput = {
    where: DetallesCitaWhereUniqueInput
    update: XOR<DetallesCitaUpdateWithoutCitasInput, DetallesCitaUncheckedUpdateWithoutCitasInput>
    create: XOR<DetallesCitaCreateWithoutCitasInput, DetallesCitaUncheckedCreateWithoutCitasInput>
  }

  export type DetallesCitaUpdateWithWhereUniqueWithoutCitasInput = {
    where: DetallesCitaWhereUniqueInput
    data: XOR<DetallesCitaUpdateWithoutCitasInput, DetallesCitaUncheckedUpdateWithoutCitasInput>
  }

  export type DetallesCitaUpdateManyWithWhereWithoutCitasInput = {
    where: DetallesCitaScalarWhereInput
    data: XOR<DetallesCitaUpdateManyMutationInput, DetallesCitaUncheckedUpdateManyWithoutCitasInput>
  }

  export type DetallesCitaScalarWhereInput = {
    AND?: DetallesCitaScalarWhereInput | DetallesCitaScalarWhereInput[]
    OR?: DetallesCitaScalarWhereInput[]
    NOT?: DetallesCitaScalarWhereInput | DetallesCitaScalarWhereInput[]
    detalleID?: IntFilter<"DetallesCita"> | number
    citaID?: IntNullableFilter<"DetallesCita"> | number | null
    servicioID?: IntNullableFilter<"DetallesCita"> | number | null
  }

  export type HistorialCitasUpsertWithWhereUniqueWithoutCitasInput = {
    where: HistorialCitasWhereUniqueInput
    update: XOR<HistorialCitasUpdateWithoutCitasInput, HistorialCitasUncheckedUpdateWithoutCitasInput>
    create: XOR<HistorialCitasCreateWithoutCitasInput, HistorialCitasUncheckedCreateWithoutCitasInput>
  }

  export type HistorialCitasUpdateWithWhereUniqueWithoutCitasInput = {
    where: HistorialCitasWhereUniqueInput
    data: XOR<HistorialCitasUpdateWithoutCitasInput, HistorialCitasUncheckedUpdateWithoutCitasInput>
  }

  export type HistorialCitasUpdateManyWithWhereWithoutCitasInput = {
    where: HistorialCitasScalarWhereInput
    data: XOR<HistorialCitasUpdateManyMutationInput, HistorialCitasUncheckedUpdateManyWithoutCitasInput>
  }

  export type HistorialCitasScalarWhereInput = {
    AND?: HistorialCitasScalarWhereInput | HistorialCitasScalarWhereInput[]
    OR?: HistorialCitasScalarWhereInput[]
    NOT?: HistorialCitasScalarWhereInput | HistorialCitasScalarWhereInput[]
    historialCitasID?: IntFilter<"HistorialCitas"> | number
    clienteID?: IntNullableFilter<"HistorialCitas"> | number | null
    citaID?: IntNullableFilter<"HistorialCitas"> | number | null
  }

  export type HorariosReservadosUpsertWithoutCitasInput = {
    update: XOR<HorariosReservadosUpdateWithoutCitasInput, HorariosReservadosUncheckedUpdateWithoutCitasInput>
    create: XOR<HorariosReservadosCreateWithoutCitasInput, HorariosReservadosUncheckedCreateWithoutCitasInput>
    where?: HorariosReservadosWhereInput
  }

  export type HorariosReservadosUpdateToOneWithWhereWithoutCitasInput = {
    where?: HorariosReservadosWhereInput
    data: XOR<HorariosReservadosUpdateWithoutCitasInput, HorariosReservadosUncheckedUpdateWithoutCitasInput>
  }

  export type HorariosReservadosUpdateWithoutCitasInput = {
    dia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hora_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hora_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type HorariosReservadosUncheckedUpdateWithoutCitasInput = {
    dia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hora_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hora_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CitasCreateWithoutDetallesCitaInput = {
    comentarios?: string | null
    ActividadCliente?: ActividadClienteCreateNestedManyWithoutCitasInput
    Usuarios_Citas_clienteIDToUsuarios?: UsuariosCreateNestedOneWithoutCitas_Citas_clienteIDToUsuariosInput
    EstadoCita?: EstadoCitaCreateNestedOneWithoutCitasInput
    Usuarios_Citas_estilistaIDToUsuarios?: UsuariosCreateNestedOneWithoutCitas_Citas_estilistaIDToUsuariosInput
    HistorialCitas?: HistorialCitasCreateNestedManyWithoutCitasInput
    HorariosReservados?: HorariosReservadosCreateNestedOneWithoutCitasInput
  }

  export type CitasUncheckedCreateWithoutDetallesCitaInput = {
    citaID?: number
    clienteID?: number | null
    estilistaID?: number | null
    comentarios?: string | null
    estadoID?: number | null
    ActividadCliente?: ActividadClienteUncheckedCreateNestedManyWithoutCitasInput
    HistorialCitas?: HistorialCitasUncheckedCreateNestedManyWithoutCitasInput
    HorariosReservados?: HorariosReservadosUncheckedCreateNestedOneWithoutCitasInput
  }

  export type CitasCreateOrConnectWithoutDetallesCitaInput = {
    where: CitasWhereUniqueInput
    create: XOR<CitasCreateWithoutDetallesCitaInput, CitasUncheckedCreateWithoutDetallesCitaInput>
  }

  export type ServiciosCreateWithoutDetallesCitaInput = {
    nombreServicio?: string | null
    descripcion?: string | null
    tiempoEstimado?: Date | string | null
    precio?: number | null
    rutaImagen?: string | null
    HistorialRecompensas?: HistorialRecompensasCreateNestedManyWithoutServiciosInput
    PuntosServicio?: PuntosServicioCreateNestedOneWithoutServiciosInput
  }

  export type ServiciosUncheckedCreateWithoutDetallesCitaInput = {
    servicioID?: number
    nombreServicio?: string | null
    descripcion?: string | null
    tiempoEstimado?: Date | string | null
    precio?: number | null
    rutaImagen?: string | null
    HistorialRecompensas?: HistorialRecompensasUncheckedCreateNestedManyWithoutServiciosInput
    PuntosServicio?: PuntosServicioUncheckedCreateNestedOneWithoutServiciosInput
  }

  export type ServiciosCreateOrConnectWithoutDetallesCitaInput = {
    where: ServiciosWhereUniqueInput
    create: XOR<ServiciosCreateWithoutDetallesCitaInput, ServiciosUncheckedCreateWithoutDetallesCitaInput>
  }

  export type CitasUpsertWithoutDetallesCitaInput = {
    update: XOR<CitasUpdateWithoutDetallesCitaInput, CitasUncheckedUpdateWithoutDetallesCitaInput>
    create: XOR<CitasCreateWithoutDetallesCitaInput, CitasUncheckedCreateWithoutDetallesCitaInput>
    where?: CitasWhereInput
  }

  export type CitasUpdateToOneWithWhereWithoutDetallesCitaInput = {
    where?: CitasWhereInput
    data: XOR<CitasUpdateWithoutDetallesCitaInput, CitasUncheckedUpdateWithoutDetallesCitaInput>
  }

  export type CitasUpdateWithoutDetallesCitaInput = {
    comentarios?: NullableStringFieldUpdateOperationsInput | string | null
    ActividadCliente?: ActividadClienteUpdateManyWithoutCitasNestedInput
    Usuarios_Citas_clienteIDToUsuarios?: UsuariosUpdateOneWithoutCitas_Citas_clienteIDToUsuariosNestedInput
    EstadoCita?: EstadoCitaUpdateOneWithoutCitasNestedInput
    Usuarios_Citas_estilistaIDToUsuarios?: UsuariosUpdateOneWithoutCitas_Citas_estilistaIDToUsuariosNestedInput
    HistorialCitas?: HistorialCitasUpdateManyWithoutCitasNestedInput
    HorariosReservados?: HorariosReservadosUpdateOneWithoutCitasNestedInput
  }

  export type CitasUncheckedUpdateWithoutDetallesCitaInput = {
    citaID?: IntFieldUpdateOperationsInput | number
    clienteID?: NullableIntFieldUpdateOperationsInput | number | null
    estilistaID?: NullableIntFieldUpdateOperationsInput | number | null
    comentarios?: NullableStringFieldUpdateOperationsInput | string | null
    estadoID?: NullableIntFieldUpdateOperationsInput | number | null
    ActividadCliente?: ActividadClienteUncheckedUpdateManyWithoutCitasNestedInput
    HistorialCitas?: HistorialCitasUncheckedUpdateManyWithoutCitasNestedInput
    HorariosReservados?: HorariosReservadosUncheckedUpdateOneWithoutCitasNestedInput
  }

  export type ServiciosUpsertWithoutDetallesCitaInput = {
    update: XOR<ServiciosUpdateWithoutDetallesCitaInput, ServiciosUncheckedUpdateWithoutDetallesCitaInput>
    create: XOR<ServiciosCreateWithoutDetallesCitaInput, ServiciosUncheckedCreateWithoutDetallesCitaInput>
    where?: ServiciosWhereInput
  }

  export type ServiciosUpdateToOneWithWhereWithoutDetallesCitaInput = {
    where?: ServiciosWhereInput
    data: XOR<ServiciosUpdateWithoutDetallesCitaInput, ServiciosUncheckedUpdateWithoutDetallesCitaInput>
  }

  export type ServiciosUpdateWithoutDetallesCitaInput = {
    nombreServicio?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    tiempoEstimado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    precio?: NullableIntFieldUpdateOperationsInput | number | null
    rutaImagen?: NullableStringFieldUpdateOperationsInput | string | null
    HistorialRecompensas?: HistorialRecompensasUpdateManyWithoutServiciosNestedInput
    PuntosServicio?: PuntosServicioUpdateOneWithoutServiciosNestedInput
  }

  export type ServiciosUncheckedUpdateWithoutDetallesCitaInput = {
    servicioID?: IntFieldUpdateOperationsInput | number
    nombreServicio?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    tiempoEstimado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    precio?: NullableIntFieldUpdateOperationsInput | number | null
    rutaImagen?: NullableStringFieldUpdateOperationsInput | string | null
    HistorialRecompensas?: HistorialRecompensasUncheckedUpdateManyWithoutServiciosNestedInput
    PuntosServicio?: PuntosServicioUncheckedUpdateOneWithoutServiciosNestedInput
  }

  export type CitasCreateWithoutEstadoCitaInput = {
    comentarios?: string | null
    ActividadCliente?: ActividadClienteCreateNestedManyWithoutCitasInput
    Usuarios_Citas_clienteIDToUsuarios?: UsuariosCreateNestedOneWithoutCitas_Citas_clienteIDToUsuariosInput
    Usuarios_Citas_estilistaIDToUsuarios?: UsuariosCreateNestedOneWithoutCitas_Citas_estilistaIDToUsuariosInput
    DetallesCita?: DetallesCitaCreateNestedManyWithoutCitasInput
    HistorialCitas?: HistorialCitasCreateNestedManyWithoutCitasInput
    HorariosReservados?: HorariosReservadosCreateNestedOneWithoutCitasInput
  }

  export type CitasUncheckedCreateWithoutEstadoCitaInput = {
    citaID?: number
    clienteID?: number | null
    estilistaID?: number | null
    comentarios?: string | null
    ActividadCliente?: ActividadClienteUncheckedCreateNestedManyWithoutCitasInput
    DetallesCita?: DetallesCitaUncheckedCreateNestedManyWithoutCitasInput
    HistorialCitas?: HistorialCitasUncheckedCreateNestedManyWithoutCitasInput
    HorariosReservados?: HorariosReservadosUncheckedCreateNestedOneWithoutCitasInput
  }

  export type CitasCreateOrConnectWithoutEstadoCitaInput = {
    where: CitasWhereUniqueInput
    create: XOR<CitasCreateWithoutEstadoCitaInput, CitasUncheckedCreateWithoutEstadoCitaInput>
  }

  export type CitasCreateManyEstadoCitaInputEnvelope = {
    data: CitasCreateManyEstadoCitaInput | CitasCreateManyEstadoCitaInput[]
  }

  export type CitasUpsertWithWhereUniqueWithoutEstadoCitaInput = {
    where: CitasWhereUniqueInput
    update: XOR<CitasUpdateWithoutEstadoCitaInput, CitasUncheckedUpdateWithoutEstadoCitaInput>
    create: XOR<CitasCreateWithoutEstadoCitaInput, CitasUncheckedCreateWithoutEstadoCitaInput>
  }

  export type CitasUpdateWithWhereUniqueWithoutEstadoCitaInput = {
    where: CitasWhereUniqueInput
    data: XOR<CitasUpdateWithoutEstadoCitaInput, CitasUncheckedUpdateWithoutEstadoCitaInput>
  }

  export type CitasUpdateManyWithWhereWithoutEstadoCitaInput = {
    where: CitasScalarWhereInput
    data: XOR<CitasUpdateManyMutationInput, CitasUncheckedUpdateManyWithoutEstadoCitaInput>
  }

  export type CitasScalarWhereInput = {
    AND?: CitasScalarWhereInput | CitasScalarWhereInput[]
    OR?: CitasScalarWhereInput[]
    NOT?: CitasScalarWhereInput | CitasScalarWhereInput[]
    citaID?: IntFilter<"Citas"> | number
    clienteID?: IntNullableFilter<"Citas"> | number | null
    estilistaID?: IntNullableFilter<"Citas"> | number | null
    comentarios?: StringNullableFilter<"Citas"> | string | null
    estadoID?: IntNullableFilter<"Citas"> | number | null
  }

  export type CitasCreateWithoutHistorialCitasInput = {
    comentarios?: string | null
    ActividadCliente?: ActividadClienteCreateNestedManyWithoutCitasInput
    Usuarios_Citas_clienteIDToUsuarios?: UsuariosCreateNestedOneWithoutCitas_Citas_clienteIDToUsuariosInput
    EstadoCita?: EstadoCitaCreateNestedOneWithoutCitasInput
    Usuarios_Citas_estilistaIDToUsuarios?: UsuariosCreateNestedOneWithoutCitas_Citas_estilistaIDToUsuariosInput
    DetallesCita?: DetallesCitaCreateNestedManyWithoutCitasInput
    HorariosReservados?: HorariosReservadosCreateNestedOneWithoutCitasInput
  }

  export type CitasUncheckedCreateWithoutHistorialCitasInput = {
    citaID?: number
    clienteID?: number | null
    estilistaID?: number | null
    comentarios?: string | null
    estadoID?: number | null
    ActividadCliente?: ActividadClienteUncheckedCreateNestedManyWithoutCitasInput
    DetallesCita?: DetallesCitaUncheckedCreateNestedManyWithoutCitasInput
    HorariosReservados?: HorariosReservadosUncheckedCreateNestedOneWithoutCitasInput
  }

  export type CitasCreateOrConnectWithoutHistorialCitasInput = {
    where: CitasWhereUniqueInput
    create: XOR<CitasCreateWithoutHistorialCitasInput, CitasUncheckedCreateWithoutHistorialCitasInput>
  }

  export type UsuariosCreateWithoutHistorialCitasInput = {
    nombre: string
    apellidos: string
    telefono?: string | null
    correo: string
    direccion?: string | null
    contra: string
    estado?: string | null
    ActividadCliente?: ActividadClienteCreateNestedManyWithoutUsuariosInput
    BitacoraCliente?: BitacoraClienteCreateNestedManyWithoutUsuariosInput
    BitacoraEstilista?: BitacoraEstilistaCreateNestedManyWithoutUsuariosInput
    BloqueoHorarios?: BloqueoHorariosCreateNestedManyWithoutUsuariosInput
    Citas_Citas_clienteIDToUsuarios?: CitasCreateNestedManyWithoutUsuarios_Citas_clienteIDToUsuariosInput
    Citas_Citas_estilistaIDToUsuarios?: CitasCreateNestedManyWithoutUsuarios_Citas_estilistaIDToUsuariosInput
    HistorialRecompensas?: HistorialRecompensasCreateNestedManyWithoutUsuariosInput
    Horarios?: HorariosCreateNestedManyWithoutUsuariosInput
    PuntosClientes?: PuntosClientesCreateNestedManyWithoutUsuariosInput
    Roles?: RolesCreateNestedOneWithoutUsuariosInput
  }

  export type UsuariosUncheckedCreateWithoutHistorialCitasInput = {
    usuarioID?: number
    nombre: string
    apellidos: string
    telefono?: string | null
    correo: string
    direccion?: string | null
    contra: string
    rolID?: number | null
    estado?: string | null
    ActividadCliente?: ActividadClienteUncheckedCreateNestedManyWithoutUsuariosInput
    BitacoraCliente?: BitacoraClienteUncheckedCreateNestedManyWithoutUsuariosInput
    BitacoraEstilista?: BitacoraEstilistaUncheckedCreateNestedManyWithoutUsuariosInput
    BloqueoHorarios?: BloqueoHorariosUncheckedCreateNestedManyWithoutUsuariosInput
    Citas_Citas_clienteIDToUsuarios?: CitasUncheckedCreateNestedManyWithoutUsuarios_Citas_clienteIDToUsuariosInput
    Citas_Citas_estilistaIDToUsuarios?: CitasUncheckedCreateNestedManyWithoutUsuarios_Citas_estilistaIDToUsuariosInput
    HistorialRecompensas?: HistorialRecompensasUncheckedCreateNestedManyWithoutUsuariosInput
    Horarios?: HorariosUncheckedCreateNestedManyWithoutUsuariosInput
    PuntosClientes?: PuntosClientesUncheckedCreateNestedManyWithoutUsuariosInput
  }

  export type UsuariosCreateOrConnectWithoutHistorialCitasInput = {
    where: UsuariosWhereUniqueInput
    create: XOR<UsuariosCreateWithoutHistorialCitasInput, UsuariosUncheckedCreateWithoutHistorialCitasInput>
  }

  export type CitasUpsertWithoutHistorialCitasInput = {
    update: XOR<CitasUpdateWithoutHistorialCitasInput, CitasUncheckedUpdateWithoutHistorialCitasInput>
    create: XOR<CitasCreateWithoutHistorialCitasInput, CitasUncheckedCreateWithoutHistorialCitasInput>
    where?: CitasWhereInput
  }

  export type CitasUpdateToOneWithWhereWithoutHistorialCitasInput = {
    where?: CitasWhereInput
    data: XOR<CitasUpdateWithoutHistorialCitasInput, CitasUncheckedUpdateWithoutHistorialCitasInput>
  }

  export type CitasUpdateWithoutHistorialCitasInput = {
    comentarios?: NullableStringFieldUpdateOperationsInput | string | null
    ActividadCliente?: ActividadClienteUpdateManyWithoutCitasNestedInput
    Usuarios_Citas_clienteIDToUsuarios?: UsuariosUpdateOneWithoutCitas_Citas_clienteIDToUsuariosNestedInput
    EstadoCita?: EstadoCitaUpdateOneWithoutCitasNestedInput
    Usuarios_Citas_estilistaIDToUsuarios?: UsuariosUpdateOneWithoutCitas_Citas_estilistaIDToUsuariosNestedInput
    DetallesCita?: DetallesCitaUpdateManyWithoutCitasNestedInput
    HorariosReservados?: HorariosReservadosUpdateOneWithoutCitasNestedInput
  }

  export type CitasUncheckedUpdateWithoutHistorialCitasInput = {
    citaID?: IntFieldUpdateOperationsInput | number
    clienteID?: NullableIntFieldUpdateOperationsInput | number | null
    estilistaID?: NullableIntFieldUpdateOperationsInput | number | null
    comentarios?: NullableStringFieldUpdateOperationsInput | string | null
    estadoID?: NullableIntFieldUpdateOperationsInput | number | null
    ActividadCliente?: ActividadClienteUncheckedUpdateManyWithoutCitasNestedInput
    DetallesCita?: DetallesCitaUncheckedUpdateManyWithoutCitasNestedInput
    HorariosReservados?: HorariosReservadosUncheckedUpdateOneWithoutCitasNestedInput
  }

  export type UsuariosUpsertWithoutHistorialCitasInput = {
    update: XOR<UsuariosUpdateWithoutHistorialCitasInput, UsuariosUncheckedUpdateWithoutHistorialCitasInput>
    create: XOR<UsuariosCreateWithoutHistorialCitasInput, UsuariosUncheckedCreateWithoutHistorialCitasInput>
    where?: UsuariosWhereInput
  }

  export type UsuariosUpdateToOneWithWhereWithoutHistorialCitasInput = {
    where?: UsuariosWhereInput
    data: XOR<UsuariosUpdateWithoutHistorialCitasInput, UsuariosUncheckedUpdateWithoutHistorialCitasInput>
  }

  export type UsuariosUpdateWithoutHistorialCitasInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    contra?: StringFieldUpdateOperationsInput | string
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    ActividadCliente?: ActividadClienteUpdateManyWithoutUsuariosNestedInput
    BitacoraCliente?: BitacoraClienteUpdateManyWithoutUsuariosNestedInput
    BitacoraEstilista?: BitacoraEstilistaUpdateManyWithoutUsuariosNestedInput
    BloqueoHorarios?: BloqueoHorariosUpdateManyWithoutUsuariosNestedInput
    Citas_Citas_clienteIDToUsuarios?: CitasUpdateManyWithoutUsuarios_Citas_clienteIDToUsuariosNestedInput
    Citas_Citas_estilistaIDToUsuarios?: CitasUpdateManyWithoutUsuarios_Citas_estilistaIDToUsuariosNestedInput
    HistorialRecompensas?: HistorialRecompensasUpdateManyWithoutUsuariosNestedInput
    Horarios?: HorariosUpdateManyWithoutUsuariosNestedInput
    PuntosClientes?: PuntosClientesUpdateManyWithoutUsuariosNestedInput
    Roles?: RolesUpdateOneWithoutUsuariosNestedInput
  }

  export type UsuariosUncheckedUpdateWithoutHistorialCitasInput = {
    usuarioID?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    contra?: StringFieldUpdateOperationsInput | string
    rolID?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    ActividadCliente?: ActividadClienteUncheckedUpdateManyWithoutUsuariosNestedInput
    BitacoraCliente?: BitacoraClienteUncheckedUpdateManyWithoutUsuariosNestedInput
    BitacoraEstilista?: BitacoraEstilistaUncheckedUpdateManyWithoutUsuariosNestedInput
    BloqueoHorarios?: BloqueoHorariosUncheckedUpdateManyWithoutUsuariosNestedInput
    Citas_Citas_clienteIDToUsuarios?: CitasUncheckedUpdateManyWithoutUsuarios_Citas_clienteIDToUsuariosNestedInput
    Citas_Citas_estilistaIDToUsuarios?: CitasUncheckedUpdateManyWithoutUsuarios_Citas_estilistaIDToUsuariosNestedInput
    HistorialRecompensas?: HistorialRecompensasUncheckedUpdateManyWithoutUsuariosNestedInput
    Horarios?: HorariosUncheckedUpdateManyWithoutUsuariosNestedInput
    PuntosClientes?: PuntosClientesUncheckedUpdateManyWithoutUsuariosNestedInput
  }

  export type UsuariosCreateWithoutHistorialRecompensasInput = {
    nombre: string
    apellidos: string
    telefono?: string | null
    correo: string
    direccion?: string | null
    contra: string
    estado?: string | null
    ActividadCliente?: ActividadClienteCreateNestedManyWithoutUsuariosInput
    BitacoraCliente?: BitacoraClienteCreateNestedManyWithoutUsuariosInput
    BitacoraEstilista?: BitacoraEstilistaCreateNestedManyWithoutUsuariosInput
    BloqueoHorarios?: BloqueoHorariosCreateNestedManyWithoutUsuariosInput
    Citas_Citas_clienteIDToUsuarios?: CitasCreateNestedManyWithoutUsuarios_Citas_clienteIDToUsuariosInput
    Citas_Citas_estilistaIDToUsuarios?: CitasCreateNestedManyWithoutUsuarios_Citas_estilistaIDToUsuariosInput
    HistorialCitas?: HistorialCitasCreateNestedManyWithoutUsuariosInput
    Horarios?: HorariosCreateNestedManyWithoutUsuariosInput
    PuntosClientes?: PuntosClientesCreateNestedManyWithoutUsuariosInput
    Roles?: RolesCreateNestedOneWithoutUsuariosInput
  }

  export type UsuariosUncheckedCreateWithoutHistorialRecompensasInput = {
    usuarioID?: number
    nombre: string
    apellidos: string
    telefono?: string | null
    correo: string
    direccion?: string | null
    contra: string
    rolID?: number | null
    estado?: string | null
    ActividadCliente?: ActividadClienteUncheckedCreateNestedManyWithoutUsuariosInput
    BitacoraCliente?: BitacoraClienteUncheckedCreateNestedManyWithoutUsuariosInput
    BitacoraEstilista?: BitacoraEstilistaUncheckedCreateNestedManyWithoutUsuariosInput
    BloqueoHorarios?: BloqueoHorariosUncheckedCreateNestedManyWithoutUsuariosInput
    Citas_Citas_clienteIDToUsuarios?: CitasUncheckedCreateNestedManyWithoutUsuarios_Citas_clienteIDToUsuariosInput
    Citas_Citas_estilistaIDToUsuarios?: CitasUncheckedCreateNestedManyWithoutUsuarios_Citas_estilistaIDToUsuariosInput
    HistorialCitas?: HistorialCitasUncheckedCreateNestedManyWithoutUsuariosInput
    Horarios?: HorariosUncheckedCreateNestedManyWithoutUsuariosInput
    PuntosClientes?: PuntosClientesUncheckedCreateNestedManyWithoutUsuariosInput
  }

  export type UsuariosCreateOrConnectWithoutHistorialRecompensasInput = {
    where: UsuariosWhereUniqueInput
    create: XOR<UsuariosCreateWithoutHistorialRecompensasInput, UsuariosUncheckedCreateWithoutHistorialRecompensasInput>
  }

  export type ServiciosCreateWithoutHistorialRecompensasInput = {
    nombreServicio?: string | null
    descripcion?: string | null
    tiempoEstimado?: Date | string | null
    precio?: number | null
    rutaImagen?: string | null
    DetallesCita?: DetallesCitaCreateNestedManyWithoutServiciosInput
    PuntosServicio?: PuntosServicioCreateNestedOneWithoutServiciosInput
  }

  export type ServiciosUncheckedCreateWithoutHistorialRecompensasInput = {
    servicioID?: number
    nombreServicio?: string | null
    descripcion?: string | null
    tiempoEstimado?: Date | string | null
    precio?: number | null
    rutaImagen?: string | null
    DetallesCita?: DetallesCitaUncheckedCreateNestedManyWithoutServiciosInput
    PuntosServicio?: PuntosServicioUncheckedCreateNestedOneWithoutServiciosInput
  }

  export type ServiciosCreateOrConnectWithoutHistorialRecompensasInput = {
    where: ServiciosWhereUniqueInput
    create: XOR<ServiciosCreateWithoutHistorialRecompensasInput, ServiciosUncheckedCreateWithoutHistorialRecompensasInput>
  }

  export type UsuariosUpsertWithoutHistorialRecompensasInput = {
    update: XOR<UsuariosUpdateWithoutHistorialRecompensasInput, UsuariosUncheckedUpdateWithoutHistorialRecompensasInput>
    create: XOR<UsuariosCreateWithoutHistorialRecompensasInput, UsuariosUncheckedCreateWithoutHistorialRecompensasInput>
    where?: UsuariosWhereInput
  }

  export type UsuariosUpdateToOneWithWhereWithoutHistorialRecompensasInput = {
    where?: UsuariosWhereInput
    data: XOR<UsuariosUpdateWithoutHistorialRecompensasInput, UsuariosUncheckedUpdateWithoutHistorialRecompensasInput>
  }

  export type UsuariosUpdateWithoutHistorialRecompensasInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    contra?: StringFieldUpdateOperationsInput | string
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    ActividadCliente?: ActividadClienteUpdateManyWithoutUsuariosNestedInput
    BitacoraCliente?: BitacoraClienteUpdateManyWithoutUsuariosNestedInput
    BitacoraEstilista?: BitacoraEstilistaUpdateManyWithoutUsuariosNestedInput
    BloqueoHorarios?: BloqueoHorariosUpdateManyWithoutUsuariosNestedInput
    Citas_Citas_clienteIDToUsuarios?: CitasUpdateManyWithoutUsuarios_Citas_clienteIDToUsuariosNestedInput
    Citas_Citas_estilistaIDToUsuarios?: CitasUpdateManyWithoutUsuarios_Citas_estilistaIDToUsuariosNestedInput
    HistorialCitas?: HistorialCitasUpdateManyWithoutUsuariosNestedInput
    Horarios?: HorariosUpdateManyWithoutUsuariosNestedInput
    PuntosClientes?: PuntosClientesUpdateManyWithoutUsuariosNestedInput
    Roles?: RolesUpdateOneWithoutUsuariosNestedInput
  }

  export type UsuariosUncheckedUpdateWithoutHistorialRecompensasInput = {
    usuarioID?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    contra?: StringFieldUpdateOperationsInput | string
    rolID?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    ActividadCliente?: ActividadClienteUncheckedUpdateManyWithoutUsuariosNestedInput
    BitacoraCliente?: BitacoraClienteUncheckedUpdateManyWithoutUsuariosNestedInput
    BitacoraEstilista?: BitacoraEstilistaUncheckedUpdateManyWithoutUsuariosNestedInput
    BloqueoHorarios?: BloqueoHorariosUncheckedUpdateManyWithoutUsuariosNestedInput
    Citas_Citas_clienteIDToUsuarios?: CitasUncheckedUpdateManyWithoutUsuarios_Citas_clienteIDToUsuariosNestedInput
    Citas_Citas_estilistaIDToUsuarios?: CitasUncheckedUpdateManyWithoutUsuarios_Citas_estilistaIDToUsuariosNestedInput
    HistorialCitas?: HistorialCitasUncheckedUpdateManyWithoutUsuariosNestedInput
    Horarios?: HorariosUncheckedUpdateManyWithoutUsuariosNestedInput
    PuntosClientes?: PuntosClientesUncheckedUpdateManyWithoutUsuariosNestedInput
  }

  export type ServiciosUpsertWithoutHistorialRecompensasInput = {
    update: XOR<ServiciosUpdateWithoutHistorialRecompensasInput, ServiciosUncheckedUpdateWithoutHistorialRecompensasInput>
    create: XOR<ServiciosCreateWithoutHistorialRecompensasInput, ServiciosUncheckedCreateWithoutHistorialRecompensasInput>
    where?: ServiciosWhereInput
  }

  export type ServiciosUpdateToOneWithWhereWithoutHistorialRecompensasInput = {
    where?: ServiciosWhereInput
    data: XOR<ServiciosUpdateWithoutHistorialRecompensasInput, ServiciosUncheckedUpdateWithoutHistorialRecompensasInput>
  }

  export type ServiciosUpdateWithoutHistorialRecompensasInput = {
    nombreServicio?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    tiempoEstimado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    precio?: NullableIntFieldUpdateOperationsInput | number | null
    rutaImagen?: NullableStringFieldUpdateOperationsInput | string | null
    DetallesCita?: DetallesCitaUpdateManyWithoutServiciosNestedInput
    PuntosServicio?: PuntosServicioUpdateOneWithoutServiciosNestedInput
  }

  export type ServiciosUncheckedUpdateWithoutHistorialRecompensasInput = {
    servicioID?: IntFieldUpdateOperationsInput | number
    nombreServicio?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    tiempoEstimado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    precio?: NullableIntFieldUpdateOperationsInput | number | null
    rutaImagen?: NullableStringFieldUpdateOperationsInput | string | null
    DetallesCita?: DetallesCitaUncheckedUpdateManyWithoutServiciosNestedInput
    PuntosServicio?: PuntosServicioUncheckedUpdateOneWithoutServiciosNestedInput
  }

  export type UsuariosCreateWithoutHorariosInput = {
    nombre: string
    apellidos: string
    telefono?: string | null
    correo: string
    direccion?: string | null
    contra: string
    estado?: string | null
    ActividadCliente?: ActividadClienteCreateNestedManyWithoutUsuariosInput
    BitacoraCliente?: BitacoraClienteCreateNestedManyWithoutUsuariosInput
    BitacoraEstilista?: BitacoraEstilistaCreateNestedManyWithoutUsuariosInput
    BloqueoHorarios?: BloqueoHorariosCreateNestedManyWithoutUsuariosInput
    Citas_Citas_clienteIDToUsuarios?: CitasCreateNestedManyWithoutUsuarios_Citas_clienteIDToUsuariosInput
    Citas_Citas_estilistaIDToUsuarios?: CitasCreateNestedManyWithoutUsuarios_Citas_estilistaIDToUsuariosInput
    HistorialCitas?: HistorialCitasCreateNestedManyWithoutUsuariosInput
    HistorialRecompensas?: HistorialRecompensasCreateNestedManyWithoutUsuariosInput
    PuntosClientes?: PuntosClientesCreateNestedManyWithoutUsuariosInput
    Roles?: RolesCreateNestedOneWithoutUsuariosInput
  }

  export type UsuariosUncheckedCreateWithoutHorariosInput = {
    usuarioID?: number
    nombre: string
    apellidos: string
    telefono?: string | null
    correo: string
    direccion?: string | null
    contra: string
    rolID?: number | null
    estado?: string | null
    ActividadCliente?: ActividadClienteUncheckedCreateNestedManyWithoutUsuariosInput
    BitacoraCliente?: BitacoraClienteUncheckedCreateNestedManyWithoutUsuariosInput
    BitacoraEstilista?: BitacoraEstilistaUncheckedCreateNestedManyWithoutUsuariosInput
    BloqueoHorarios?: BloqueoHorariosUncheckedCreateNestedManyWithoutUsuariosInput
    Citas_Citas_clienteIDToUsuarios?: CitasUncheckedCreateNestedManyWithoutUsuarios_Citas_clienteIDToUsuariosInput
    Citas_Citas_estilistaIDToUsuarios?: CitasUncheckedCreateNestedManyWithoutUsuarios_Citas_estilistaIDToUsuariosInput
    HistorialCitas?: HistorialCitasUncheckedCreateNestedManyWithoutUsuariosInput
    HistorialRecompensas?: HistorialRecompensasUncheckedCreateNestedManyWithoutUsuariosInput
    PuntosClientes?: PuntosClientesUncheckedCreateNestedManyWithoutUsuariosInput
  }

  export type UsuariosCreateOrConnectWithoutHorariosInput = {
    where: UsuariosWhereUniqueInput
    create: XOR<UsuariosCreateWithoutHorariosInput, UsuariosUncheckedCreateWithoutHorariosInput>
  }

  export type UsuariosUpsertWithoutHorariosInput = {
    update: XOR<UsuariosUpdateWithoutHorariosInput, UsuariosUncheckedUpdateWithoutHorariosInput>
    create: XOR<UsuariosCreateWithoutHorariosInput, UsuariosUncheckedCreateWithoutHorariosInput>
    where?: UsuariosWhereInput
  }

  export type UsuariosUpdateToOneWithWhereWithoutHorariosInput = {
    where?: UsuariosWhereInput
    data: XOR<UsuariosUpdateWithoutHorariosInput, UsuariosUncheckedUpdateWithoutHorariosInput>
  }

  export type UsuariosUpdateWithoutHorariosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    contra?: StringFieldUpdateOperationsInput | string
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    ActividadCliente?: ActividadClienteUpdateManyWithoutUsuariosNestedInput
    BitacoraCliente?: BitacoraClienteUpdateManyWithoutUsuariosNestedInput
    BitacoraEstilista?: BitacoraEstilistaUpdateManyWithoutUsuariosNestedInput
    BloqueoHorarios?: BloqueoHorariosUpdateManyWithoutUsuariosNestedInput
    Citas_Citas_clienteIDToUsuarios?: CitasUpdateManyWithoutUsuarios_Citas_clienteIDToUsuariosNestedInput
    Citas_Citas_estilistaIDToUsuarios?: CitasUpdateManyWithoutUsuarios_Citas_estilistaIDToUsuariosNestedInput
    HistorialCitas?: HistorialCitasUpdateManyWithoutUsuariosNestedInput
    HistorialRecompensas?: HistorialRecompensasUpdateManyWithoutUsuariosNestedInput
    PuntosClientes?: PuntosClientesUpdateManyWithoutUsuariosNestedInput
    Roles?: RolesUpdateOneWithoutUsuariosNestedInput
  }

  export type UsuariosUncheckedUpdateWithoutHorariosInput = {
    usuarioID?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    contra?: StringFieldUpdateOperationsInput | string
    rolID?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    ActividadCliente?: ActividadClienteUncheckedUpdateManyWithoutUsuariosNestedInput
    BitacoraCliente?: BitacoraClienteUncheckedUpdateManyWithoutUsuariosNestedInput
    BitacoraEstilista?: BitacoraEstilistaUncheckedUpdateManyWithoutUsuariosNestedInput
    BloqueoHorarios?: BloqueoHorariosUncheckedUpdateManyWithoutUsuariosNestedInput
    Citas_Citas_clienteIDToUsuarios?: CitasUncheckedUpdateManyWithoutUsuarios_Citas_clienteIDToUsuariosNestedInput
    Citas_Citas_estilistaIDToUsuarios?: CitasUncheckedUpdateManyWithoutUsuarios_Citas_estilistaIDToUsuariosNestedInput
    HistorialCitas?: HistorialCitasUncheckedUpdateManyWithoutUsuariosNestedInput
    HistorialRecompensas?: HistorialRecompensasUncheckedUpdateManyWithoutUsuariosNestedInput
    PuntosClientes?: PuntosClientesUncheckedUpdateManyWithoutUsuariosNestedInput
  }

  export type CitasCreateWithoutHorariosReservadosInput = {
    comentarios?: string | null
    ActividadCliente?: ActividadClienteCreateNestedManyWithoutCitasInput
    Usuarios_Citas_clienteIDToUsuarios?: UsuariosCreateNestedOneWithoutCitas_Citas_clienteIDToUsuariosInput
    EstadoCita?: EstadoCitaCreateNestedOneWithoutCitasInput
    Usuarios_Citas_estilistaIDToUsuarios?: UsuariosCreateNestedOneWithoutCitas_Citas_estilistaIDToUsuariosInput
    DetallesCita?: DetallesCitaCreateNestedManyWithoutCitasInput
    HistorialCitas?: HistorialCitasCreateNestedManyWithoutCitasInput
  }

  export type CitasUncheckedCreateWithoutHorariosReservadosInput = {
    citaID?: number
    clienteID?: number | null
    estilistaID?: number | null
    comentarios?: string | null
    estadoID?: number | null
    ActividadCliente?: ActividadClienteUncheckedCreateNestedManyWithoutCitasInput
    DetallesCita?: DetallesCitaUncheckedCreateNestedManyWithoutCitasInput
    HistorialCitas?: HistorialCitasUncheckedCreateNestedManyWithoutCitasInput
  }

  export type CitasCreateOrConnectWithoutHorariosReservadosInput = {
    where: CitasWhereUniqueInput
    create: XOR<CitasCreateWithoutHorariosReservadosInput, CitasUncheckedCreateWithoutHorariosReservadosInput>
  }

  export type CitasUpsertWithoutHorariosReservadosInput = {
    update: XOR<CitasUpdateWithoutHorariosReservadosInput, CitasUncheckedUpdateWithoutHorariosReservadosInput>
    create: XOR<CitasCreateWithoutHorariosReservadosInput, CitasUncheckedCreateWithoutHorariosReservadosInput>
    where?: CitasWhereInput
  }

  export type CitasUpdateToOneWithWhereWithoutHorariosReservadosInput = {
    where?: CitasWhereInput
    data: XOR<CitasUpdateWithoutHorariosReservadosInput, CitasUncheckedUpdateWithoutHorariosReservadosInput>
  }

  export type CitasUpdateWithoutHorariosReservadosInput = {
    comentarios?: NullableStringFieldUpdateOperationsInput | string | null
    ActividadCliente?: ActividadClienteUpdateManyWithoutCitasNestedInput
    Usuarios_Citas_clienteIDToUsuarios?: UsuariosUpdateOneWithoutCitas_Citas_clienteIDToUsuariosNestedInput
    EstadoCita?: EstadoCitaUpdateOneWithoutCitasNestedInput
    Usuarios_Citas_estilistaIDToUsuarios?: UsuariosUpdateOneWithoutCitas_Citas_estilistaIDToUsuariosNestedInput
    DetallesCita?: DetallesCitaUpdateManyWithoutCitasNestedInput
    HistorialCitas?: HistorialCitasUpdateManyWithoutCitasNestedInput
  }

  export type CitasUncheckedUpdateWithoutHorariosReservadosInput = {
    citaID?: IntFieldUpdateOperationsInput | number
    clienteID?: NullableIntFieldUpdateOperationsInput | number | null
    estilistaID?: NullableIntFieldUpdateOperationsInput | number | null
    comentarios?: NullableStringFieldUpdateOperationsInput | string | null
    estadoID?: NullableIntFieldUpdateOperationsInput | number | null
    ActividadCliente?: ActividadClienteUncheckedUpdateManyWithoutCitasNestedInput
    DetallesCita?: DetallesCitaUncheckedUpdateManyWithoutCitasNestedInput
    HistorialCitas?: HistorialCitasUncheckedUpdateManyWithoutCitasNestedInput
  }

  export type UsuariosCreateWithoutPuntosClientesInput = {
    nombre: string
    apellidos: string
    telefono?: string | null
    correo: string
    direccion?: string | null
    contra: string
    estado?: string | null
    ActividadCliente?: ActividadClienteCreateNestedManyWithoutUsuariosInput
    BitacoraCliente?: BitacoraClienteCreateNestedManyWithoutUsuariosInput
    BitacoraEstilista?: BitacoraEstilistaCreateNestedManyWithoutUsuariosInput
    BloqueoHorarios?: BloqueoHorariosCreateNestedManyWithoutUsuariosInput
    Citas_Citas_clienteIDToUsuarios?: CitasCreateNestedManyWithoutUsuarios_Citas_clienteIDToUsuariosInput
    Citas_Citas_estilistaIDToUsuarios?: CitasCreateNestedManyWithoutUsuarios_Citas_estilistaIDToUsuariosInput
    HistorialCitas?: HistorialCitasCreateNestedManyWithoutUsuariosInput
    HistorialRecompensas?: HistorialRecompensasCreateNestedManyWithoutUsuariosInput
    Horarios?: HorariosCreateNestedManyWithoutUsuariosInput
    Roles?: RolesCreateNestedOneWithoutUsuariosInput
  }

  export type UsuariosUncheckedCreateWithoutPuntosClientesInput = {
    usuarioID?: number
    nombre: string
    apellidos: string
    telefono?: string | null
    correo: string
    direccion?: string | null
    contra: string
    rolID?: number | null
    estado?: string | null
    ActividadCliente?: ActividadClienteUncheckedCreateNestedManyWithoutUsuariosInput
    BitacoraCliente?: BitacoraClienteUncheckedCreateNestedManyWithoutUsuariosInput
    BitacoraEstilista?: BitacoraEstilistaUncheckedCreateNestedManyWithoutUsuariosInput
    BloqueoHorarios?: BloqueoHorariosUncheckedCreateNestedManyWithoutUsuariosInput
    Citas_Citas_clienteIDToUsuarios?: CitasUncheckedCreateNestedManyWithoutUsuarios_Citas_clienteIDToUsuariosInput
    Citas_Citas_estilistaIDToUsuarios?: CitasUncheckedCreateNestedManyWithoutUsuarios_Citas_estilistaIDToUsuariosInput
    HistorialCitas?: HistorialCitasUncheckedCreateNestedManyWithoutUsuariosInput
    HistorialRecompensas?: HistorialRecompensasUncheckedCreateNestedManyWithoutUsuariosInput
    Horarios?: HorariosUncheckedCreateNestedManyWithoutUsuariosInput
  }

  export type UsuariosCreateOrConnectWithoutPuntosClientesInput = {
    where: UsuariosWhereUniqueInput
    create: XOR<UsuariosCreateWithoutPuntosClientesInput, UsuariosUncheckedCreateWithoutPuntosClientesInput>
  }

  export type UsuariosUpsertWithoutPuntosClientesInput = {
    update: XOR<UsuariosUpdateWithoutPuntosClientesInput, UsuariosUncheckedUpdateWithoutPuntosClientesInput>
    create: XOR<UsuariosCreateWithoutPuntosClientesInput, UsuariosUncheckedCreateWithoutPuntosClientesInput>
    where?: UsuariosWhereInput
  }

  export type UsuariosUpdateToOneWithWhereWithoutPuntosClientesInput = {
    where?: UsuariosWhereInput
    data: XOR<UsuariosUpdateWithoutPuntosClientesInput, UsuariosUncheckedUpdateWithoutPuntosClientesInput>
  }

  export type UsuariosUpdateWithoutPuntosClientesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    contra?: StringFieldUpdateOperationsInput | string
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    ActividadCliente?: ActividadClienteUpdateManyWithoutUsuariosNestedInput
    BitacoraCliente?: BitacoraClienteUpdateManyWithoutUsuariosNestedInput
    BitacoraEstilista?: BitacoraEstilistaUpdateManyWithoutUsuariosNestedInput
    BloqueoHorarios?: BloqueoHorariosUpdateManyWithoutUsuariosNestedInput
    Citas_Citas_clienteIDToUsuarios?: CitasUpdateManyWithoutUsuarios_Citas_clienteIDToUsuariosNestedInput
    Citas_Citas_estilistaIDToUsuarios?: CitasUpdateManyWithoutUsuarios_Citas_estilistaIDToUsuariosNestedInput
    HistorialCitas?: HistorialCitasUpdateManyWithoutUsuariosNestedInput
    HistorialRecompensas?: HistorialRecompensasUpdateManyWithoutUsuariosNestedInput
    Horarios?: HorariosUpdateManyWithoutUsuariosNestedInput
    Roles?: RolesUpdateOneWithoutUsuariosNestedInput
  }

  export type UsuariosUncheckedUpdateWithoutPuntosClientesInput = {
    usuarioID?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    contra?: StringFieldUpdateOperationsInput | string
    rolID?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    ActividadCliente?: ActividadClienteUncheckedUpdateManyWithoutUsuariosNestedInput
    BitacoraCliente?: BitacoraClienteUncheckedUpdateManyWithoutUsuariosNestedInput
    BitacoraEstilista?: BitacoraEstilistaUncheckedUpdateManyWithoutUsuariosNestedInput
    BloqueoHorarios?: BloqueoHorariosUncheckedUpdateManyWithoutUsuariosNestedInput
    Citas_Citas_clienteIDToUsuarios?: CitasUncheckedUpdateManyWithoutUsuarios_Citas_clienteIDToUsuariosNestedInput
    Citas_Citas_estilistaIDToUsuarios?: CitasUncheckedUpdateManyWithoutUsuarios_Citas_estilistaIDToUsuariosNestedInput
    HistorialCitas?: HistorialCitasUncheckedUpdateManyWithoutUsuariosNestedInput
    HistorialRecompensas?: HistorialRecompensasUncheckedUpdateManyWithoutUsuariosNestedInput
    Horarios?: HorariosUncheckedUpdateManyWithoutUsuariosNestedInput
  }

  export type ServiciosCreateWithoutPuntosServicioInput = {
    nombreServicio?: string | null
    descripcion?: string | null
    tiempoEstimado?: Date | string | null
    precio?: number | null
    rutaImagen?: string | null
    DetallesCita?: DetallesCitaCreateNestedManyWithoutServiciosInput
    HistorialRecompensas?: HistorialRecompensasCreateNestedManyWithoutServiciosInput
  }

  export type ServiciosUncheckedCreateWithoutPuntosServicioInput = {
    servicioID?: number
    nombreServicio?: string | null
    descripcion?: string | null
    tiempoEstimado?: Date | string | null
    precio?: number | null
    rutaImagen?: string | null
    DetallesCita?: DetallesCitaUncheckedCreateNestedManyWithoutServiciosInput
    HistorialRecompensas?: HistorialRecompensasUncheckedCreateNestedManyWithoutServiciosInput
  }

  export type ServiciosCreateOrConnectWithoutPuntosServicioInput = {
    where: ServiciosWhereUniqueInput
    create: XOR<ServiciosCreateWithoutPuntosServicioInput, ServiciosUncheckedCreateWithoutPuntosServicioInput>
  }

  export type ServiciosUpsertWithoutPuntosServicioInput = {
    update: XOR<ServiciosUpdateWithoutPuntosServicioInput, ServiciosUncheckedUpdateWithoutPuntosServicioInput>
    create: XOR<ServiciosCreateWithoutPuntosServicioInput, ServiciosUncheckedCreateWithoutPuntosServicioInput>
    where?: ServiciosWhereInput
  }

  export type ServiciosUpdateToOneWithWhereWithoutPuntosServicioInput = {
    where?: ServiciosWhereInput
    data: XOR<ServiciosUpdateWithoutPuntosServicioInput, ServiciosUncheckedUpdateWithoutPuntosServicioInput>
  }

  export type ServiciosUpdateWithoutPuntosServicioInput = {
    nombreServicio?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    tiempoEstimado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    precio?: NullableIntFieldUpdateOperationsInput | number | null
    rutaImagen?: NullableStringFieldUpdateOperationsInput | string | null
    DetallesCita?: DetallesCitaUpdateManyWithoutServiciosNestedInput
    HistorialRecompensas?: HistorialRecompensasUpdateManyWithoutServiciosNestedInput
  }

  export type ServiciosUncheckedUpdateWithoutPuntosServicioInput = {
    servicioID?: IntFieldUpdateOperationsInput | number
    nombreServicio?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    tiempoEstimado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    precio?: NullableIntFieldUpdateOperationsInput | number | null
    rutaImagen?: NullableStringFieldUpdateOperationsInput | string | null
    DetallesCita?: DetallesCitaUncheckedUpdateManyWithoutServiciosNestedInput
    HistorialRecompensas?: HistorialRecompensasUncheckedUpdateManyWithoutServiciosNestedInput
  }

  export type UsuariosCreateWithoutRolesInput = {
    nombre: string
    apellidos: string
    telefono?: string | null
    correo: string
    direccion?: string | null
    contra: string
    estado?: string | null
    ActividadCliente?: ActividadClienteCreateNestedManyWithoutUsuariosInput
    BitacoraCliente?: BitacoraClienteCreateNestedManyWithoutUsuariosInput
    BitacoraEstilista?: BitacoraEstilistaCreateNestedManyWithoutUsuariosInput
    BloqueoHorarios?: BloqueoHorariosCreateNestedManyWithoutUsuariosInput
    Citas_Citas_clienteIDToUsuarios?: CitasCreateNestedManyWithoutUsuarios_Citas_clienteIDToUsuariosInput
    Citas_Citas_estilistaIDToUsuarios?: CitasCreateNestedManyWithoutUsuarios_Citas_estilistaIDToUsuariosInput
    HistorialCitas?: HistorialCitasCreateNestedManyWithoutUsuariosInput
    HistorialRecompensas?: HistorialRecompensasCreateNestedManyWithoutUsuariosInput
    Horarios?: HorariosCreateNestedManyWithoutUsuariosInput
    PuntosClientes?: PuntosClientesCreateNestedManyWithoutUsuariosInput
  }

  export type UsuariosUncheckedCreateWithoutRolesInput = {
    usuarioID?: number
    nombre: string
    apellidos: string
    telefono?: string | null
    correo: string
    direccion?: string | null
    contra: string
    estado?: string | null
    ActividadCliente?: ActividadClienteUncheckedCreateNestedManyWithoutUsuariosInput
    BitacoraCliente?: BitacoraClienteUncheckedCreateNestedManyWithoutUsuariosInput
    BitacoraEstilista?: BitacoraEstilistaUncheckedCreateNestedManyWithoutUsuariosInput
    BloqueoHorarios?: BloqueoHorariosUncheckedCreateNestedManyWithoutUsuariosInput
    Citas_Citas_clienteIDToUsuarios?: CitasUncheckedCreateNestedManyWithoutUsuarios_Citas_clienteIDToUsuariosInput
    Citas_Citas_estilistaIDToUsuarios?: CitasUncheckedCreateNestedManyWithoutUsuarios_Citas_estilistaIDToUsuariosInput
    HistorialCitas?: HistorialCitasUncheckedCreateNestedManyWithoutUsuariosInput
    HistorialRecompensas?: HistorialRecompensasUncheckedCreateNestedManyWithoutUsuariosInput
    Horarios?: HorariosUncheckedCreateNestedManyWithoutUsuariosInput
    PuntosClientes?: PuntosClientesUncheckedCreateNestedManyWithoutUsuariosInput
  }

  export type UsuariosCreateOrConnectWithoutRolesInput = {
    where: UsuariosWhereUniqueInput
    create: XOR<UsuariosCreateWithoutRolesInput, UsuariosUncheckedCreateWithoutRolesInput>
  }

  export type UsuariosCreateManyRolesInputEnvelope = {
    data: UsuariosCreateManyRolesInput | UsuariosCreateManyRolesInput[]
  }

  export type UsuariosUpsertWithWhereUniqueWithoutRolesInput = {
    where: UsuariosWhereUniqueInput
    update: XOR<UsuariosUpdateWithoutRolesInput, UsuariosUncheckedUpdateWithoutRolesInput>
    create: XOR<UsuariosCreateWithoutRolesInput, UsuariosUncheckedCreateWithoutRolesInput>
  }

  export type UsuariosUpdateWithWhereUniqueWithoutRolesInput = {
    where: UsuariosWhereUniqueInput
    data: XOR<UsuariosUpdateWithoutRolesInput, UsuariosUncheckedUpdateWithoutRolesInput>
  }

  export type UsuariosUpdateManyWithWhereWithoutRolesInput = {
    where: UsuariosScalarWhereInput
    data: XOR<UsuariosUpdateManyMutationInput, UsuariosUncheckedUpdateManyWithoutRolesInput>
  }

  export type UsuariosScalarWhereInput = {
    AND?: UsuariosScalarWhereInput | UsuariosScalarWhereInput[]
    OR?: UsuariosScalarWhereInput[]
    NOT?: UsuariosScalarWhereInput | UsuariosScalarWhereInput[]
    usuarioID?: IntFilter<"Usuarios"> | number
    nombre?: StringFilter<"Usuarios"> | string
    apellidos?: StringFilter<"Usuarios"> | string
    telefono?: StringNullableFilter<"Usuarios"> | string | null
    correo?: StringFilter<"Usuarios"> | string
    direccion?: StringNullableFilter<"Usuarios"> | string | null
    contra?: StringFilter<"Usuarios"> | string
    rolID?: IntNullableFilter<"Usuarios"> | number | null
    estado?: StringNullableFilter<"Usuarios"> | string | null
  }

  export type DetallesCitaCreateWithoutServiciosInput = {
    Citas?: CitasCreateNestedOneWithoutDetallesCitaInput
  }

  export type DetallesCitaUncheckedCreateWithoutServiciosInput = {
    detalleID?: number
    citaID?: number | null
  }

  export type DetallesCitaCreateOrConnectWithoutServiciosInput = {
    where: DetallesCitaWhereUniqueInput
    create: XOR<DetallesCitaCreateWithoutServiciosInput, DetallesCitaUncheckedCreateWithoutServiciosInput>
  }

  export type DetallesCitaCreateManyServiciosInputEnvelope = {
    data: DetallesCitaCreateManyServiciosInput | DetallesCitaCreateManyServiciosInput[]
  }

  export type HistorialRecompensasCreateWithoutServiciosInput = {
    puntosCanjeados?: number | null
    fecha?: Date | string | null
    Usuarios?: UsuariosCreateNestedOneWithoutHistorialRecompensasInput
  }

  export type HistorialRecompensasUncheckedCreateWithoutServiciosInput = {
    historialID?: number
    clienteID?: number | null
    puntosCanjeados?: number | null
    fecha?: Date | string | null
  }

  export type HistorialRecompensasCreateOrConnectWithoutServiciosInput = {
    where: HistorialRecompensasWhereUniqueInput
    create: XOR<HistorialRecompensasCreateWithoutServiciosInput, HistorialRecompensasUncheckedCreateWithoutServiciosInput>
  }

  export type HistorialRecompensasCreateManyServiciosInputEnvelope = {
    data: HistorialRecompensasCreateManyServiciosInput | HistorialRecompensasCreateManyServiciosInput[]
  }

  export type PuntosServicioCreateWithoutServiciosInput = {
    puntosGenerados?: number | null
  }

  export type PuntosServicioUncheckedCreateWithoutServiciosInput = {
    puntosGenerados?: number | null
  }

  export type PuntosServicioCreateOrConnectWithoutServiciosInput = {
    where: PuntosServicioWhereUniqueInput
    create: XOR<PuntosServicioCreateWithoutServiciosInput, PuntosServicioUncheckedCreateWithoutServiciosInput>
  }

  export type DetallesCitaUpsertWithWhereUniqueWithoutServiciosInput = {
    where: DetallesCitaWhereUniqueInput
    update: XOR<DetallesCitaUpdateWithoutServiciosInput, DetallesCitaUncheckedUpdateWithoutServiciosInput>
    create: XOR<DetallesCitaCreateWithoutServiciosInput, DetallesCitaUncheckedCreateWithoutServiciosInput>
  }

  export type DetallesCitaUpdateWithWhereUniqueWithoutServiciosInput = {
    where: DetallesCitaWhereUniqueInput
    data: XOR<DetallesCitaUpdateWithoutServiciosInput, DetallesCitaUncheckedUpdateWithoutServiciosInput>
  }

  export type DetallesCitaUpdateManyWithWhereWithoutServiciosInput = {
    where: DetallesCitaScalarWhereInput
    data: XOR<DetallesCitaUpdateManyMutationInput, DetallesCitaUncheckedUpdateManyWithoutServiciosInput>
  }

  export type HistorialRecompensasUpsertWithWhereUniqueWithoutServiciosInput = {
    where: HistorialRecompensasWhereUniqueInput
    update: XOR<HistorialRecompensasUpdateWithoutServiciosInput, HistorialRecompensasUncheckedUpdateWithoutServiciosInput>
    create: XOR<HistorialRecompensasCreateWithoutServiciosInput, HistorialRecompensasUncheckedCreateWithoutServiciosInput>
  }

  export type HistorialRecompensasUpdateWithWhereUniqueWithoutServiciosInput = {
    where: HistorialRecompensasWhereUniqueInput
    data: XOR<HistorialRecompensasUpdateWithoutServiciosInput, HistorialRecompensasUncheckedUpdateWithoutServiciosInput>
  }

  export type HistorialRecompensasUpdateManyWithWhereWithoutServiciosInput = {
    where: HistorialRecompensasScalarWhereInput
    data: XOR<HistorialRecompensasUpdateManyMutationInput, HistorialRecompensasUncheckedUpdateManyWithoutServiciosInput>
  }

  export type HistorialRecompensasScalarWhereInput = {
    AND?: HistorialRecompensasScalarWhereInput | HistorialRecompensasScalarWhereInput[]
    OR?: HistorialRecompensasScalarWhereInput[]
    NOT?: HistorialRecompensasScalarWhereInput | HistorialRecompensasScalarWhereInput[]
    historialID?: IntFilter<"HistorialRecompensas"> | number
    clienteID?: IntNullableFilter<"HistorialRecompensas"> | number | null
    servicioID?: IntNullableFilter<"HistorialRecompensas"> | number | null
    puntosCanjeados?: IntNullableFilter<"HistorialRecompensas"> | number | null
    fecha?: DateTimeNullableFilter<"HistorialRecompensas"> | Date | string | null
  }

  export type PuntosServicioUpsertWithoutServiciosInput = {
    update: XOR<PuntosServicioUpdateWithoutServiciosInput, PuntosServicioUncheckedUpdateWithoutServiciosInput>
    create: XOR<PuntosServicioCreateWithoutServiciosInput, PuntosServicioUncheckedCreateWithoutServiciosInput>
    where?: PuntosServicioWhereInput
  }

  export type PuntosServicioUpdateToOneWithWhereWithoutServiciosInput = {
    where?: PuntosServicioWhereInput
    data: XOR<PuntosServicioUpdateWithoutServiciosInput, PuntosServicioUncheckedUpdateWithoutServiciosInput>
  }

  export type PuntosServicioUpdateWithoutServiciosInput = {
    puntosGenerados?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PuntosServicioUncheckedUpdateWithoutServiciosInput = {
    puntosGenerados?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ActividadClienteCreateWithoutUsuariosInput = {
    ultimaConexion?: Date | string | null
    Citas?: CitasCreateNestedOneWithoutActividadClienteInput
  }

  export type ActividadClienteUncheckedCreateWithoutUsuariosInput = {
    actividadID?: number
    ultimaConexion?: Date | string | null
    ultimaCitaID?: number | null
  }

  export type ActividadClienteCreateOrConnectWithoutUsuariosInput = {
    where: ActividadClienteWhereUniqueInput
    create: XOR<ActividadClienteCreateWithoutUsuariosInput, ActividadClienteUncheckedCreateWithoutUsuariosInput>
  }

  export type ActividadClienteCreateManyUsuariosInputEnvelope = {
    data: ActividadClienteCreateManyUsuariosInput | ActividadClienteCreateManyUsuariosInput[]
  }

  export type BitacoraClienteCreateWithoutUsuariosInput = {
    fechaRegistro?: Date | string | null
  }

  export type BitacoraClienteUncheckedCreateWithoutUsuariosInput = {
    bitacoraID?: number
    fechaRegistro?: Date | string | null
  }

  export type BitacoraClienteCreateOrConnectWithoutUsuariosInput = {
    where: BitacoraClienteWhereUniqueInput
    create: XOR<BitacoraClienteCreateWithoutUsuariosInput, BitacoraClienteUncheckedCreateWithoutUsuariosInput>
  }

  export type BitacoraClienteCreateManyUsuariosInputEnvelope = {
    data: BitacoraClienteCreateManyUsuariosInput | BitacoraClienteCreateManyUsuariosInput[]
  }

  export type BitacoraEstilistaCreateWithoutUsuariosInput = {
    fechaIngreso?: Date | string | null
    fechaSalida?: Date | string | null
  }

  export type BitacoraEstilistaUncheckedCreateWithoutUsuariosInput = {
    bitacoraID?: number
    fechaIngreso?: Date | string | null
    fechaSalida?: Date | string | null
  }

  export type BitacoraEstilistaCreateOrConnectWithoutUsuariosInput = {
    where: BitacoraEstilistaWhereUniqueInput
    create: XOR<BitacoraEstilistaCreateWithoutUsuariosInput, BitacoraEstilistaUncheckedCreateWithoutUsuariosInput>
  }

  export type BitacoraEstilistaCreateManyUsuariosInputEnvelope = {
    data: BitacoraEstilistaCreateManyUsuariosInput | BitacoraEstilistaCreateManyUsuariosInput[]
  }

  export type BloqueoHorariosCreateWithoutUsuariosInput = {
    dia?: string | null
    horaInicio?: Date | string | null
    horaFinal?: Date | string | null
    motivo?: string | null
  }

  export type BloqueoHorariosUncheckedCreateWithoutUsuariosInput = {
    bloqueoID?: number
    dia?: string | null
    horaInicio?: Date | string | null
    horaFinal?: Date | string | null
    motivo?: string | null
  }

  export type BloqueoHorariosCreateOrConnectWithoutUsuariosInput = {
    where: BloqueoHorariosWhereUniqueInput
    create: XOR<BloqueoHorariosCreateWithoutUsuariosInput, BloqueoHorariosUncheckedCreateWithoutUsuariosInput>
  }

  export type BloqueoHorariosCreateManyUsuariosInputEnvelope = {
    data: BloqueoHorariosCreateManyUsuariosInput | BloqueoHorariosCreateManyUsuariosInput[]
  }

  export type CitasCreateWithoutUsuarios_Citas_clienteIDToUsuariosInput = {
    comentarios?: string | null
    ActividadCliente?: ActividadClienteCreateNestedManyWithoutCitasInput
    EstadoCita?: EstadoCitaCreateNestedOneWithoutCitasInput
    Usuarios_Citas_estilistaIDToUsuarios?: UsuariosCreateNestedOneWithoutCitas_Citas_estilistaIDToUsuariosInput
    DetallesCita?: DetallesCitaCreateNestedManyWithoutCitasInput
    HistorialCitas?: HistorialCitasCreateNestedManyWithoutCitasInput
    HorariosReservados?: HorariosReservadosCreateNestedOneWithoutCitasInput
  }

  export type CitasUncheckedCreateWithoutUsuarios_Citas_clienteIDToUsuariosInput = {
    citaID?: number
    estilistaID?: number | null
    comentarios?: string | null
    estadoID?: number | null
    ActividadCliente?: ActividadClienteUncheckedCreateNestedManyWithoutCitasInput
    DetallesCita?: DetallesCitaUncheckedCreateNestedManyWithoutCitasInput
    HistorialCitas?: HistorialCitasUncheckedCreateNestedManyWithoutCitasInput
    HorariosReservados?: HorariosReservadosUncheckedCreateNestedOneWithoutCitasInput
  }

  export type CitasCreateOrConnectWithoutUsuarios_Citas_clienteIDToUsuariosInput = {
    where: CitasWhereUniqueInput
    create: XOR<CitasCreateWithoutUsuarios_Citas_clienteIDToUsuariosInput, CitasUncheckedCreateWithoutUsuarios_Citas_clienteIDToUsuariosInput>
  }

  export type CitasCreateManyUsuarios_Citas_clienteIDToUsuariosInputEnvelope = {
    data: CitasCreateManyUsuarios_Citas_clienteIDToUsuariosInput | CitasCreateManyUsuarios_Citas_clienteIDToUsuariosInput[]
  }

  export type CitasCreateWithoutUsuarios_Citas_estilistaIDToUsuariosInput = {
    comentarios?: string | null
    ActividadCliente?: ActividadClienteCreateNestedManyWithoutCitasInput
    Usuarios_Citas_clienteIDToUsuarios?: UsuariosCreateNestedOneWithoutCitas_Citas_clienteIDToUsuariosInput
    EstadoCita?: EstadoCitaCreateNestedOneWithoutCitasInput
    DetallesCita?: DetallesCitaCreateNestedManyWithoutCitasInput
    HistorialCitas?: HistorialCitasCreateNestedManyWithoutCitasInput
    HorariosReservados?: HorariosReservadosCreateNestedOneWithoutCitasInput
  }

  export type CitasUncheckedCreateWithoutUsuarios_Citas_estilistaIDToUsuariosInput = {
    citaID?: number
    clienteID?: number | null
    comentarios?: string | null
    estadoID?: number | null
    ActividadCliente?: ActividadClienteUncheckedCreateNestedManyWithoutCitasInput
    DetallesCita?: DetallesCitaUncheckedCreateNestedManyWithoutCitasInput
    HistorialCitas?: HistorialCitasUncheckedCreateNestedManyWithoutCitasInput
    HorariosReservados?: HorariosReservadosUncheckedCreateNestedOneWithoutCitasInput
  }

  export type CitasCreateOrConnectWithoutUsuarios_Citas_estilistaIDToUsuariosInput = {
    where: CitasWhereUniqueInput
    create: XOR<CitasCreateWithoutUsuarios_Citas_estilistaIDToUsuariosInput, CitasUncheckedCreateWithoutUsuarios_Citas_estilistaIDToUsuariosInput>
  }

  export type CitasCreateManyUsuarios_Citas_estilistaIDToUsuariosInputEnvelope = {
    data: CitasCreateManyUsuarios_Citas_estilistaIDToUsuariosInput | CitasCreateManyUsuarios_Citas_estilistaIDToUsuariosInput[]
  }

  export type HistorialCitasCreateWithoutUsuariosInput = {
    Citas?: CitasCreateNestedOneWithoutHistorialCitasInput
  }

  export type HistorialCitasUncheckedCreateWithoutUsuariosInput = {
    historialCitasID?: number
    citaID?: number | null
  }

  export type HistorialCitasCreateOrConnectWithoutUsuariosInput = {
    where: HistorialCitasWhereUniqueInput
    create: XOR<HistorialCitasCreateWithoutUsuariosInput, HistorialCitasUncheckedCreateWithoutUsuariosInput>
  }

  export type HistorialCitasCreateManyUsuariosInputEnvelope = {
    data: HistorialCitasCreateManyUsuariosInput | HistorialCitasCreateManyUsuariosInput[]
  }

  export type HistorialRecompensasCreateWithoutUsuariosInput = {
    puntosCanjeados?: number | null
    fecha?: Date | string | null
    Servicios?: ServiciosCreateNestedOneWithoutHistorialRecompensasInput
  }

  export type HistorialRecompensasUncheckedCreateWithoutUsuariosInput = {
    historialID?: number
    servicioID?: number | null
    puntosCanjeados?: number | null
    fecha?: Date | string | null
  }

  export type HistorialRecompensasCreateOrConnectWithoutUsuariosInput = {
    where: HistorialRecompensasWhereUniqueInput
    create: XOR<HistorialRecompensasCreateWithoutUsuariosInput, HistorialRecompensasUncheckedCreateWithoutUsuariosInput>
  }

  export type HistorialRecompensasCreateManyUsuariosInputEnvelope = {
    data: HistorialRecompensasCreateManyUsuariosInput | HistorialRecompensasCreateManyUsuariosInput[]
  }

  export type HorariosCreateWithoutUsuariosInput = {
    diaSemana?: string | null
    horaInicio?: Date | string | null
    horaFinal?: Date | string | null
  }

  export type HorariosUncheckedCreateWithoutUsuariosInput = {
    horariosID?: number
    diaSemana?: string | null
    horaInicio?: Date | string | null
    horaFinal?: Date | string | null
  }

  export type HorariosCreateOrConnectWithoutUsuariosInput = {
    where: HorariosWhereUniqueInput
    create: XOR<HorariosCreateWithoutUsuariosInput, HorariosUncheckedCreateWithoutUsuariosInput>
  }

  export type HorariosCreateManyUsuariosInputEnvelope = {
    data: HorariosCreateManyUsuariosInput | HorariosCreateManyUsuariosInput[]
  }

  export type PuntosClientesCreateWithoutUsuariosInput = {
    puntosAcumulados?: number | null
    puntosCanjeados?: number | null
  }

  export type PuntosClientesUncheckedCreateWithoutUsuariosInput = {
    puntosID?: number
    puntosAcumulados?: number | null
    puntosCanjeados?: number | null
  }

  export type PuntosClientesCreateOrConnectWithoutUsuariosInput = {
    where: PuntosClientesWhereUniqueInput
    create: XOR<PuntosClientesCreateWithoutUsuariosInput, PuntosClientesUncheckedCreateWithoutUsuariosInput>
  }

  export type PuntosClientesCreateManyUsuariosInputEnvelope = {
    data: PuntosClientesCreateManyUsuariosInput | PuntosClientesCreateManyUsuariosInput[]
  }

  export type RolesCreateWithoutUsuariosInput = {
    nombreRol?: string | null
  }

  export type RolesUncheckedCreateWithoutUsuariosInput = {
    rolID?: number
    nombreRol?: string | null
  }

  export type RolesCreateOrConnectWithoutUsuariosInput = {
    where: RolesWhereUniqueInput
    create: XOR<RolesCreateWithoutUsuariosInput, RolesUncheckedCreateWithoutUsuariosInput>
  }

  export type ActividadClienteUpsertWithWhereUniqueWithoutUsuariosInput = {
    where: ActividadClienteWhereUniqueInput
    update: XOR<ActividadClienteUpdateWithoutUsuariosInput, ActividadClienteUncheckedUpdateWithoutUsuariosInput>
    create: XOR<ActividadClienteCreateWithoutUsuariosInput, ActividadClienteUncheckedCreateWithoutUsuariosInput>
  }

  export type ActividadClienteUpdateWithWhereUniqueWithoutUsuariosInput = {
    where: ActividadClienteWhereUniqueInput
    data: XOR<ActividadClienteUpdateWithoutUsuariosInput, ActividadClienteUncheckedUpdateWithoutUsuariosInput>
  }

  export type ActividadClienteUpdateManyWithWhereWithoutUsuariosInput = {
    where: ActividadClienteScalarWhereInput
    data: XOR<ActividadClienteUpdateManyMutationInput, ActividadClienteUncheckedUpdateManyWithoutUsuariosInput>
  }

  export type BitacoraClienteUpsertWithWhereUniqueWithoutUsuariosInput = {
    where: BitacoraClienteWhereUniqueInput
    update: XOR<BitacoraClienteUpdateWithoutUsuariosInput, BitacoraClienteUncheckedUpdateWithoutUsuariosInput>
    create: XOR<BitacoraClienteCreateWithoutUsuariosInput, BitacoraClienteUncheckedCreateWithoutUsuariosInput>
  }

  export type BitacoraClienteUpdateWithWhereUniqueWithoutUsuariosInput = {
    where: BitacoraClienteWhereUniqueInput
    data: XOR<BitacoraClienteUpdateWithoutUsuariosInput, BitacoraClienteUncheckedUpdateWithoutUsuariosInput>
  }

  export type BitacoraClienteUpdateManyWithWhereWithoutUsuariosInput = {
    where: BitacoraClienteScalarWhereInput
    data: XOR<BitacoraClienteUpdateManyMutationInput, BitacoraClienteUncheckedUpdateManyWithoutUsuariosInput>
  }

  export type BitacoraClienteScalarWhereInput = {
    AND?: BitacoraClienteScalarWhereInput | BitacoraClienteScalarWhereInput[]
    OR?: BitacoraClienteScalarWhereInput[]
    NOT?: BitacoraClienteScalarWhereInput | BitacoraClienteScalarWhereInput[]
    bitacoraID?: IntFilter<"BitacoraCliente"> | number
    clienteID?: IntNullableFilter<"BitacoraCliente"> | number | null
    fechaRegistro?: DateTimeNullableFilter<"BitacoraCliente"> | Date | string | null
  }

  export type BitacoraEstilistaUpsertWithWhereUniqueWithoutUsuariosInput = {
    where: BitacoraEstilistaWhereUniqueInput
    update: XOR<BitacoraEstilistaUpdateWithoutUsuariosInput, BitacoraEstilistaUncheckedUpdateWithoutUsuariosInput>
    create: XOR<BitacoraEstilistaCreateWithoutUsuariosInput, BitacoraEstilistaUncheckedCreateWithoutUsuariosInput>
  }

  export type BitacoraEstilistaUpdateWithWhereUniqueWithoutUsuariosInput = {
    where: BitacoraEstilistaWhereUniqueInput
    data: XOR<BitacoraEstilistaUpdateWithoutUsuariosInput, BitacoraEstilistaUncheckedUpdateWithoutUsuariosInput>
  }

  export type BitacoraEstilistaUpdateManyWithWhereWithoutUsuariosInput = {
    where: BitacoraEstilistaScalarWhereInput
    data: XOR<BitacoraEstilistaUpdateManyMutationInput, BitacoraEstilistaUncheckedUpdateManyWithoutUsuariosInput>
  }

  export type BitacoraEstilistaScalarWhereInput = {
    AND?: BitacoraEstilistaScalarWhereInput | BitacoraEstilistaScalarWhereInput[]
    OR?: BitacoraEstilistaScalarWhereInput[]
    NOT?: BitacoraEstilistaScalarWhereInput | BitacoraEstilistaScalarWhereInput[]
    bitacoraID?: IntFilter<"BitacoraEstilista"> | number
    estilistaID?: IntNullableFilter<"BitacoraEstilista"> | number | null
    fechaIngreso?: DateTimeNullableFilter<"BitacoraEstilista"> | Date | string | null
    fechaSalida?: DateTimeNullableFilter<"BitacoraEstilista"> | Date | string | null
  }

  export type BloqueoHorariosUpsertWithWhereUniqueWithoutUsuariosInput = {
    where: BloqueoHorariosWhereUniqueInput
    update: XOR<BloqueoHorariosUpdateWithoutUsuariosInput, BloqueoHorariosUncheckedUpdateWithoutUsuariosInput>
    create: XOR<BloqueoHorariosCreateWithoutUsuariosInput, BloqueoHorariosUncheckedCreateWithoutUsuariosInput>
  }

  export type BloqueoHorariosUpdateWithWhereUniqueWithoutUsuariosInput = {
    where: BloqueoHorariosWhereUniqueInput
    data: XOR<BloqueoHorariosUpdateWithoutUsuariosInput, BloqueoHorariosUncheckedUpdateWithoutUsuariosInput>
  }

  export type BloqueoHorariosUpdateManyWithWhereWithoutUsuariosInput = {
    where: BloqueoHorariosScalarWhereInput
    data: XOR<BloqueoHorariosUpdateManyMutationInput, BloqueoHorariosUncheckedUpdateManyWithoutUsuariosInput>
  }

  export type BloqueoHorariosScalarWhereInput = {
    AND?: BloqueoHorariosScalarWhereInput | BloqueoHorariosScalarWhereInput[]
    OR?: BloqueoHorariosScalarWhereInput[]
    NOT?: BloqueoHorariosScalarWhereInput | BloqueoHorariosScalarWhereInput[]
    bloqueoID?: IntFilter<"BloqueoHorarios"> | number
    estilistaID?: IntNullableFilter<"BloqueoHorarios"> | number | null
    dia?: StringNullableFilter<"BloqueoHorarios"> | string | null
    horaInicio?: DateTimeNullableFilter<"BloqueoHorarios"> | Date | string | null
    horaFinal?: DateTimeNullableFilter<"BloqueoHorarios"> | Date | string | null
    motivo?: StringNullableFilter<"BloqueoHorarios"> | string | null
  }

  export type CitasUpsertWithWhereUniqueWithoutUsuarios_Citas_clienteIDToUsuariosInput = {
    where: CitasWhereUniqueInput
    update: XOR<CitasUpdateWithoutUsuarios_Citas_clienteIDToUsuariosInput, CitasUncheckedUpdateWithoutUsuarios_Citas_clienteIDToUsuariosInput>
    create: XOR<CitasCreateWithoutUsuarios_Citas_clienteIDToUsuariosInput, CitasUncheckedCreateWithoutUsuarios_Citas_clienteIDToUsuariosInput>
  }

  export type CitasUpdateWithWhereUniqueWithoutUsuarios_Citas_clienteIDToUsuariosInput = {
    where: CitasWhereUniqueInput
    data: XOR<CitasUpdateWithoutUsuarios_Citas_clienteIDToUsuariosInput, CitasUncheckedUpdateWithoutUsuarios_Citas_clienteIDToUsuariosInput>
  }

  export type CitasUpdateManyWithWhereWithoutUsuarios_Citas_clienteIDToUsuariosInput = {
    where: CitasScalarWhereInput
    data: XOR<CitasUpdateManyMutationInput, CitasUncheckedUpdateManyWithoutUsuarios_Citas_clienteIDToUsuariosInput>
  }

  export type CitasUpsertWithWhereUniqueWithoutUsuarios_Citas_estilistaIDToUsuariosInput = {
    where: CitasWhereUniqueInput
    update: XOR<CitasUpdateWithoutUsuarios_Citas_estilistaIDToUsuariosInput, CitasUncheckedUpdateWithoutUsuarios_Citas_estilistaIDToUsuariosInput>
    create: XOR<CitasCreateWithoutUsuarios_Citas_estilistaIDToUsuariosInput, CitasUncheckedCreateWithoutUsuarios_Citas_estilistaIDToUsuariosInput>
  }

  export type CitasUpdateWithWhereUniqueWithoutUsuarios_Citas_estilistaIDToUsuariosInput = {
    where: CitasWhereUniqueInput
    data: XOR<CitasUpdateWithoutUsuarios_Citas_estilistaIDToUsuariosInput, CitasUncheckedUpdateWithoutUsuarios_Citas_estilistaIDToUsuariosInput>
  }

  export type CitasUpdateManyWithWhereWithoutUsuarios_Citas_estilistaIDToUsuariosInput = {
    where: CitasScalarWhereInput
    data: XOR<CitasUpdateManyMutationInput, CitasUncheckedUpdateManyWithoutUsuarios_Citas_estilistaIDToUsuariosInput>
  }

  export type HistorialCitasUpsertWithWhereUniqueWithoutUsuariosInput = {
    where: HistorialCitasWhereUniqueInput
    update: XOR<HistorialCitasUpdateWithoutUsuariosInput, HistorialCitasUncheckedUpdateWithoutUsuariosInput>
    create: XOR<HistorialCitasCreateWithoutUsuariosInput, HistorialCitasUncheckedCreateWithoutUsuariosInput>
  }

  export type HistorialCitasUpdateWithWhereUniqueWithoutUsuariosInput = {
    where: HistorialCitasWhereUniqueInput
    data: XOR<HistorialCitasUpdateWithoutUsuariosInput, HistorialCitasUncheckedUpdateWithoutUsuariosInput>
  }

  export type HistorialCitasUpdateManyWithWhereWithoutUsuariosInput = {
    where: HistorialCitasScalarWhereInput
    data: XOR<HistorialCitasUpdateManyMutationInput, HistorialCitasUncheckedUpdateManyWithoutUsuariosInput>
  }

  export type HistorialRecompensasUpsertWithWhereUniqueWithoutUsuariosInput = {
    where: HistorialRecompensasWhereUniqueInput
    update: XOR<HistorialRecompensasUpdateWithoutUsuariosInput, HistorialRecompensasUncheckedUpdateWithoutUsuariosInput>
    create: XOR<HistorialRecompensasCreateWithoutUsuariosInput, HistorialRecompensasUncheckedCreateWithoutUsuariosInput>
  }

  export type HistorialRecompensasUpdateWithWhereUniqueWithoutUsuariosInput = {
    where: HistorialRecompensasWhereUniqueInput
    data: XOR<HistorialRecompensasUpdateWithoutUsuariosInput, HistorialRecompensasUncheckedUpdateWithoutUsuariosInput>
  }

  export type HistorialRecompensasUpdateManyWithWhereWithoutUsuariosInput = {
    where: HistorialRecompensasScalarWhereInput
    data: XOR<HistorialRecompensasUpdateManyMutationInput, HistorialRecompensasUncheckedUpdateManyWithoutUsuariosInput>
  }

  export type HorariosUpsertWithWhereUniqueWithoutUsuariosInput = {
    where: HorariosWhereUniqueInput
    update: XOR<HorariosUpdateWithoutUsuariosInput, HorariosUncheckedUpdateWithoutUsuariosInput>
    create: XOR<HorariosCreateWithoutUsuariosInput, HorariosUncheckedCreateWithoutUsuariosInput>
  }

  export type HorariosUpdateWithWhereUniqueWithoutUsuariosInput = {
    where: HorariosWhereUniqueInput
    data: XOR<HorariosUpdateWithoutUsuariosInput, HorariosUncheckedUpdateWithoutUsuariosInput>
  }

  export type HorariosUpdateManyWithWhereWithoutUsuariosInput = {
    where: HorariosScalarWhereInput
    data: XOR<HorariosUpdateManyMutationInput, HorariosUncheckedUpdateManyWithoutUsuariosInput>
  }

  export type HorariosScalarWhereInput = {
    AND?: HorariosScalarWhereInput | HorariosScalarWhereInput[]
    OR?: HorariosScalarWhereInput[]
    NOT?: HorariosScalarWhereInput | HorariosScalarWhereInput[]
    horariosID?: IntFilter<"Horarios"> | number
    estilistaID?: IntNullableFilter<"Horarios"> | number | null
    diaSemana?: StringNullableFilter<"Horarios"> | string | null
    horaInicio?: DateTimeNullableFilter<"Horarios"> | Date | string | null
    horaFinal?: DateTimeNullableFilter<"Horarios"> | Date | string | null
  }

  export type PuntosClientesUpsertWithWhereUniqueWithoutUsuariosInput = {
    where: PuntosClientesWhereUniqueInput
    update: XOR<PuntosClientesUpdateWithoutUsuariosInput, PuntosClientesUncheckedUpdateWithoutUsuariosInput>
    create: XOR<PuntosClientesCreateWithoutUsuariosInput, PuntosClientesUncheckedCreateWithoutUsuariosInput>
  }

  export type PuntosClientesUpdateWithWhereUniqueWithoutUsuariosInput = {
    where: PuntosClientesWhereUniqueInput
    data: XOR<PuntosClientesUpdateWithoutUsuariosInput, PuntosClientesUncheckedUpdateWithoutUsuariosInput>
  }

  export type PuntosClientesUpdateManyWithWhereWithoutUsuariosInput = {
    where: PuntosClientesScalarWhereInput
    data: XOR<PuntosClientesUpdateManyMutationInput, PuntosClientesUncheckedUpdateManyWithoutUsuariosInput>
  }

  export type PuntosClientesScalarWhereInput = {
    AND?: PuntosClientesScalarWhereInput | PuntosClientesScalarWhereInput[]
    OR?: PuntosClientesScalarWhereInput[]
    NOT?: PuntosClientesScalarWhereInput | PuntosClientesScalarWhereInput[]
    puntosID?: IntFilter<"PuntosClientes"> | number
    clienteID?: IntNullableFilter<"PuntosClientes"> | number | null
    puntosAcumulados?: IntNullableFilter<"PuntosClientes"> | number | null
    puntosCanjeados?: IntNullableFilter<"PuntosClientes"> | number | null
  }

  export type RolesUpsertWithoutUsuariosInput = {
    update: XOR<RolesUpdateWithoutUsuariosInput, RolesUncheckedUpdateWithoutUsuariosInput>
    create: XOR<RolesCreateWithoutUsuariosInput, RolesUncheckedCreateWithoutUsuariosInput>
    where?: RolesWhereInput
  }

  export type RolesUpdateToOneWithWhereWithoutUsuariosInput = {
    where?: RolesWhereInput
    data: XOR<RolesUpdateWithoutUsuariosInput, RolesUncheckedUpdateWithoutUsuariosInput>
  }

  export type RolesUpdateWithoutUsuariosInput = {
    nombreRol?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RolesUncheckedUpdateWithoutUsuariosInput = {
    rolID?: IntFieldUpdateOperationsInput | number
    nombreRol?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ActividadClienteCreateManyCitasInput = {
    clienteID?: number | null
    ultimaConexion?: Date | string | null
  }

  export type DetallesCitaCreateManyCitasInput = {
    servicioID?: number | null
  }

  export type HistorialCitasCreateManyCitasInput = {
    clienteID?: number | null
  }

  export type ActividadClienteUpdateWithoutCitasInput = {
    ultimaConexion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Usuarios?: UsuariosUpdateOneWithoutActividadClienteNestedInput
  }

  export type ActividadClienteUncheckedUpdateWithoutCitasInput = {
    actividadID?: IntFieldUpdateOperationsInput | number
    clienteID?: NullableIntFieldUpdateOperationsInput | number | null
    ultimaConexion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ActividadClienteUncheckedUpdateManyWithoutCitasInput = {
    actividadID?: IntFieldUpdateOperationsInput | number
    clienteID?: NullableIntFieldUpdateOperationsInput | number | null
    ultimaConexion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DetallesCitaUpdateWithoutCitasInput = {
    Servicios?: ServiciosUpdateOneWithoutDetallesCitaNestedInput
  }

  export type DetallesCitaUncheckedUpdateWithoutCitasInput = {
    detalleID?: IntFieldUpdateOperationsInput | number
    servicioID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DetallesCitaUncheckedUpdateManyWithoutCitasInput = {
    detalleID?: IntFieldUpdateOperationsInput | number
    servicioID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type HistorialCitasUpdateWithoutCitasInput = {
    Usuarios?: UsuariosUpdateOneWithoutHistorialCitasNestedInput
  }

  export type HistorialCitasUncheckedUpdateWithoutCitasInput = {
    historialCitasID?: IntFieldUpdateOperationsInput | number
    clienteID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type HistorialCitasUncheckedUpdateManyWithoutCitasInput = {
    historialCitasID?: IntFieldUpdateOperationsInput | number
    clienteID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CitasCreateManyEstadoCitaInput = {
    clienteID?: number | null
    estilistaID?: number | null
    comentarios?: string | null
  }

  export type CitasUpdateWithoutEstadoCitaInput = {
    comentarios?: NullableStringFieldUpdateOperationsInput | string | null
    ActividadCliente?: ActividadClienteUpdateManyWithoutCitasNestedInput
    Usuarios_Citas_clienteIDToUsuarios?: UsuariosUpdateOneWithoutCitas_Citas_clienteIDToUsuariosNestedInput
    Usuarios_Citas_estilistaIDToUsuarios?: UsuariosUpdateOneWithoutCitas_Citas_estilistaIDToUsuariosNestedInput
    DetallesCita?: DetallesCitaUpdateManyWithoutCitasNestedInput
    HistorialCitas?: HistorialCitasUpdateManyWithoutCitasNestedInput
    HorariosReservados?: HorariosReservadosUpdateOneWithoutCitasNestedInput
  }

  export type CitasUncheckedUpdateWithoutEstadoCitaInput = {
    citaID?: IntFieldUpdateOperationsInput | number
    clienteID?: NullableIntFieldUpdateOperationsInput | number | null
    estilistaID?: NullableIntFieldUpdateOperationsInput | number | null
    comentarios?: NullableStringFieldUpdateOperationsInput | string | null
    ActividadCliente?: ActividadClienteUncheckedUpdateManyWithoutCitasNestedInput
    DetallesCita?: DetallesCitaUncheckedUpdateManyWithoutCitasNestedInput
    HistorialCitas?: HistorialCitasUncheckedUpdateManyWithoutCitasNestedInput
    HorariosReservados?: HorariosReservadosUncheckedUpdateOneWithoutCitasNestedInput
  }

  export type CitasUncheckedUpdateManyWithoutEstadoCitaInput = {
    citaID?: IntFieldUpdateOperationsInput | number
    clienteID?: NullableIntFieldUpdateOperationsInput | number | null
    estilistaID?: NullableIntFieldUpdateOperationsInput | number | null
    comentarios?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UsuariosCreateManyRolesInput = {
    nombre: string
    apellidos: string
    telefono?: string | null
    correo: string
    direccion?: string | null
    contra: string
    estado?: string | null
  }

  export type UsuariosUpdateWithoutRolesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    contra?: StringFieldUpdateOperationsInput | string
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    ActividadCliente?: ActividadClienteUpdateManyWithoutUsuariosNestedInput
    BitacoraCliente?: BitacoraClienteUpdateManyWithoutUsuariosNestedInput
    BitacoraEstilista?: BitacoraEstilistaUpdateManyWithoutUsuariosNestedInput
    BloqueoHorarios?: BloqueoHorariosUpdateManyWithoutUsuariosNestedInput
    Citas_Citas_clienteIDToUsuarios?: CitasUpdateManyWithoutUsuarios_Citas_clienteIDToUsuariosNestedInput
    Citas_Citas_estilistaIDToUsuarios?: CitasUpdateManyWithoutUsuarios_Citas_estilistaIDToUsuariosNestedInput
    HistorialCitas?: HistorialCitasUpdateManyWithoutUsuariosNestedInput
    HistorialRecompensas?: HistorialRecompensasUpdateManyWithoutUsuariosNestedInput
    Horarios?: HorariosUpdateManyWithoutUsuariosNestedInput
    PuntosClientes?: PuntosClientesUpdateManyWithoutUsuariosNestedInput
  }

  export type UsuariosUncheckedUpdateWithoutRolesInput = {
    usuarioID?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    contra?: StringFieldUpdateOperationsInput | string
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    ActividadCliente?: ActividadClienteUncheckedUpdateManyWithoutUsuariosNestedInput
    BitacoraCliente?: BitacoraClienteUncheckedUpdateManyWithoutUsuariosNestedInput
    BitacoraEstilista?: BitacoraEstilistaUncheckedUpdateManyWithoutUsuariosNestedInput
    BloqueoHorarios?: BloqueoHorariosUncheckedUpdateManyWithoutUsuariosNestedInput
    Citas_Citas_clienteIDToUsuarios?: CitasUncheckedUpdateManyWithoutUsuarios_Citas_clienteIDToUsuariosNestedInput
    Citas_Citas_estilistaIDToUsuarios?: CitasUncheckedUpdateManyWithoutUsuarios_Citas_estilistaIDToUsuariosNestedInput
    HistorialCitas?: HistorialCitasUncheckedUpdateManyWithoutUsuariosNestedInput
    HistorialRecompensas?: HistorialRecompensasUncheckedUpdateManyWithoutUsuariosNestedInput
    Horarios?: HorariosUncheckedUpdateManyWithoutUsuariosNestedInput
    PuntosClientes?: PuntosClientesUncheckedUpdateManyWithoutUsuariosNestedInput
  }

  export type UsuariosUncheckedUpdateManyWithoutRolesInput = {
    usuarioID?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    contra?: StringFieldUpdateOperationsInput | string
    estado?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DetallesCitaCreateManyServiciosInput = {
    citaID?: number | null
  }

  export type HistorialRecompensasCreateManyServiciosInput = {
    clienteID?: number | null
    puntosCanjeados?: number | null
    fecha?: Date | string | null
  }

  export type DetallesCitaUpdateWithoutServiciosInput = {
    Citas?: CitasUpdateOneWithoutDetallesCitaNestedInput
  }

  export type DetallesCitaUncheckedUpdateWithoutServiciosInput = {
    detalleID?: IntFieldUpdateOperationsInput | number
    citaID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DetallesCitaUncheckedUpdateManyWithoutServiciosInput = {
    detalleID?: IntFieldUpdateOperationsInput | number
    citaID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type HistorialRecompensasUpdateWithoutServiciosInput = {
    puntosCanjeados?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Usuarios?: UsuariosUpdateOneWithoutHistorialRecompensasNestedInput
  }

  export type HistorialRecompensasUncheckedUpdateWithoutServiciosInput = {
    historialID?: IntFieldUpdateOperationsInput | number
    clienteID?: NullableIntFieldUpdateOperationsInput | number | null
    puntosCanjeados?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type HistorialRecompensasUncheckedUpdateManyWithoutServiciosInput = {
    historialID?: IntFieldUpdateOperationsInput | number
    clienteID?: NullableIntFieldUpdateOperationsInput | number | null
    puntosCanjeados?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ActividadClienteCreateManyUsuariosInput = {
    ultimaConexion?: Date | string | null
    ultimaCitaID?: number | null
  }

  export type BitacoraClienteCreateManyUsuariosInput = {
    fechaRegistro?: Date | string | null
  }

  export type BitacoraEstilistaCreateManyUsuariosInput = {
    fechaIngreso?: Date | string | null
    fechaSalida?: Date | string | null
  }

  export type BloqueoHorariosCreateManyUsuariosInput = {
    dia?: string | null
    horaInicio?: Date | string | null
    horaFinal?: Date | string | null
    motivo?: string | null
  }

  export type CitasCreateManyUsuarios_Citas_clienteIDToUsuariosInput = {
    estilistaID?: number | null
    comentarios?: string | null
    estadoID?: number | null
  }

  export type CitasCreateManyUsuarios_Citas_estilistaIDToUsuariosInput = {
    clienteID?: number | null
    comentarios?: string | null
    estadoID?: number | null
  }

  export type HistorialCitasCreateManyUsuariosInput = {
    citaID?: number | null
  }

  export type HistorialRecompensasCreateManyUsuariosInput = {
    servicioID?: number | null
    puntosCanjeados?: number | null
    fecha?: Date | string | null
  }

  export type HorariosCreateManyUsuariosInput = {
    diaSemana?: string | null
    horaInicio?: Date | string | null
    horaFinal?: Date | string | null
  }

  export type PuntosClientesCreateManyUsuariosInput = {
    puntosAcumulados?: number | null
    puntosCanjeados?: number | null
  }

  export type ActividadClienteUpdateWithoutUsuariosInput = {
    ultimaConexion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Citas?: CitasUpdateOneWithoutActividadClienteNestedInput
  }

  export type ActividadClienteUncheckedUpdateWithoutUsuariosInput = {
    actividadID?: IntFieldUpdateOperationsInput | number
    ultimaConexion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimaCitaID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ActividadClienteUncheckedUpdateManyWithoutUsuariosInput = {
    actividadID?: IntFieldUpdateOperationsInput | number
    ultimaConexion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimaCitaID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BitacoraClienteUpdateWithoutUsuariosInput = {
    fechaRegistro?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BitacoraClienteUncheckedUpdateWithoutUsuariosInput = {
    bitacoraID?: IntFieldUpdateOperationsInput | number
    fechaRegistro?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BitacoraClienteUncheckedUpdateManyWithoutUsuariosInput = {
    bitacoraID?: IntFieldUpdateOperationsInput | number
    fechaRegistro?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BitacoraEstilistaUpdateWithoutUsuariosInput = {
    fechaIngreso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaSalida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BitacoraEstilistaUncheckedUpdateWithoutUsuariosInput = {
    bitacoraID?: IntFieldUpdateOperationsInput | number
    fechaIngreso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaSalida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BitacoraEstilistaUncheckedUpdateManyWithoutUsuariosInput = {
    bitacoraID?: IntFieldUpdateOperationsInput | number
    fechaIngreso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaSalida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BloqueoHorariosUpdateWithoutUsuariosInput = {
    dia?: NullableStringFieldUpdateOperationsInput | string | null
    horaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horaFinal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BloqueoHorariosUncheckedUpdateWithoutUsuariosInput = {
    bloqueoID?: IntFieldUpdateOperationsInput | number
    dia?: NullableStringFieldUpdateOperationsInput | string | null
    horaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horaFinal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BloqueoHorariosUncheckedUpdateManyWithoutUsuariosInput = {
    bloqueoID?: IntFieldUpdateOperationsInput | number
    dia?: NullableStringFieldUpdateOperationsInput | string | null
    horaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horaFinal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CitasUpdateWithoutUsuarios_Citas_clienteIDToUsuariosInput = {
    comentarios?: NullableStringFieldUpdateOperationsInput | string | null
    ActividadCliente?: ActividadClienteUpdateManyWithoutCitasNestedInput
    EstadoCita?: EstadoCitaUpdateOneWithoutCitasNestedInput
    Usuarios_Citas_estilistaIDToUsuarios?: UsuariosUpdateOneWithoutCitas_Citas_estilistaIDToUsuariosNestedInput
    DetallesCita?: DetallesCitaUpdateManyWithoutCitasNestedInput
    HistorialCitas?: HistorialCitasUpdateManyWithoutCitasNestedInput
    HorariosReservados?: HorariosReservadosUpdateOneWithoutCitasNestedInput
  }

  export type CitasUncheckedUpdateWithoutUsuarios_Citas_clienteIDToUsuariosInput = {
    citaID?: IntFieldUpdateOperationsInput | number
    estilistaID?: NullableIntFieldUpdateOperationsInput | number | null
    comentarios?: NullableStringFieldUpdateOperationsInput | string | null
    estadoID?: NullableIntFieldUpdateOperationsInput | number | null
    ActividadCliente?: ActividadClienteUncheckedUpdateManyWithoutCitasNestedInput
    DetallesCita?: DetallesCitaUncheckedUpdateManyWithoutCitasNestedInput
    HistorialCitas?: HistorialCitasUncheckedUpdateManyWithoutCitasNestedInput
    HorariosReservados?: HorariosReservadosUncheckedUpdateOneWithoutCitasNestedInput
  }

  export type CitasUncheckedUpdateManyWithoutUsuarios_Citas_clienteIDToUsuariosInput = {
    citaID?: IntFieldUpdateOperationsInput | number
    estilistaID?: NullableIntFieldUpdateOperationsInput | number | null
    comentarios?: NullableStringFieldUpdateOperationsInput | string | null
    estadoID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CitasUpdateWithoutUsuarios_Citas_estilistaIDToUsuariosInput = {
    comentarios?: NullableStringFieldUpdateOperationsInput | string | null
    ActividadCliente?: ActividadClienteUpdateManyWithoutCitasNestedInput
    Usuarios_Citas_clienteIDToUsuarios?: UsuariosUpdateOneWithoutCitas_Citas_clienteIDToUsuariosNestedInput
    EstadoCita?: EstadoCitaUpdateOneWithoutCitasNestedInput
    DetallesCita?: DetallesCitaUpdateManyWithoutCitasNestedInput
    HistorialCitas?: HistorialCitasUpdateManyWithoutCitasNestedInput
    HorariosReservados?: HorariosReservadosUpdateOneWithoutCitasNestedInput
  }

  export type CitasUncheckedUpdateWithoutUsuarios_Citas_estilistaIDToUsuariosInput = {
    citaID?: IntFieldUpdateOperationsInput | number
    clienteID?: NullableIntFieldUpdateOperationsInput | number | null
    comentarios?: NullableStringFieldUpdateOperationsInput | string | null
    estadoID?: NullableIntFieldUpdateOperationsInput | number | null
    ActividadCliente?: ActividadClienteUncheckedUpdateManyWithoutCitasNestedInput
    DetallesCita?: DetallesCitaUncheckedUpdateManyWithoutCitasNestedInput
    HistorialCitas?: HistorialCitasUncheckedUpdateManyWithoutCitasNestedInput
    HorariosReservados?: HorariosReservadosUncheckedUpdateOneWithoutCitasNestedInput
  }

  export type CitasUncheckedUpdateManyWithoutUsuarios_Citas_estilistaIDToUsuariosInput = {
    citaID?: IntFieldUpdateOperationsInput | number
    clienteID?: NullableIntFieldUpdateOperationsInput | number | null
    comentarios?: NullableStringFieldUpdateOperationsInput | string | null
    estadoID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type HistorialCitasUpdateWithoutUsuariosInput = {
    Citas?: CitasUpdateOneWithoutHistorialCitasNestedInput
  }

  export type HistorialCitasUncheckedUpdateWithoutUsuariosInput = {
    historialCitasID?: IntFieldUpdateOperationsInput | number
    citaID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type HistorialCitasUncheckedUpdateManyWithoutUsuariosInput = {
    historialCitasID?: IntFieldUpdateOperationsInput | number
    citaID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type HistorialRecompensasUpdateWithoutUsuariosInput = {
    puntosCanjeados?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Servicios?: ServiciosUpdateOneWithoutHistorialRecompensasNestedInput
  }

  export type HistorialRecompensasUncheckedUpdateWithoutUsuariosInput = {
    historialID?: IntFieldUpdateOperationsInput | number
    servicioID?: NullableIntFieldUpdateOperationsInput | number | null
    puntosCanjeados?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type HistorialRecompensasUncheckedUpdateManyWithoutUsuariosInput = {
    historialID?: IntFieldUpdateOperationsInput | number
    servicioID?: NullableIntFieldUpdateOperationsInput | number | null
    puntosCanjeados?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type HorariosUpdateWithoutUsuariosInput = {
    diaSemana?: NullableStringFieldUpdateOperationsInput | string | null
    horaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horaFinal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type HorariosUncheckedUpdateWithoutUsuariosInput = {
    horariosID?: IntFieldUpdateOperationsInput | number
    diaSemana?: NullableStringFieldUpdateOperationsInput | string | null
    horaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horaFinal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type HorariosUncheckedUpdateManyWithoutUsuariosInput = {
    horariosID?: IntFieldUpdateOperationsInput | number
    diaSemana?: NullableStringFieldUpdateOperationsInput | string | null
    horaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horaFinal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PuntosClientesUpdateWithoutUsuariosInput = {
    puntosAcumulados?: NullableIntFieldUpdateOperationsInput | number | null
    puntosCanjeados?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PuntosClientesUncheckedUpdateWithoutUsuariosInput = {
    puntosID?: IntFieldUpdateOperationsInput | number
    puntosAcumulados?: NullableIntFieldUpdateOperationsInput | number | null
    puntosCanjeados?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PuntosClientesUncheckedUpdateManyWithoutUsuariosInput = {
    puntosID?: IntFieldUpdateOperationsInput | number
    puntosAcumulados?: NullableIntFieldUpdateOperationsInput | number | null
    puntosCanjeados?: NullableIntFieldUpdateOperationsInput | number | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use CitasCountOutputTypeDefaultArgs instead
     */
    export type CitasCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CitasCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EstadoCitaCountOutputTypeDefaultArgs instead
     */
    export type EstadoCitaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EstadoCitaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RolesCountOutputTypeDefaultArgs instead
     */
    export type RolesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RolesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiciosCountOutputTypeDefaultArgs instead
     */
    export type ServiciosCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiciosCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsuariosCountOutputTypeDefaultArgs instead
     */
    export type UsuariosCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsuariosCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ActividadClienteDefaultArgs instead
     */
    export type ActividadClienteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ActividadClienteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BitacoraClienteDefaultArgs instead
     */
    export type BitacoraClienteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BitacoraClienteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BitacoraEstilistaDefaultArgs instead
     */
    export type BitacoraEstilistaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BitacoraEstilistaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BloqueoHorariosDefaultArgs instead
     */
    export type BloqueoHorariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BloqueoHorariosDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CitasDefaultArgs instead
     */
    export type CitasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CitasDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DetallesCitaDefaultArgs instead
     */
    export type DetallesCitaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DetallesCitaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EstadoCitaDefaultArgs instead
     */
    export type EstadoCitaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EstadoCitaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HistorialCitasDefaultArgs instead
     */
    export type HistorialCitasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HistorialCitasDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HistorialRecompensasDefaultArgs instead
     */
    export type HistorialRecompensasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HistorialRecompensasDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HorariosDefaultArgs instead
     */
    export type HorariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HorariosDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HorariosReservadosDefaultArgs instead
     */
    export type HorariosReservadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HorariosReservadosDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PuntosClientesDefaultArgs instead
     */
    export type PuntosClientesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PuntosClientesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PuntosServicioDefaultArgs instead
     */
    export type PuntosServicioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PuntosServicioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RolesDefaultArgs instead
     */
    export type RolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RolesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiciosDefaultArgs instead
     */
    export type ServiciosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiciosDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsuariosDefaultArgs instead
     */
    export type UsuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsuariosDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}